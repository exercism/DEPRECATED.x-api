{
  "track": {
    "language": "Ruby",
    "active": true,
    "id": "ruby",
    "slug": "ruby",
    "problems": [
      "ruby/hamming",
      "ruby/gigasecond",
      "ruby/rna-transcription",
      "ruby/raindrops",
      "ruby/difference-of-squares",
      "ruby/roman-numerals",
      "ruby/robot-name",
      "ruby/nth-prime",
      "ruby/leap",
      "ruby/grains",
      "ruby/word-count",
      "ruby/bob",
      "ruby/food-chain",
      "ruby/sieve",
      "ruby/binary",
      "ruby/accumulate",
      "ruby/sum-of-multiples",
      "ruby/grade-school",
      "ruby/series",
      "ruby/phone-number",
      "ruby/prime-factors",
      "ruby/strain",
      "ruby/etl",
      "ruby/trinary",
      "ruby/beer-song",
      "ruby/space-age",
      "ruby/anagram",
      "ruby/binary-search-tree",
      "ruby/crypto-square",
      "ruby/clock",
      "ruby/scrabble-score",
      "ruby/nucleotide-count",
      "ruby/hexadecimal",
      "ruby/say",
      "ruby/meetup",
      "ruby/queen-attack",
      "ruby/palindrome-products",
      "ruby/matrix",
      "ruby/saddle-points",
      "ruby/triangle",
      "ruby/atbash-cipher",
      "ruby/house",
      "ruby/secret-handshake",
      "ruby/proverb",
      "ruby/ocr-numbers",
      "ruby/pig-latin",
      "ruby/simple-linked-list",
      "ruby/luhn",
      "ruby/simple-cipher",
      "ruby/wordy",
      "ruby/allergies",
      "ruby/kindergarten-garden",
      "ruby/linked-list",
      "ruby/pythagorean-triplet",
      "ruby/robot-simulator",
      "ruby/twelve-days",
      "ruby/circular-buffer",
      "ruby/largest-series-product",
      "ruby/binary-search",
      "ruby/pascals-triangle",
      "ruby/custom-set",
      "ruby/minesweeper",
      "ruby/scale-generator",
      "ruby/protein-translation"
    ],
    "repository": "https://github.com/exercism/xruby"
  },
  "problems": [
    {
      "id": "ruby/hamming",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "hamming",
      "name": "Hamming",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\n## Step 1\n\nRun the test suite. It's in Minitest, and can be run with ruby:\n\n    $ ruby hamming_test.rb\n\nThis will fail, complaining that there is no file called `hamming`.\n\nTo fix the error create an empty file called `hamming.rb` in the same\ndirectory as the `hamming_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error.\n\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    NameError: uninitialized constant Hamming\n        hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\nWithin the first test, we are referencing a constant named `Hamming` when\nwe say `Hamming.compute('A', 'A')`. When Ruby sees a capitalized name like\n`Hamming`, it looks it up in a big huge list of all the constants it knows about,\nto see what it points to. It could point to anything, and often in Ruby we have\nconstants that point to definitions of classes or modules.\n\nWhen it looks `Hamming` up in it's list, it doesn't find anything, so we need to make\none.\n\nThere are several ways that this error message can be made to go\naway, one of which is to define a `Hamming` class.\n\nOpen up the hamming.rb file and add the following code:\n\n    class Hamming\n    end\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    NoMethodError: undefined method `compute' for #<Hamming:0x007fa531343e50>\n        hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\n\nThis time we have a `Hamming`, but we're trying tell it to `compute`, and\n`Hamming` doesn't understand that message.\n\nOpen up hamming.rb and add a method definition inside the class:\n\n    class Hamming\n      def self.compute\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Error:\n    HammingTest#test_no_difference_between_identical_strands:\n    ArgumentError: wrong number of arguments (2 for 0)\n      in `compute' hamming_test.rb:12:in `test_no_difference_between_identical_strands'\n\nThe method `compute` needs to take two arguments.\n\nThese are examples of method definitions that take arguments:\n\n    def self.greet(name)\n    end\n\n    def self.drink(beverage,size)\n    end\n\nChange the `compute` method definition so it takes two arguments.\n\n## Step 5\n\nRun the test again.\n\n    1) Failure:\n    HammingTest#test_no_difference_between_identical_strands [hamming_test.rb:12]:\n    Expected: 0\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that Ruby cannot even run properly because of things like missing\nfiles or syntax errors, or referring to things that don't exist.\n\nA failure is differentâ€”when you have a failure the Ruby is running just fine,\nbut the test is expecting one outcome, but getting another.\n\nThe test is expecting the `compute` method to return the number 0. The easiest way\nto make it pass, is to simply stick the number 0 inside the method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the hamming_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rinse, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hamming.rb\n\n",
        "hamming_test.rb": "require 'minitest/autorun'\nbegin\n  require_relative 'hamming'\nrescue LoadError => e\n  puts \"\\n\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\nclass HammingTest < Minitest::Test\n  def test_no_difference_between_identical_strands\n    assert_equal 0, Hamming.compute('A', 'A')\n  end\n\n  def test_complete_hamming_distance_of_for_single_nucleotide_strand\n    skip\n    assert_equal 1, Hamming.compute('A', 'G')\n  end\n\n  def test_complete_hamming_distance_of_for_small_strand\n    skip\n    assert_equal 2, Hamming.compute('AG', 'CT')\n  end\n\n  def test_small_hamming_distance\n    skip\n    assert_equal 1, Hamming.compute('AT', 'CT')\n  end\n\n  def test_small_hamming_distance_in_longer_strand\n    skip\n    assert_equal 1, Hamming.compute('GGACG', 'GGTCG')\n  end\n\n  def test_nonunique_characters_within_first_strand\n    skip\n    assert_equal 1, Hamming.compute('AGA', 'AGG')\n  end\n\n  def test_nonunique_characters_within_second_strand\n    skip\n    assert_equal 1, Hamming.compute('AGG', 'AGA')\n  end\n\n  def test_large_hamming_distance\n    skip\n    assert_equal 4, Hamming.compute('GATACA', 'GCATAA')\n  end\n\n  def test_hamming_distance_in_very_long_strand\n    skip\n    assert_equal 9, Hamming.compute('GGACGGATTCTG', 'AGGACGGATTCT')\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n      cannot load such file\n\nIt's looking for a file named hamming.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named hamming.rb\nin the same directory as the hamming_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/gigasecond",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "gigasecond",
      "name": "Gigasecond",
      "files": {
        "gigasecond_test.rb": "require 'minitest/autorun'\nrequire 'date'\nrequire 'time'\n\nrequire_relative 'gigasecond'\nclass GigasecondTest < Minitest::Test\n  def test_1\n    gs = Gigasecond.from(Time.utc(2011, 4, 25))\n    assert_equal Time.utc(2043, 1, 1, 1, 46, 40), gs\n  end\n\n  def test_2\n    skip\n    gs = Gigasecond.from(Time.utc(1977, 6, 13))\n    assert_equal Time.utc(2009, 2, 19, 1, 46, 40), gs\n  end\n\n  def test_3\n    skip\n    gs = Gigasecond.from(Time.utc(1959, 7, 19))\n    assert_equal Time.utc(1991, 3, 27, 1, 46, 40), gs\n  end\n\n  def test_4_with_seconds\n    skip\n    gs = Gigasecond.from(Time.utc(1959, 7, 19, 23, 59, 59))\n    assert_equal Time.utc(1991, 3, 28, 1, 46, 39), gs\n  end\n\n  # modify the test to test your 1 Gs anniversary\n  def test_5_with_your_birthday\n    skip\n    your_birthday = Time.utc(year, month, day)\n    gs = Gigasecond.from(your_birthday)\n    assert_equal Time.utc(2009, 1, 31, 1, 46, 39), gs\n  end\nend\n",
        "README.md": "# Gigasecond\n\nWrite a program that will calculate the date that someone turned or will celebrate their 1 Gs anniversary.\n\nA gigasecond is one billion (10**9) seconds.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nChapter 9 in Chris Pine's online Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=09)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/rna-transcription",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "rna-transcription",
      "name": "Rna Transcription",
      "files": {
        "complement_test.rb": "require 'minitest/autorun'\nrequire_relative 'complement'\n\nclass ComplementTest < Minitest::Test\n  def test_rna_complement_of_cytosine_is_guanine\n    assert_equal 'G', Complement.of_dna('C')\n  end\n\n  def test_rna_complement_of_guanine_is_cytosine\n    skip\n    assert_equal 'C', Complement.of_dna('G')\n  end\n\n  def test_rna_complement_of_thymine_is_adenine\n    skip\n    assert_equal 'A', Complement.of_dna('T')\n  end\n\n  def test_rna_complement_of_adenine_is_uracil\n    skip\n    assert_equal 'U', Complement.of_dna('A')\n  end\n\n  def test_rna_complement\n    skip\n    assert_equal 'UGCACCAGAAUU', Complement.of_dna('ACGTGGTCTTAA')\n  end\n\n  def test_dna_complement_of_cytosine_is_guanine\n    skip\n    assert_equal 'G', Complement.of_rna('C')\n  end\n\n  def test_dna_complement_of_guanine_is_cytosine\n    skip\n    assert_equal 'C', Complement.of_rna('G')\n  end\n\n  def test_dna_complement_of_uracil_is_adenine\n    skip\n    assert_equal 'A', Complement.of_rna('U')\n  end\n\n  def test_dna_complement_of_adenine_is_thymine\n    skip\n    assert_equal 'T', Complement.of_rna('A')\n  end\n\n  def test_dna_complement\n    skip\n    assert_equal 'ACTTGGGCTGTAC', Complement.of_rna('UGAACCCGACAUG')\n  end\n\n  def test_dna_raises_argument_error\n    skip\n    assert_raises(ArgumentError){ Complement.of_dna('U') }\n  end\n\n  def test_rna_raises_argument_error\n    skip\n    assert_raises(ArgumentError){ Complement.of_rna('T') }\n  end\nend\n",
        "README.md": "# Rna Transcription\n\nWrite a program that, given a DNA strand, returns its RNA complement (per RNA transcription).\n\nBoth DNA and RNA strands are a sequence of nucleotides.\n\nThe four nucleotides found in DNA are adenine (**A**), cytosine (**C**),\nguanine (**G**) and thymine (**T**).\n\nThe four nucleotides found in RNA are adenine (**A**), cytosine (**C**),\nguanine (**G**) and uracil (**U**).\n\nGiven a DNA strand, its transcribed RNA strand is formed by replacing\neach nucleotide with its complement:\n\n* `G` -> `C`\n* `C` -> `G`\n* `T` -> `A`\n* `A` -> `U`\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nRosalind [view source](http://rosalind.info/problems/rna)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/raindrops",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "raindrops",
      "name": "Raindrops",
      "files": {
        "raindrops_test.rb": "require 'minitest/autorun'\nrequire_relative 'raindrops'\n\nclass RaindropsTest < Minitest::Test\n  def test_1\n    assert_equal '1', Raindrops.convert(1)\n  end\n\n  def test_3\n    skip\n    assert_equal 'Pling', Raindrops.convert(3)\n  end\n\n  def test_5\n    skip\n    assert_equal 'Plang', Raindrops.convert(5)\n  end\n\n  def test_7\n    skip\n    assert_equal 'Plong', Raindrops.convert(7)\n  end\n\n  def test_6\n    skip\n    assert_equal 'Pling', Raindrops.convert(6)\n  end\n\n  def test_9\n    skip\n    assert_equal 'Pling', Raindrops.convert(9)\n  end\n\n  def test_10\n    skip\n    assert_equal 'Plang', Raindrops.convert(10)\n  end\n\n  def test_14\n    skip\n    assert_equal 'Plong', Raindrops.convert(14)\n  end\n\n  def test_15\n    skip\n    assert_equal 'PlingPlang', Raindrops.convert(15)\n  end\n\n  def test_21\n    skip\n    assert_equal 'PlingPlong', Raindrops.convert(21)\n  end\n\n  def test_25\n    skip\n    assert_equal 'Plang', Raindrops.convert(25)\n  end\n\n  def test_35\n    skip\n    assert_equal 'PlangPlong', Raindrops.convert(35)\n  end\n\n  def test_49\n    skip\n    assert_equal 'Plong', Raindrops.convert(49)\n  end\n\n  def test_52\n    skip\n    assert_equal '52', Raindrops.convert(52)\n  end\n\n  def test_105\n    skip\n    assert_equal 'PlingPlangPlong', Raindrops.convert(105)\n  end\n\n  def test_12121\n    skip\n    assert_equal '12121', Raindrops.convert(12_121)\n  end\nend\n",
        "README.md": "# Raindrops\n\nWrite a program that converts a number to a string, the contents of which depends on the number's prime factors.\n\n- If the number contains 3 as a prime factor, output 'Pling'.\n- If the number contains 5 as a prime factor, output 'Plang'.\n- If the number contains 7 as a prime factor, output 'Plong'.\n- If the number does not contain 3, 5, or 7 as a prime factor,\n  just pass the number's digits straight through.\n\n## Examples\n\n- 28's prime-factorization is 2, 2, 7.\n  - In raindrop-speak, this would be a simple \"Plong\".\n- 1755 prime-factorization is 3, 3, 3, 5, 13.\n  - In raindrop-speak, this would be a \"PlingPlang\".\n- The prime factors of 34 are 2 and 17.\n  - Raindrop-speak doesn't know what to make of that,\n    so it just goes with the straightforward \"34\".\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA variation on a famous interview question intended to weed out potential candidates. [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/difference-of-squares",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "difference-of-squares",
      "name": "Difference Of Squares",
      "files": {
        "difference_of_squares_test.rb": "require 'minitest/autorun'\nrequire_relative 'squares'\n\nclass SquaresTest < Minitest::Test\n  def test_square_of_sums_to_5\n    assert_equal 225, Squares.new(5).square_of_sums\n  end\n\n  def test_sum_of_squares_to_5\n    skip\n    assert_equal 55, Squares.new(5).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_5\n    skip\n    assert_equal 170, Squares.new(5).difference\n  end\n\n  def test_square_of_sums_to_10\n    skip\n    assert_equal 3025, Squares.new(10).square_of_sums\n  end\n\n  def test_sum_of_squares_to_10\n    skip\n    assert_equal 385, Squares.new(10).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_10\n    skip\n    assert_equal 2640, Squares.new(10).difference\n  end\n\n  def test_square_of_sums_to_100\n    skip\n    assert_equal 25_502_500, Squares.new(100).square_of_sums\n  end\n\n  def test_sum_of_squares_to_100\n    skip\n    assert_equal 338_350, Squares.new(100).sum_of_squares\n  end\n\n  def test_difference_of_sums_to_100\n    skip\n    assert_equal 25_164_150, Squares.new(100).difference\n  end\n\n  def test_consistent_difference\n    skip\n    squares = Squares.new(10)\n    assert_equal squares.difference, squares.difference\n  end\nend\n",
        "README.md": "# Difference Of Squares\n\nFind the difference between the sum of the squares and the square of the sums of the first N natural numbers.\n\nThe sum of the squares of the first ten natural numbers is,\n\n    1**2 + 2**2 + ... + 10**2 = 385\n\nThe square of the sum of the first ten natural numbers is,\n\n    (1 + 2 + ... + 10)**2 = 55**2 = 3025\n\nHence the difference between the sum of the squares of the first ten\nnatural numbers and the square of the sum is 3025 - 385 = 2640.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nProblem 6 at Project Euler [view source](http://projecteuler.net/problem=6)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/roman-numerals",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "roman-numerals",
      "name": "Roman Numerals",
      "files": {
        "roman_numerals_test.rb": "require 'minitest/autorun'\nrequire_relative 'roman'\n\nclass RomanTest < Minitest::Test\n  def test_1\n    assert_equal 'I', 1.to_roman\n  end\n\n  def test_2\n    skip\n    assert_equal 'II', 2.to_roman\n  end\n\n  def test_3\n    skip\n    assert_equal 'III', 3.to_roman\n  end\n\n  def test_4\n    skip\n    assert_equal 'IV', 4.to_roman\n  end\n\n  def test_5\n    skip\n    assert_equal 'V', 5.to_roman\n  end\n\n  def test_6\n    skip\n    assert_equal 'VI', 6.to_roman\n  end\n\n  def test_9\n    skip\n    assert_equal 'IX', 9.to_roman\n  end\n\n  def test_27\n    skip\n    assert_equal 'XXVII', 27.to_roman\n  end\n\n  def test_48\n    skip\n    assert_equal 'XLVIII', 48.to_roman\n  end\n\n  def test_59\n    skip\n    assert_equal 'LIX', 59.to_roman\n  end\n\n  def test_93\n    skip\n    assert_equal 'XCIII', 93.to_roman\n  end\n\n  def test_141\n    skip\n    assert_equal 'CXLI', 141.to_roman\n  end\n\n  def test_163\n    skip\n    assert_equal 'CLXIII', 163.to_roman\n  end\n\n  def test_402\n    skip\n    assert_equal 'CDII', 402.to_roman\n  end\n\n  def test_575\n    skip\n    assert_equal 'DLXXV', 575.to_roman\n  end\n\n  def test_911\n    skip\n    assert_equal 'CMXI', 911.to_roman\n  end\n\n  def test_1024\n    skip\n    assert_equal 'MXXIV', 1024.to_roman\n  end\n\n  def test_3000\n    skip\n    assert_equal 'MMM', 3000.to_roman\n  end\nend\n",
        "README.md": "# Roman Numerals\n\nWrite a function to convert from normal numbers to Roman Numerals: e.g.\n\nThe Romans were a clever bunch. They conquered most of Europe and ruled\nit for hundreds of years. They invented concrete and straight roads and\neven bikinis. One thing they never discovered though was the number\nzero. This made writing and dating extensive histories of their exploits\nslightly more challenging, but the system of numbers they came up with\nis still in use today. For example the BBC uses Roman numerals to date\ntheir programmes.\n\nThe Romans wrote numbers using letters - I, V, X, L, C, D, M. (notice\nthese letters have lots of straight lines and are hence easy to hack\ninto stone tablets).\n\n```\n 1  => I\n10  => X\n 7  => VII\n```\n\nThere is no need to be able to convert numbers larger than about 3000.\n(The Romans themselves didn't tend to go any higher)\n\nWikipedia says: Modern Roman numerals ... are written by expressing each\ndigit separately starting with the left most digit and skipping any\ndigit with a value of zero.\n\nTo see this in practice, consider the example of 1990.\n\nIn Roman numerals 1990 is MCMXC:\n\n1000=M\n900=CM\n90=XC\n\n2008 is written as MMVIII:\n\n2000=MM\n8=VIII\n\nSee also: http://www.novaroma.org/via_romana/numbers.html\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Roman Numeral Kata [view source](http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/robot-name",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "robot-name",
      "name": "Robot Name",
      "files": {
        "robot_name_test.rb": "require 'minitest/autorun'\nrequire_relative 'robot'\n\nclass RobotTest < Minitest::Test\n  def test_has_name\n    # rubocop:disable Lint/AmbiguousRegexpLiteral\n    assert_match /^[A-Z]{2}\\d{3}$/, Robot.new.name\n    # rubocop:enable Lint/AmbiguousRegexpLiteral\n  end\n\n  def test_name_sticks\n    skip\n    robot = Robot.new\n    robot.name\n    assert_equal robot.name, robot.name\n  end\n\n  def test_different_robots_have_different_names\n    skip\n    # rubocop:disable Lint/UselessComparison\n    assert Robot.new.name != Robot.new.name\n    # rubocop:enable Lint/UselessComparison\n  end\n\n  def test_reset_name\n    skip\n    robot = Robot.new\n    name = robot.name\n    robot.reset\n    name2 = robot.name\n    assert name != name2\n    # rubocop:disable Lint/AmbiguousRegexpLiteral\n    assert_match /^[A-Z]{2}\\d{3}$/, name2\n    # rubocop:enable Lint/AmbiguousRegexpLiteral\n  end\nend\n",
        "README.md": "# Robot Name\n\nWrite a program that manages robot factory settings.\n\nWhen robots come off the factory floor, they have no name.\n\nThe first time you boot them up, a random name is generated, such as\nRX837 or BC811.\n\nEvery once in a while we need to reset a robot to its factory settings,\nwhich means that their name gets wiped. The next time you ask, it gets a\nnew name.\n\nRandom names means a risk of collisions. In some exercism language\ntracks there are tests to ensure that the same name is never used twice.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA debugging session with Paul Blackwell at gSchool. [view source](http://gschool.it)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/nth-prime",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "nth-prime",
      "name": "Nth Prime",
      "files": {
        "nth_prime_test.rb": "require 'minitest/autorun'\nrequire_relative 'prime'\n\nclass TestPrimes < Minitest::Test\n  def test_first\n    assert_equal 2, Prime.nth(1)\n  end\n\n  def test_second\n    skip\n    assert_equal 3, Prime.nth(2)\n  end\n\n  def test_sixth_prime\n    skip\n    assert_equal 13, Prime.nth(6)\n  end\n\n  def test_big_prime\n    skip\n    assert_equal 104_743, Prime.nth(10_001)\n  end\n\n  def test_weird_case\n    skip\n    assert_raises ArgumentError do\n      Prime.nth(0)\n    end\n  end\nend\n",
        "README.md": "# Nth Prime\n\nWrite a program that can tell you what the nth prime is.\n\nBy listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that\nthe 6th prime is 13.\n\nIf your language provides methods in the standard library to deal with prime\nnumbers, pretend it doesn't exist and implement it yourself.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA variation on Problem 7 at Project Euler [view source](http://projecteuler.net/problem=7)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/leap",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "leap_test.rb": "require 'date'\nrequire 'minitest/autorun'\nrequire_relative 'year'\n\nclass Date\n  def leap?\n    throw \"Implement this yourself instead of using Ruby's implementation.\"\n  end\n\n  alias_method :gregorian_leap?, :leap?\n  alias_method :julian_leap?, :leap?\nend\n\nclass YearTest < Minitest::Test\n  def test_leap_year\n    assert Year.leap?(1996), 'Yes, 1996 is a leap year'\n  end\n\n  def test_non_leap_year\n    skip\n    refute Year.leap?(1997), 'No, 1997 is not a leap year'\n  end\n\n  def test_non_leap_even_year\n    skip\n    refute Year.leap?(1998), 'No, 1998 is not a leap year'\n  end\n\n  def test_century\n    skip\n    refute Year.leap?(1900), 'No, 1900 is not a leap year'\n  end\n\n  def test_fourth_century\n    skip\n    assert Year.leap?(2400), 'Yes, 2400 is a leap year'\n  end\nend\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/grains",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "grains",
      "name": "Grains",
      "files": {
        "grains_test.rb": "require 'minitest/autorun'\nrequire_relative 'grains'\n\nclass GrainsTest < Minitest::Test\n  def test_square_1\n    assert_equal 1, Grains.new.square(1)\n  end\n\n  def test_square_2\n    skip\n    assert_equal 2, Grains.new.square(2)\n  end\n\n  def test_square_3\n    skip\n    assert_equal 4, Grains.new.square(3)\n  end\n\n  def test_square_4\n    skip\n    assert_equal 8, Grains.new.square(4)\n  end\n\n  def test_square_16\n    skip\n    assert_equal 32_768, Grains.new.square(16)\n  end\n\n  def test_square_32\n    skip\n    assert_equal 2_147_483_648, Grains.new.square(32)\n  end\n\n  def test_square_64\n    skip\n    assert_equal 9_223_372_036_854_775_808, Grains.new.square(64)\n  end\n\n  def test_total_grains\n    skip\n    assert_equal 18_446_744_073_709_551_615, Grains.new.total\n  end\nend\n",
        "README.md": "# Grains\n\nWrite a program that calculates the number of grains of wheat on a chessboard given that the number on each square doubles.\n\nThere once was a wise servant who saved the life of a prince. The king\npromised to pay whatever the servant could dream up. Knowing that the\nking loved chess, the servant told the king he would like to have grains\nof wheat. One grain on the first square of a chess board. Two grains on\nthe next. Four on the third, and so on.\n\nThere are 64 squares on a chessboard.\n\nWrite a program that shows:\n- how many grains were on each square, and\n- the total number of grains\n\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n- Optimize for speed.\n- Optimize for readability.\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJavaRanch Cattle Drive, exercise 6 [view source](http://www.javaranch.com/grains.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/word-count",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "word-count",
      "name": "Word Count",
      "files": {
        "word_count_test.rb": "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < Minitest::Test\n  def test_count_one_word\n    phrase = Phrase.new('word')\n    counts = { 'word' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new('one of each')\n    counts = { 'one' => 1, 'of' => 1, 'each' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new('one fish two fish red fish blue fish')\n    counts = { 'one' => 1, 'fish' => 4, 'two' => 1, 'red' => 1, 'blue' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new('all the kings horses and all the kings men')\n    phrase.word_count # count it an extra time\n    counts = {\n      'all' => 2, 'the' => 2, 'kings' => 2,\n      'horses' => 1, 'and' => 1, 'men' => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new('car : carpet as java : javascript!!&@$%^&')\n    counts = {\n      'car' => 1, 'carpet' => 1, 'as' => 1,\n      'java' => 1, 'javascript' => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new('one,two,three')\n    counts = { 'one' => 1, 'two' => 1, 'three' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_expanded_lists\n    skip\n    phrase = Phrase.new(\"one,\\ntwo,\\nthree\")\n    counts = { 'one' => 1, 'two' => 1, 'three' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new('testing, 1, 2 testing')\n    counts = { 'testing' => 2, '1' => 1, '2' => 1 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new('go Go GO')\n    counts = { 'go' => 3 }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\n      'first' => 1, \"don't\" => 2, 'laugh' => 1,\n      'then' => 1, 'cry' => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\nend\n",
        "README.md": "# Word Count\n\nWrite a program that given a phrase can count the occurrences of each word in that phrase.\n\nFor example for the input `\"olly olly in come free\"`\n\n```plain\nolly: 2\nin: 1\ncome: 1\nfree: 1\n```\n\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe golang tour [view source](http://tour.golang.org)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/bob",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob_test.rb": "require 'minitest/autorun'\nrequire_relative 'bob'\n\nclass BobTest < Minitest::Test\n  def bob\n    ::Bob.new\n  end\n\n  def feedback(text)\n    \"Bob hears #{text.inspect}, and..\"\n  end\n\n  def test_stating_something\n    remark = 'Tom-ay-to, tom-aaaah-to.'\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_shouting\n    skip\n    remark = 'WATCH OUT!'\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_shouting_gibberish\n    skip\n    remark = ('A'..'Z').to_a.shuffle[0, 10].join\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_asking_a_question\n    skip\n    remark = 'Does this cryogenic chamber make me look fat?'\n    assert_equal 'Sure.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_asking_a_numeric_question\n    skip\n    remark = 'You are, what, like 15?'\n    assert_equal 'Sure.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_asking_gibberish\n    skip\n    remark = ('a'..'z').to_a.shuffle[0, 10].join << '?'\n    assert_equal 'Sure.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_talking_forcefully\n    skip\n    remark = \"Let's go make out behind the gym!\"\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_using_acronyms_in_regular_speech\n    skip\n    remark = \"It's OK if you don't want to go to the DMV.\"\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_forceful_questions\n    skip\n    remark = 'WHAT THE HELL WERE YOU THINKING?'\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_shouting_numbers\n    skip\n    remark = '1, 2, 3 GO!'\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_only_numbers\n    skip\n    remark = '1, 2, 3'\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_question_with_only_numbers\n    skip\n    remark = '4?'\n    assert_equal 'Sure.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_shouting_with_special_characters\n    skip\n    remark = 'ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!'\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_shouting_with_no_exclamation_mark\n    skip\n    remark = 'I HATE YOU'\n    assert_equal 'Whoa, chill out!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_statement_containing_question_mark\n    skip\n    remark = 'Ending with ? means a question.'\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_prattling_on\n    skip\n    remark = 'Wait! Hang on. Are you going to be OK?'\n    assert_equal 'Sure.', bob.hey(remark), feedback(remark)\n  end\n\n  def test_silence\n    skip\n    remark = ''\n    assert_equal 'Fine. Be that way!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_prolonged_silence\n    skip\n    remark = ' ' * rand(1..10)\n    assert_equal 'Fine. Be that way!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_alternate_silences\n    skip\n    remark = \"\\t\" * rand(1..10)\n    assert_equal 'Fine. Be that way!', bob.hey(remark), feedback(remark)\n  end\n\n  def test_on_multiple_line_questions\n    skip\n    remark = %(\nDoes this cryogenic chamber make me look fat?\nno)\n    assert_equal 'Whatever.', bob.hey(remark), feedback(remark)\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/food-chain",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "food-chain",
      "name": "Food Chain",
      "files": {
        "food_chain_test.rb": "require 'minitest/autorun'\nrequire_relative 'food_chain'\n\n# rubocop:disable Metrics/MethodLength, Metrics/LineLength\nclass FoodChainTest < Minitest::Test\n  attr_reader :song\n  def song\n    @song = ::FoodChainSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  def test_fly\n    expected = \"I know an old lady who swallowed a fly.\\nI don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_spider\n    skip\n    expected = \"I know an old lady who swallowed a spider.\\nIt wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_bird\n    skip\n    expected = \"I know an old lady who swallowed a bird.\\n\" \\\n      \"How absurd to swallow a bird!\\n\" \\\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_cat\n    skip\n    expected = \"I know an old lady who swallowed a cat.\\n\" \\\n      \"Imagine that, to swallow a cat!\\n\" \\\n      \"She swallowed the cat to catch the bird.\\n\" \\\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. \" \\\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(4)\n  end\n\n  def test_dog\n    skip\n    expected = \"I know an old lady who swallowed a dog.\\n\" \\\n      \"What a hog, to swallow a dog!\\n\" \\\n      \"She swallowed the dog to catch the cat.\\n\" \\\n      \"She swallowed the cat to catch the bird.\\n\" \\\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. \" \\\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(5)\n  end\n\n  def test_goat\n    skip\n    expected = \"I know an old lady who swallowed a goat.\\n\" \\\n      \"Just opened her throat and swallowed a goat!\\n\" \\\n      \"She swallowed the goat to catch the dog.\\n\" \\\n      \"She swallowed the dog to catch the cat.\\n\" \\\n      \"She swallowed the cat to catch the bird.\\n\" \\\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. \" \\\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(6)\n  end\n\n  def test_cow\n    skip\n    expected = \"I know an old lady who swallowed a cow.\\n\" \\\n      \"I don't know how she swallowed a cow!\\n\" \\\n      \"She swallowed the cow to catch the goat.\\n\" \\\n      \"She swallowed the goat to catch the dog.\\n\" \\\n      \"She swallowed the dog to catch the cat.\\n\" \\\n      \"She swallowed the cat to catch the bird.\\n\" \\\n      \"She swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. \" \\\n      \"Perhaps she'll die.\\n\"\n    assert_equal expected, song.verse(7)\n  end\n\n  def test_horse\n    skip\n    expected = \"I know an old lady who swallowed a horse.\\n\" \\\n      \"She's dead, of course!\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_multiple_verses\n    skip\n    expected = ''\n    expected << \"I know an old lady who swallowed a fly.\\nI don't know why she swallowed the fly. Perhaps she'll die.\\n\\n\"\n    expected << \"I know an old lady who swallowed a spider.\\nIt wriggled and jiggled and tickled inside her.\\n\" \\\n      \"She swallowed the spider to catch the fly.\\n\" \\\n      \"I don't know why she swallowed the fly. Perhaps she'll die.\\n\\n\"\n    assert_equal expected, song.verses(1, 2)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(1, 8), song.sing\n  end\nend\n",
        "README.md": "# Food Chain\n\nWrite a program that outputs the lyrics of the song 'I Know an Old Lady Who Swallowed a Fly'\n\nThis is a [cumulative song](http://en.wikipedia.org/wiki/Cumulative_song) of unknown origin.\n\nThis is one of many common variants.\n\n```plain\nI know an old lady who swallowed a fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a spider.\nIt wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a bird.\nHow absurd to swallow a bird!\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a cat.\nImagine that, to swallow a cat!\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a dog.\nWhat a hog, to swallow a dog!\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a goat.\nJust opened her throat and swallowed a goat!\nShe swallowed the goat to catch the dog.\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a cow.\nI don't know how she swallowed a cow!\nShe swallowed the cow to catch the goat.\nShe swallowed the goat to catch the dog.\nShe swallowed the dog to catch the cat.\nShe swallowed the cat to catch the bird.\nShe swallowed the bird to catch the spider that wriggled and jiggled and tickled inside her.\nShe swallowed the spider to catch the fly.\nI don't know why she swallowed the fly. Perhaps she'll die.\n\nI know an old lady who swallowed a horse.\nShe's dead, of course!\n```\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/There_Was_an_Old_Lady_Who_Swallowed_a_Fly)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/sieve",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "sieve",
      "name": "Sieve",
      "files": {
        "sieve_test.rb": "require 'minitest/autorun'\nrequire_relative 'sieve'\n\nclass SieveTest < Minitest::Test\n  def test_a_few_primes\n    expected = [2, 3, 5, 7]\n    assert_equal expected, Sieve.new(10).primes\n  end\n\n  def test_primes # rubocop:disable Metrics/MethodLength\n    skip\n    expected = [\n      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\n      61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\n      131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191,\n      193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\n      263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331,\n      337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\n      409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,\n      479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\n      569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631,\n      641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,\n      719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\n      809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\n      881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967,\n      971, 977, 983, 991, 997\n    ]\n    assert_equal expected, Sieve.new(1000).primes\n  end\nend\n",
        "README.md": "# Sieve\n\nWrite a program that uses the Sieve of Eratosthenes to find all the primes from 2 up to a given number.\n\nThe Sieve of Eratosthenes is a simple, ancient algorithm for finding all\nprime numbers up to any given limit. It does so by iteratively marking as\ncomposite (i.e. not prime) the multiples of each prime,\nstarting with the multiples of 2.\n\nCreate your range, starting at two and continuing up to and including the given limit. (i.e. [2, limit])\n\nThe algorithm consists of repeating the following over and over:\n\n- take the next available unmarked number in your list (it is prime)\n- mark all the multiples of that number (they are not prime)\n\nRepeat until you have processed each number in your range.\n\nWhen the algorithm terminates, all the numbers in the list that have not\nbeen marked are prime.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nSieve of Eratosthenes at Wikipedia [view source](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/binary",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "binary",
      "name": "Binary",
      "files": {
        "binary_test.rb": "require 'minitest/autorun'\nrequire_relative 'binary'\n\nclass BinaryTest < Minitest::Test\n  def test_binary_1_is_decimal_1\n    assert_equal 1, Binary.new('1').to_decimal\n  end\n\n  def test_binary_10_is_decimal_2\n    skip\n    assert_equal 2, Binary.new('10').to_decimal\n  end\n\n  def test_binary_11_is_decimal_3\n    skip\n    assert_equal 3, Binary.new('11').to_decimal\n  end\n\n  def test_binary_100_is_decimal_4\n    skip\n    assert_equal 4, Binary.new('100').to_decimal\n  end\n\n  def test_binary_1001_is_decimal_9\n    skip\n    assert_equal 9, Binary.new('1001').to_decimal\n  end\n\n  def test_binary_11010_is_decimal_26\n    skip\n    assert_equal 26, Binary.new('11010').to_decimal\n  end\n\n  def test_binary_10001101000_is_decimal_1128\n    skip\n    assert_equal 1128, Binary.new('10001101000').to_decimal\n  end\n\n  def test_invalid_binary_is_decimal_0\n    skip\n    assert_equal 0, Binary.new('carrot123').to_decimal\n  end\nend\n",
        "README.md": "# Binary\n\nWrite a program that will convert a binary number, represented as a string (e.g. '101010'), to its decimal equivalent using first principles\n\nImplement binary to decimal conversion.  Given a binary input\nstring, your program should produce a decimal output.\n\n## Note\n- Implement the conversion yourself.\n  Do not use something else to perform the conversion for you.\n- Treat invalid input as binary 0.\n\n## About Binary (Base-2)\nDecimal is a base-10 system.\n\nA number 23 in base 10 notation can be understood\nas a linear combination of powers of 10:\n\n- The rightmost digit gets multiplied by 10^0 = 1\n- The next number gets multiplied by 10^1 = 10\n- ...\n- The *n*th number gets multiplied by 10^*(n-1)*.\n- All these values are summed.\n\nSo: `23 => 2*10^1 + 3*10^0 => 2*10 + 3*1 = 23 base 10`\n\nBinary is similar, but uses powers of 2 rather than powers of 10.\n\nSo: `101 => 1*2^2 + 0*2^1 + 1*2^0 => 1*4 + 0*2 + 1*1 => 4 + 1 => 5 base 10`.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/input/?i=binary&a=*C.binary-_*MathWorld-)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/accumulate",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "accumulate",
      "name": "Accumulate",
      "files": {
        "accumulate_test.rb": "require 'minitest/autorun'\nrequire_relative 'array'\n\nclass ArrayTest < Minitest::Test\n  def test_empty_accumulation\n    assert_equal [], [].accumulate { |e| e * e }\n  end\n\n  def test_accumulate_squares\n    skip\n    result = [1, 2, 3].accumulate do |number|\n      number * number\n    end\n    assert_equal [1, 4, 9], result\n  end\n\n  def test_accumulate_upcases\n    skip\n    result = %w(hello world).accumulate(&:upcase)\n    assert_equal %w(HELLO WORLD), result\n  end\n\n  def test_accumulate_reversed_strings\n    skip\n    result = %w(the quick brown fox etc).accumulate(&:reverse)\n    assert_equal %w(eht kciuq nworb xof cte), result\n  end\n\n  def test_accumulate_recursively\n    skip\n    result = %w(a b c).accumulate do |char|\n      %w(1 2 3).accumulate do |digit|\n        \"#{char}#{digit}\"\n      end\n    end\n    assert_equal [%w(a1 a2 a3), %w(b1 b2 b3), %w(c1 c2 c3)], result\n  end\nend\n",
        "README.md": "# Accumulate\n\nImplement the `accumulate` operation, which, given a collection and an operation to perform on each element of the collection, returns a new collection containing the result of applying that operation to each element of the input collection.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the operation:\n\n- square a number\n\nYour code should be able to produce the collection of squares:\n\n- 1, 4, 9, 16, 25\n\n## Restrictions\n\nKeep your hands off that collect/map/fmap/whatchamacallit functionality\nprovided by your standard library!\nSolve this one yourself using other basic tools instead.\n\nElixir specific: it's perfectly fine to use `Enum.reduce` or\n`Enumerable.reduce`.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nConversation with James Edward Gray II [view source](https://twitter.com/jeg2)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/sum-of-multiples",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "sum-of-multiples",
      "name": "Sum Of Multiples",
      "files": {
        "sum_of_multiples_test.rb": "require 'minitest/autorun'\nrequire_relative 'sum'\n\nclass SumTest < Minitest::Test\n  def test_sum_to_1\n    assert_equal 0, SumOfMultiples.to(1)\n  end\n\n  def test_sum_to_3\n    skip\n    assert_equal 3, SumOfMultiples.to(4)\n  end\n\n  def test_sum_to_10\n    skip\n    assert_equal 23, SumOfMultiples.to(10)\n  end\n\n  def test_sum_to_1000\n    skip\n    assert_equal 233_168, SumOfMultiples.to(1000)\n  end\n\n  def test_configurable_7_13_17_to_20\n    skip\n    assert_equal 51, SumOfMultiples.new(7, 13, 17).to(20)\n  end\n\n  def test_configurable_43_47_to_10000\n    skip\n    assert_equal 2_203_160, SumOfMultiples.new(43, 47).to(10_000)\n  end\nend\n",
        "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of 3 or 5 up to but not including that number.\n\nIf we list all the natural numbers below 10 that are multiples of 3 or\n5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nAllow the program to be configured to find the sum of multiples of\nnumbers other than 3 and 5.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/grade-school",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "grade-school",
      "name": "Grade School",
      "files": {
        "grade_school_test.rb": "require 'minitest/autorun'\nrequire_relative 'school'\n\nclass SchoolTest < Minitest::Test\n  attr_reader :school\n\n  def setup\n    @school = School.new\n  end\n\n  def test_an_empty_school\n    assert_equal({}, school.to_hash)\n  end\n\n  def test_add_student\n    skip\n    school.add('Aimee', 2)\n    assert_equal({ 2 => ['Aimee'] }, school.to_hash)\n  end\n\n  def test_add_more_students_in_same_class\n    skip\n    school.add('Blair', 2)\n    school.add('James', 2)\n    school.add('Paul', 2)\n    assert_equal({ 2 => %w(Blair James Paul) }, school.to_hash)\n  end\n\n  def test_add_students_to_different_grades\n    skip\n    school.add('Chelsea', 3)\n    school.add('Logan', 7)\n    assert_equal({ 3 => ['Chelsea'], 7 => ['Logan'] }, school.to_hash)\n  end\n\n  def test_get_students_in_a_grade\n    skip\n    school.add('Bradley', 5)\n    school.add('Franklin', 5)\n    school.add('Jeff', 1)\n    assert_equal %w(Bradley Franklin), school.grade(5)\n  end\n\n  def test_get_students_sorted_in_a_grade\n    skip\n    school.add('Franklin', 5)\n    school.add('Bradley', 5)\n    school.add('Jeff', 1)\n    assert_equal %w(Bradley Franklin), school.grade(5)\n  end\n\n  def test_get_students_in_a_non_existant_grade\n    skip\n    assert_equal [], school.grade(1)\n  end\n\n  def test_sort_school # rubocop:disable Metrics/MethodLength\n    skip\n    [\n      ['Jennifer', 4], ['Kareem', 6],\n      ['Christopher', 4], ['Kyle', 3]\n    ].each do |name, grade|\n      school.add(name, grade)\n    end\n    sorted = {\n      3 => ['Kyle'],\n      4 => %w(Christopher Jennifer),\n      6 => ['Kareem']\n    }\n    assert_equal sorted, school.to_hash\n    assert_equal [3, 4, 6], school.to_hash.keys\n  end\nend\n",
        "README.md": "# Grade School\n\nWrite a small archiving program that stores students' names along with the grade that they are in.\n\nIn the end, you should be able to:\n\n- Add a student's name to the roster for a grade\n  - \"Add Jim to grade 2.\"\n  - \"OK.\"\n- Get a list of all students enrolled in a grade\n  - \"Which students are in grade 2?\"\n  - \"We've only got Jim just now.\"\n- Get a sorted list of all students in all grades.  Grades should sort\n  as 1, 2, 3, etc., and students within a grade should be sorted\n  alphabetically by name.\n  - \"Who all is enrolled in school right now?\"\n  - \"Grade 1: Anna, Barb, and Charlie. Grade 2: Alex, Peter, and Zoe.\n    Grade 3â€¦\"\n\nNote that all our students only have one name.  (It's a small town, what\ndo you want?)\n\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n- If you're working in a language with mutable data structures and your\n  implementation allows outside code to mutate the school's internal DB\n  directly, see if you can prevent this. Feel free to introduce additional\n  tests.\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA pairing session with Phil Battos at gSchool [view source](http://gschool.it)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/series",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "series",
      "name": "Series",
      "files": {
        "series_test.rb": "require 'minitest/autorun'\nrequire_relative 'series'\n\nclass SeriesTest < Minitest::Test\n  def test_simple_slices_of_one\n    series = Series.new('01234')\n    assert_equal [[0], [1], [2], [3], [4]], series.slices(1)\n  end\n\n  def test_simple_slices_of_one_again\n    skip\n    series = Series.new('92834')\n    assert_equal [[9], [2], [8], [3], [4]], series.slices(1)\n  end\n\n  def test_simple_slices_of_two\n    skip\n    series = Series.new('01234')\n    assert_equal [[0, 1], [1, 2], [2, 3], [3, 4]], series.slices(2)\n  end\n\n  def test_other_slices_of_two\n    skip\n    series = Series.new('98273463')\n    expected = [[9, 8], [8, 2], [2, 7], [7, 3], [3, 4], [4, 6], [6, 3]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_simple_slices_of_two_again\n    skip\n    series = Series.new('37103')\n    assert_equal [[3, 7], [7, 1], [1, 0], [0, 3]], series.slices(2)\n  end\n\n  def test_simple_slices_of_three\n    skip\n    series = Series.new('01234')\n    assert_equal [[0, 1, 2], [1, 2, 3], [2, 3, 4]], series.slices(3)\n  end\n\n  def test_simple_slices_of_three_again\n    skip\n    series = Series.new('31001')\n    assert_equal [[3, 1, 0], [1, 0, 0], [0, 0, 1]], series.slices(3)\n  end\n\n  def test_other_slices_of_three\n    skip\n    series = Series.new('982347')\n    expected = [[9, 8, 2], [8, 2, 3], [2, 3, 4], [3, 4, 7]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_simple_slices_of_four\n    skip\n    series = Series.new('01234')\n    assert_equal [[0, 1, 2, 3], [1, 2, 3, 4]], series.slices(4)\n  end\n\n  def test_simple_slices_of_four_again\n    skip\n    series = Series.new('91274')\n    assert_equal [[9, 1, 2, 7], [1, 2, 7, 4]], series.slices(4)\n  end\n\n  def test_simple_slices_of_five\n    skip\n    series = Series.new('01234')\n    assert_equal [[0, 1, 2, 3, 4]], series.slices(5)\n  end\n\n  def test_simple_slices_of_five_again\n    skip\n    series = Series.new('81228')\n    assert_equal [[8, 1, 2, 2, 8]], series.slices(5)\n  end\n\n  def test_simple_slice_that_blows_up\n    skip\n    series = Series.new('01234')\n    assert_raises ArgumentError do\n      series.slices(6)\n    end\n  end\n\n  def test_more_complicated_slice_that_blows_up\n    skip\n    slice_string = '01032987583'\n\n    series = Series.new(slice_string)\n    assert_raises ArgumentError do\n      series.slices(slice_string.length + 1)\n    end\n  end\nend\n",
        "README.md": "# Series\n\nWrite a program that will take a string of digits and give you all the possible consecutive number series of length `n` in that string.\n\nFor example, the string \"01234\" has the following 3-digit series:\n\n- 012\n- 123\n- 234\n\nAnd the following 4-digit series:\n\n- 0123\n- 1234\n\nAnd if you ask for a 6-digit series from a 5-digit string, you deserve\nwhatever you get.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA subset of the Problem 8 at Project Euler [view source](http://projecteuler.net/problem=8)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/phone-number",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "phone-number",
      "name": "Phone Number",
      "files": {
        "phone_number_test.rb": "require 'minitest/autorun'\nrequire_relative 'phone_number'\n\nclass PhoneNumberTest < Minitest::Test\n  def test_cleans_number\n    number = PhoneNumber.new('(123) 456-7890').number\n    assert_equal '1234567890', number\n  end\n\n  def test_cleans_a_different_number\n    skip\n    number = PhoneNumber.new('(987) 654-3210').number\n    assert_equal '9876543210', number\n  end\n\n  def test_cleans_number_with_dots\n    skip\n    number = PhoneNumber.new('456.123.7890').number\n    assert_equal '4561237890', number\n  end\n\n  def test_invalid_with_letters_in_place_of_numbers\n    skip\n    number = PhoneNumber.new('123-abc-1234').number\n    assert_equal '0000000000', number\n  end\n\n  def test_invalid_when_9_digits\n    skip\n    number = PhoneNumber.new('123456789').number\n    assert_equal '0000000000', number\n  end\n\n  def test_valid_when_11_digits_and_first_is_1\n    skip\n    number = PhoneNumber.new('19876543210').number\n    assert_equal '9876543210', number\n  end\n\n  def test_invalid_when_11_digits\n    skip\n    number = PhoneNumber.new('21234567890').number\n    assert_equal '0000000000', number\n  end\n\n  def test_invalid_when_12_digits_and_first_is_1\n    skip\n    number = PhoneNumber.new('112345678901').number\n    assert_equal '0000000000', number\n  end\n\n  def test_invalid_when_10_digits_with_extra_letters\n    skip\n    number = PhoneNumber.new('1a2a3a4a5a6a7a8a9a0a').number\n    assert_equal '0000000000', number\n  end\n\n  def test_area_code\n    skip\n    number = PhoneNumber.new('1234567890')\n    assert_equal '123', number.area_code\n  end\n\n  def test_different_area_code\n    skip\n    number = PhoneNumber.new('9876543210')\n    assert_equal '987', number.area_code\n  end\n\n  def test_pretty_print\n    skip\n    number = PhoneNumber.new('5551234567')\n    assert_equal '(555) 123-4567', number.to_s\n  end\n\n  def test_pretty_print_with_full_us_phone_number\n    skip\n    number = PhoneNumber.new('11234567890')\n    assert_equal '(123) 456-7890', number.to_s\n  end\nend\n",
        "README.md": "# Phone Number\n\nWrite a program that cleans up user-entered phone numbers so that they can be sent SMS messages.\n\nThe rules are as follows:\n\n- If the phone number is less than 10 digits assume that it is bad\n  number\n- If the phone number is 10 digits assume that it is good\n- If the phone number is 11 digits and the first number is 1, trim the 1\n  and use the last 10 digits\n- If the phone number is 11 digits and the first number is not 1, then\n  it is a bad number\n- If the phone number is more than 11 digits assume that it is a bad\n  number\n\nWe've provided tests, now make them pass.\n\nHint: Only make one test pass at a time. Disable the others, then flip\neach on in turn after you get the current failing one to pass.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nEvent Manager by JumpstartLab [view source](http://tutorials.jumpstartlab.com/projects/eventmanager.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/prime-factors",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "prime-factors",
      "name": "Prime Factors",
      "files": {
        "prime_factors_test.rb": "require 'minitest/autorun'\nrequire_relative 'prime_factors'\n\nclass PrimeFactorsTest < Minitest::Test\n  def test_1\n    assert_equal [], PrimeFactors.for(1)\n  end\n\n  def test_2\n    skip\n    assert_equal [2], PrimeFactors.for(2)\n  end\n\n  def test_3\n    skip\n    assert_equal [3], PrimeFactors.for(3)\n  end\n\n  def test_4\n    skip\n    assert_equal [2, 2], PrimeFactors.for(4)\n  end\n\n  def test_6\n    skip\n    assert_equal [2, 3], PrimeFactors.for(6)\n  end\n\n  def test_8\n    skip\n    assert_equal [2, 2, 2], PrimeFactors.for(8)\n  end\n\n  def test_9\n    skip\n    assert_equal [3, 3], PrimeFactors.for(9)\n  end\n\n  def test_27\n    skip\n    assert_equal [3, 3, 3], PrimeFactors.for(27)\n  end\n\n  def test_625\n    skip\n    assert_equal [5, 5, 5, 5], PrimeFactors.for(625)\n  end\n\n  def test_901255\n    skip\n    assert_equal [5, 17, 23, 461], PrimeFactors.for(901_255)\n  end\n\n  def test_93819012551\n    skip\n    assert_equal [11, 9539, 894_119], PrimeFactors.for(93_819_012_551)\n  end\nend\n",
        "README.md": "# Prime Factors\n\nCompute the prime factors of a given natural number.\n\nA prime number is only evenly divisible by itself and 1.\n\nNote that 1 is not a prime number.\n\n## Example\n\nWhat are the prime factors of 60?\n\n- Our first divisor is 2. 2 goes into 60, leaving 30.\n- 2 goes into 30, leaving 15.\n  - 2 doesn't go cleanly into 15. So let's move on to our next divisor, 3.\n- 3 goes cleanly into 15, leaving 5.\n  - 3 does not go cleanly into 5. The next possible factor is 4.\n  - 4 does not go cleanly into 5. The next possible factor is 5.\n- 5 does go cleanly into 5.\n- We're left only with 1, so now, we're done.\n\nOur successful divisors in that computation represent the list of prime\nfactors of 60: 2, 2, 3, and 5.\n\nYou can check this yourself:\n\n- 2 * 2 * 3 * 5\n- = 4 * 15\n- = 60\n- Success!\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Prime Factors Kata by Uncle Bob [view source](http://butunclebob.com/ArticleS.UncleBob.ThePrimeFactorsKata)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/strain",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "strain",
      "name": "Strain",
      "files": {
        "strain_test.rb": "require 'minitest/autorun'\nrequire_relative 'array'\n\nclass ArrayTest < Minitest::Test\n  def test_empty_keep\n    assert_equal [], [].keep { |e| e < 10 }\n  end\n\n  def test_keep_everything\n    skip\n    assert_equal [1, 2, 3], [1, 2, 3].keep { |e| e < 10 }\n  end\n\n  def test_keep_first_and_last\n    skip\n    assert_equal [1, 3], [1, 2, 3].keep(&:odd?)\n  end\n\n  def test_keep_neither_first_nor_last\n    skip\n    assert_equal [2, 4], [1, 2, 3, 4, 5].keep(&:even?)\n  end\n\n  def test_keep_strings\n    skip\n    words = %w(apple zebra banana zombies cherimoya zelot)\n    result = words.keep { |word| word.start_with?('z') }\n    assert_equal %w(zebra zombies zelot), result\n  end\n\n  def test_keep_arrays # rubocop:disable Metrics/MethodLength\n    skip\n    rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5]\n    ]\n    result = rows.keep { |row| row.include?(5) }\n    assert_equal [[5, 5, 5], [5, 1, 2], [1, 5, 2], [1, 2, 5]], result\n  end\n\n  def test_empty_discard\n    skip\n    assert_equal [], [].discard { |e| e < 10 }\n  end\n\n  def test_discard_nothing\n    skip\n    assert_equal [1, 2, 3], [1, 2, 3].discard { |e| e > 10 }\n  end\n\n  def test_discard_first_and_last\n    skip\n    assert_equal [2], [1, 2, 3].discard(&:odd?)\n  end\n\n  def test_discard_neither_first_nor_last\n    skip\n    assert_equal [1, 3, 5], [1, 2, 3, 4, 5].discard(&:even?)\n  end\n\n  def test_discard_strings\n    skip\n    words = %w(apple zebra banana zombies cherimoya zelot)\n    result = words.discard { |word| word.start_with?('z') }\n    assert_equal %w(apple banana cherimoya), result\n  end\n\n  def test_discard_arrays # rubocop:disable Metrics/MethodLength\n    skip\n    rows = [\n      [1, 2, 3],\n      [5, 5, 5],\n      [5, 1, 2],\n      [2, 1, 2],\n      [1, 5, 2],\n      [2, 2, 1],\n      [1, 2, 5]\n    ]\n    result = rows.discard { |row| row.include?(5) }\n    assert_equal [[1, 2, 3], [2, 1, 2], [2, 2, 1]], result\n  end\nend\n",
        "README.md": "# Strain\n\nImplement the `keep` and `discard` operation on collections. Given a collection and a predicate on the collection's elements, `keep` returns a new collection containing those elements where the predicate is true, while `discard` returns a new collection containing those elements where the predicate is false.\n\nFor example, given the collection of numbers:\n\n- 1, 2, 3, 4, 5\n\nAnd the predicate:\n\n- is the number even?\n\nThen your `keep` operation should produce:\n\n- 2, 4\n\nWhile your `discard` operation should produce:\n\n- 1, 3, 5\n\nNote that the union of `keep` and `discard` is all the elements.\n\n## Restrictions\n\nKeep your hands off that filter/reject/whatchamacallit functionality\nprovided by your standard library!  Solve this one yourself using other\nbasic tools instead.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nConversation with James Edward Gray II [view source](https://twitter.com/jeg2)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/etl",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "etl",
      "name": "Etl",
      "files": {
        "etl_test.rb": "require 'minitest/autorun'\nrequire_relative 'etl'\n\nclass TransformTest < Minitest::Test\n  def test_transform_one_value\n    old = { 1 => ['A'] }\n    expected = { 'a' => 1 }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_transform_more_values\n    skip\n    old = { 1 => %w(A E I O U) }\n    expected = { 'a' => 1, 'e' => 1, 'i' => 1, 'o' => 1, 'u' => 1 }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_more_keys\n    skip\n    old = { 1 => %w(A E), 2 => %w(D G) }\n    expected = {\n      'a' => 1,\n      'e' => 1,\n      'd' => 2,\n      'g' => 2\n    }\n\n    assert_equal expected, ETL.transform(old)\n  end\n\n  def test_full_dataset # rubocop:disable Metrics/MethodLength\n    skip\n    old = {\n      1 => %w(A E I O U L N R S T),\n      2 => %w(D G),\n      3 => %w(B C M P),\n      4 => %w(F H V W Y),\n      5 => %w(K),\n      8 => %w(J X),\n      10 => %w(Q Z)\n    }\n\n    expected = {\n      'a' => 1, 'b' => 3, 'c' => 3, 'd' => 2, 'e' => 1,\n      'f' => 4, 'g' => 2, 'h' => 4, 'i' => 1, 'j' => 8,\n      'k' => 5, 'l' => 1, 'm' => 3, 'n' => 1, 'o' => 1,\n      'p' => 3, 'q' => 10, 'r' => 1, 's' => 1, 't' => 1,\n      'u' => 1, 'v' => 4, 'w' => 4, 'x' => 8, 'y' => 4,\n      'z' => 10\n    }\n\n    assert_equal expected, ETL.transform(old)\n  end\nend\n",
        "README.md": "# Etl\n\nWe are going to do the `Transform` step of an Extract-Transform-Load.\n\n### ETL\nExtract-Transform-Load (ETL) is a fancy way of saying, \"We have some crufty, legacy data over in this system, and now we need it in this shiny new system over here, so\nwe're going to migrate this.\"\n\n(Typically, this is followed by, \"We're only going to need to run this\nonce.\" That's then typically followed by much forehead slapping and\nmoaning about how stupid we could possibly be.)\n\n### The goal\nWe're going to extract some scrabble scores from a legacy system.\n\nThe old system stored a list of letters per score:\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThe shiny new scrabble system instead stores the score per letter, which\nmakes it much faster and easier to calculate the score for a word. It\nalso stores the letters in lower-case regardless of the case of the\ninput letters:\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- Etc.\n\nYour mission, should you choose to accept it, is to write a program that\ntransforms the legacy data format to the shiny new format.\n\n### Notes\nNote that both the old and the new system use strings to represent\nletters, even in languages that have a separate data type for\ncharacters. \n\nA final note about scoring, Scrabble is played around the world in a\nvariety of languages, each with its own unique scoring table. For\nexample, an \"A\" is scored at 14 in the Basque-language version of the\ngame while being scored at 9 in the Latin-language version.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Jumpstart Lab team [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/trinary",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "trinary",
      "name": "Trinary",
      "files": {
        "trinary_test.rb": "require 'minitest/autorun'\nrequire_relative 'trinary'\n\nclass TrinaryTest < Minitest::Test\n  def test_trinary_1_is_decimal_1\n    assert_equal 1, Trinary.new('1').to_decimal\n  end\n\n  def test_trinary_2_is_decimal_2\n    skip\n    assert_equal 2, Trinary.new('2').to_decimal\n  end\n\n  def test_trinary_10_is_decimal_3\n    skip\n    assert_equal 3, Trinary.new('10').to_decimal\n  end\n\n  def test_trinary_11_is_decimal_4\n    skip\n    assert_equal 4, Trinary.new('11').to_decimal\n  end\n\n  def test_trinary_100_is_decimal_9\n    skip\n    assert_equal 9, Trinary.new('100').to_decimal\n  end\n\n  def test_trinary_112_is_decimal_14\n    skip\n    assert_equal 14, Trinary.new('112').to_decimal\n  end\n\n  def test_trinary_222_is_26\n    skip\n    assert_equal 26, Trinary.new('222').to_decimal\n  end\n\n  def test_trinary_1122000120_is_32091\n    skip\n    assert_equal 32_091, Trinary.new('1122000120').to_decimal\n  end\n\n  def test_invalid_trinary_is_decimal_0\n    skip\n    assert_equal 0, Trinary.new('carrot').to_decimal\n  end\nend\n",
        "README.md": "# Trinary\n\nWrite a program that will convert a trinary number, represented as a string (e.g. '102012'), to its decimal equivalent using first principles.\n\nThe program should consider strings specifying an invalid trinary as the\nvalue 0.\n\nTrinary numbers contain three symbols: 0, 1, and 2.\n\nThe last place in a trinary number is the 1's place. The second to last\nis the 3's place, the third to last is the 9's place, etc.\n\n```bash\n# \"102012\"\n    1       0       2       0       1       2    # the number\n1*3^5 + 0*3^4 + 2*3^3 + 0*3^2 + 1*3^1 + 2*3^0    # the value\n  243 +     0 +    54 +     0 +     3 +     2 =  302\n```\n\nIf your language provides a method in the standard library to perform the\nconversion, pretend it doesn't exist and implement it yourself.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/input/?i=binary&a=*C.binary-_*MathWorld-)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/beer-song",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "beer-song",
      "name": "Beer Song",
      "files": {
        "beer_song_test.rb": "require 'minitest/autorun'\nrequire_relative 'beer_song'\n\nclass BeerSongTest < Minitest::Test\n  def song\n    @song = ::BeerSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  def test_a_typical_verse\n    expected = \"8 bottles of beer on the wall, 8 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 7 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_another_typical_verse\n    skip\n    expected = \"3 bottles of beer on the wall, 3 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 2 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_verse_1\n    skip\n    expected = \"1 bottle of beer on the wall, 1 bottle of beer.\\n\" \\\n      \"Take it down and pass it around, no more bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_verse_2\n    skip\n    expected = \"2 bottles of beer on the wall, 2 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 1 bottle of beer on the wall.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_verse_0\n    skip\n    expected =\n      \"No more bottles of beer on the wall, no more bottles of beer.\\n\" \\\n      \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\"\n    assert_equal expected, song.verse(0)\n  end\n\n  def test_several_verses\n    skip\n    expected = \"8 bottles of beer on the wall, 8 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 7 bottles of beer on the wall.\\n\\n\" \\\n      \"7 bottles of beer on the wall, 7 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 6 bottles of beer on the wall.\\n\\n\" \\\n      \"6 bottles of beer on the wall, 6 bottles of beer.\\n\" \\\n      \"Take one down and pass it around, 5 bottles of beer on the wall.\\n\\n\"\n    assert_equal expected, song.verses(8, 6)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(99, 0), song.sing\n  end\nend\n",
        "README.md": "# Beer Song\n\nWrite a program which produces the lyrics to that beloved classic, that field-trip favorite: 99 Bottles of Beer on the Wall.\n\nNote that not all verses are identical.\n\n```plain\n99 bottles of beer on the wall, 99 bottles of beer.\nTake one down and pass it around, 98 bottles of beer on the wall.\n\n98 bottles of beer on the wall, 98 bottles of beer.\nTake one down and pass it around, 97 bottles of beer on the wall.\n\n97 bottles of beer on the wall, 97 bottles of beer.\nTake one down and pass it around, 96 bottles of beer on the wall.\n\n96 bottles of beer on the wall, 96 bottles of beer.\nTake one down and pass it around, 95 bottles of beer on the wall.\n\n95 bottles of beer on the wall, 95 bottles of beer.\nTake one down and pass it around, 94 bottles of beer on the wall.\n\n94 bottles of beer on the wall, 94 bottles of beer.\nTake one down and pass it around, 93 bottles of beer on the wall.\n\n93 bottles of beer on the wall, 93 bottles of beer.\nTake one down and pass it around, 92 bottles of beer on the wall.\n\n92 bottles of beer on the wall, 92 bottles of beer.\nTake one down and pass it around, 91 bottles of beer on the wall.\n\n91 bottles of beer on the wall, 91 bottles of beer.\nTake one down and pass it around, 90 bottles of beer on the wall.\n\n90 bottles of beer on the wall, 90 bottles of beer.\nTake one down and pass it around, 89 bottles of beer on the wall.\n\n89 bottles of beer on the wall, 89 bottles of beer.\nTake one down and pass it around, 88 bottles of beer on the wall.\n\n88 bottles of beer on the wall, 88 bottles of beer.\nTake one down and pass it around, 87 bottles of beer on the wall.\n\n87 bottles of beer on the wall, 87 bottles of beer.\nTake one down and pass it around, 86 bottles of beer on the wall.\n\n86 bottles of beer on the wall, 86 bottles of beer.\nTake one down and pass it around, 85 bottles of beer on the wall.\n\n85 bottles of beer on the wall, 85 bottles of beer.\nTake one down and pass it around, 84 bottles of beer on the wall.\n\n84 bottles of beer on the wall, 84 bottles of beer.\nTake one down and pass it around, 83 bottles of beer on the wall.\n\n83 bottles of beer on the wall, 83 bottles of beer.\nTake one down and pass it around, 82 bottles of beer on the wall.\n\n82 bottles of beer on the wall, 82 bottles of beer.\nTake one down and pass it around, 81 bottles of beer on the wall.\n\n81 bottles of beer on the wall, 81 bottles of beer.\nTake one down and pass it around, 80 bottles of beer on the wall.\n\n80 bottles of beer on the wall, 80 bottles of beer.\nTake one down and pass it around, 79 bottles of beer on the wall.\n\n79 bottles of beer on the wall, 79 bottles of beer.\nTake one down and pass it around, 78 bottles of beer on the wall.\n\n78 bottles of beer on the wall, 78 bottles of beer.\nTake one down and pass it around, 77 bottles of beer on the wall.\n\n77 bottles of beer on the wall, 77 bottles of beer.\nTake one down and pass it around, 76 bottles of beer on the wall.\n\n76 bottles of beer on the wall, 76 bottles of beer.\nTake one down and pass it around, 75 bottles of beer on the wall.\n\n75 bottles of beer on the wall, 75 bottles of beer.\nTake one down and pass it around, 74 bottles of beer on the wall.\n\n74 bottles of beer on the wall, 74 bottles of beer.\nTake one down and pass it around, 73 bottles of beer on the wall.\n\n73 bottles of beer on the wall, 73 bottles of beer.\nTake one down and pass it around, 72 bottles of beer on the wall.\n\n72 bottles of beer on the wall, 72 bottles of beer.\nTake one down and pass it around, 71 bottles of beer on the wall.\n\n71 bottles of beer on the wall, 71 bottles of beer.\nTake one down and pass it around, 70 bottles of beer on the wall.\n\n70 bottles of beer on the wall, 70 bottles of beer.\nTake one down and pass it around, 69 bottles of beer on the wall.\n\n69 bottles of beer on the wall, 69 bottles of beer.\nTake one down and pass it around, 68 bottles of beer on the wall.\n\n68 bottles of beer on the wall, 68 bottles of beer.\nTake one down and pass it around, 67 bottles of beer on the wall.\n\n67 bottles of beer on the wall, 67 bottles of beer.\nTake one down and pass it around, 66 bottles of beer on the wall.\n\n66 bottles of beer on the wall, 66 bottles of beer.\nTake one down and pass it around, 65 bottles of beer on the wall.\n\n65 bottles of beer on the wall, 65 bottles of beer.\nTake one down and pass it around, 64 bottles of beer on the wall.\n\n64 bottles of beer on the wall, 64 bottles of beer.\nTake one down and pass it around, 63 bottles of beer on the wall.\n\n63 bottles of beer on the wall, 63 bottles of beer.\nTake one down and pass it around, 62 bottles of beer on the wall.\n\n62 bottles of beer on the wall, 62 bottles of beer.\nTake one down and pass it around, 61 bottles of beer on the wall.\n\n61 bottles of beer on the wall, 61 bottles of beer.\nTake one down and pass it around, 60 bottles of beer on the wall.\n\n60 bottles of beer on the wall, 60 bottles of beer.\nTake one down and pass it around, 59 bottles of beer on the wall.\n\n59 bottles of beer on the wall, 59 bottles of beer.\nTake one down and pass it around, 58 bottles of beer on the wall.\n\n58 bottles of beer on the wall, 58 bottles of beer.\nTake one down and pass it around, 57 bottles of beer on the wall.\n\n57 bottles of beer on the wall, 57 bottles of beer.\nTake one down and pass it around, 56 bottles of beer on the wall.\n\n56 bottles of beer on the wall, 56 bottles of beer.\nTake one down and pass it around, 55 bottles of beer on the wall.\n\n55 bottles of beer on the wall, 55 bottles of beer.\nTake one down and pass it around, 54 bottles of beer on the wall.\n\n54 bottles of beer on the wall, 54 bottles of beer.\nTake one down and pass it around, 53 bottles of beer on the wall.\n\n53 bottles of beer on the wall, 53 bottles of beer.\nTake one down and pass it around, 52 bottles of beer on the wall.\n\n52 bottles of beer on the wall, 52 bottles of beer.\nTake one down and pass it around, 51 bottles of beer on the wall.\n\n51 bottles of beer on the wall, 51 bottles of beer.\nTake one down and pass it around, 50 bottles of beer on the wall.\n\n50 bottles of beer on the wall, 50 bottles of beer.\nTake one down and pass it around, 49 bottles of beer on the wall.\n\n49 bottles of beer on the wall, 49 bottles of beer.\nTake one down and pass it around, 48 bottles of beer on the wall.\n\n48 bottles of beer on the wall, 48 bottles of beer.\nTake one down and pass it around, 47 bottles of beer on the wall.\n\n47 bottles of beer on the wall, 47 bottles of beer.\nTake one down and pass it around, 46 bottles of beer on the wall.\n\n46 bottles of beer on the wall, 46 bottles of beer.\nTake one down and pass it around, 45 bottles of beer on the wall.\n\n45 bottles of beer on the wall, 45 bottles of beer.\nTake one down and pass it around, 44 bottles of beer on the wall.\n\n44 bottles of beer on the wall, 44 bottles of beer.\nTake one down and pass it around, 43 bottles of beer on the wall.\n\n43 bottles of beer on the wall, 43 bottles of beer.\nTake one down and pass it around, 42 bottles of beer on the wall.\n\n42 bottles of beer on the wall, 42 bottles of beer.\nTake one down and pass it around, 41 bottles of beer on the wall.\n\n41 bottles of beer on the wall, 41 bottles of beer.\nTake one down and pass it around, 40 bottles of beer on the wall.\n\n40 bottles of beer on the wall, 40 bottles of beer.\nTake one down and pass it around, 39 bottles of beer on the wall.\n\n39 bottles of beer on the wall, 39 bottles of beer.\nTake one down and pass it around, 38 bottles of beer on the wall.\n\n38 bottles of beer on the wall, 38 bottles of beer.\nTake one down and pass it around, 37 bottles of beer on the wall.\n\n37 bottles of beer on the wall, 37 bottles of beer.\nTake one down and pass it around, 36 bottles of beer on the wall.\n\n36 bottles of beer on the wall, 36 bottles of beer.\nTake one down and pass it around, 35 bottles of beer on the wall.\n\n35 bottles of beer on the wall, 35 bottles of beer.\nTake one down and pass it around, 34 bottles of beer on the wall.\n\n34 bottles of beer on the wall, 34 bottles of beer.\nTake one down and pass it around, 33 bottles of beer on the wall.\n\n33 bottles of beer on the wall, 33 bottles of beer.\nTake one down and pass it around, 32 bottles of beer on the wall.\n\n32 bottles of beer on the wall, 32 bottles of beer.\nTake one down and pass it around, 31 bottles of beer on the wall.\n\n31 bottles of beer on the wall, 31 bottles of beer.\nTake one down and pass it around, 30 bottles of beer on the wall.\n\n30 bottles of beer on the wall, 30 bottles of beer.\nTake one down and pass it around, 29 bottles of beer on the wall.\n\n29 bottles of beer on the wall, 29 bottles of beer.\nTake one down and pass it around, 28 bottles of beer on the wall.\n\n28 bottles of beer on the wall, 28 bottles of beer.\nTake one down and pass it around, 27 bottles of beer on the wall.\n\n27 bottles of beer on the wall, 27 bottles of beer.\nTake one down and pass it around, 26 bottles of beer on the wall.\n\n26 bottles of beer on the wall, 26 bottles of beer.\nTake one down and pass it around, 25 bottles of beer on the wall.\n\n25 bottles of beer on the wall, 25 bottles of beer.\nTake one down and pass it around, 24 bottles of beer on the wall.\n\n24 bottles of beer on the wall, 24 bottles of beer.\nTake one down and pass it around, 23 bottles of beer on the wall.\n\n23 bottles of beer on the wall, 23 bottles of beer.\nTake one down and pass it around, 22 bottles of beer on the wall.\n\n22 bottles of beer on the wall, 22 bottles of beer.\nTake one down and pass it around, 21 bottles of beer on the wall.\n\n21 bottles of beer on the wall, 21 bottles of beer.\nTake one down and pass it around, 20 bottles of beer on the wall.\n\n20 bottles of beer on the wall, 20 bottles of beer.\nTake one down and pass it around, 19 bottles of beer on the wall.\n\n19 bottles of beer on the wall, 19 bottles of beer.\nTake one down and pass it around, 18 bottles of beer on the wall.\n\n18 bottles of beer on the wall, 18 bottles of beer.\nTake one down and pass it around, 17 bottles of beer on the wall.\n\n17 bottles of beer on the wall, 17 bottles of beer.\nTake one down and pass it around, 16 bottles of beer on the wall.\n\n16 bottles of beer on the wall, 16 bottles of beer.\nTake one down and pass it around, 15 bottles of beer on the wall.\n\n15 bottles of beer on the wall, 15 bottles of beer.\nTake one down and pass it around, 14 bottles of beer on the wall.\n\n14 bottles of beer on the wall, 14 bottles of beer.\nTake one down and pass it around, 13 bottles of beer on the wall.\n\n13 bottles of beer on the wall, 13 bottles of beer.\nTake one down and pass it around, 12 bottles of beer on the wall.\n\n12 bottles of beer on the wall, 12 bottles of beer.\nTake one down and pass it around, 11 bottles of beer on the wall.\n\n11 bottles of beer on the wall, 11 bottles of beer.\nTake one down and pass it around, 10 bottles of beer on the wall.\n\n10 bottles of beer on the wall, 10 bottles of beer.\nTake one down and pass it around, 9 bottles of beer on the wall.\n\n9 bottles of beer on the wall, 9 bottles of beer.\nTake one down and pass it around, 8 bottles of beer on the wall.\n\n8 bottles of beer on the wall, 8 bottles of beer.\nTake one down and pass it around, 7 bottles of beer on the wall.\n\n7 bottles of beer on the wall, 7 bottles of beer.\nTake one down and pass it around, 6 bottles of beer on the wall.\n\n6 bottles of beer on the wall, 6 bottles of beer.\nTake one down and pass it around, 5 bottles of beer on the wall.\n\n5 bottles of beer on the wall, 5 bottles of beer.\nTake one down and pass it around, 4 bottles of beer on the wall.\n\n4 bottles of beer on the wall, 4 bottles of beer.\nTake one down and pass it around, 3 bottles of beer on the wall.\n\n3 bottles of beer on the wall, 3 bottles of beer.\nTake one down and pass it around, 2 bottles of beer on the wall.\n\n2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n\n1 bottle of beer on the wall, 1 bottle of beer.\nTake it down and pass it around, no more bottles of beer on the wall.\n\nNo more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n```\n\n## For bonus points\n\nDid you get the tests passing and the code clean? If you want to, these\nare some additional things you could try:\n\n* Remove as much duplication as you possibly can.\n* Optimize for readability, even if it means introducing duplication.\n* If you've removed all the duplication, do you have a lot of\n  conditionals? Try replacing the conditionals with polymorphism, if it\n  applies in this language. How readable is it?\n\nThen please share your thoughts in a comment on the submission. Did this\nexperiment make the code better? Worse? Did you learn anything from it?\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nLearn to Program by Chris Pine [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/space-age",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "space-age",
      "name": "Space Age",
      "files": {
        "space_age_test.rb": "require 'minitest/autorun'\nrequire_relative 'space_age'\n\nclass SpaceAgeTest < Minitest::Test\n  def test_age_in_seconds\n    age = SpaceAge.new(1_000_000)\n    assert_equal 1_000_000, age.seconds\n  end\n\n  def test_age_in_earth_years\n    skip\n    age = SpaceAge.new(1_000_000_000)\n    assert_equal 31.69, age.on_earth\n  end\n\n  def test_age_in_mercury_years\n    skip\n    age = SpaceAge.new(2_134_835_688)\n    assert_equal 67.65, age.on_earth\n    assert_equal 280.88, age.on_mercury\n  end\n\n  def test_age_in_venus_years\n    skip\n    age = SpaceAge.new(189_839_836)\n    assert_equal 6.02, age.on_earth\n    assert_equal 9.78, age.on_venus\n  end\n\n  def test_age_on_mars\n    skip\n    age = SpaceAge.new(2_329_871_239)\n    assert_equal 73.83, age.on_earth\n    assert_equal 39.25, age.on_mars\n  end\n\n  def test_age_on_jupiter\n    skip\n    age = SpaceAge.new(901_876_382)\n    assert_equal 28.58, age.on_earth\n    assert_equal 2.41, age.on_jupiter\n  end\n\n  def test_age_on_saturn\n    skip\n    age = SpaceAge.new(3_000_000_000)\n    assert_equal 95.06, age.on_earth\n    assert_equal 3.23, age.on_saturn\n  end\n\n  def test_age_on_uranus\n    skip\n    age = SpaceAge.new(3_210_123_456)\n    assert_equal 101.72, age.on_earth\n    assert_equal 1.21, age.on_uranus\n  end\n\n  def test_age_on_neptune\n    skip\n    age = SpaceAge.new(8_210_123_456)\n    assert_equal 260.16, age.on_earth\n    assert_equal 1.58, age.on_neptune\n  end\nend\n",
        "README.md": "# Space Age\n\nWrite a program that, given an age in seconds, calculates how old someone is in terms of a given planet's solar years.\n\nGiven an age in seconds, calculate how old someone would be on:\n\n   - Earth: orbital period 365.25 Earth days, or 31557600 seconds\n   - Mercury: orbital period 0.2408467 Earth years\n   - Venus: orbital period 0.61519726 Earth years\n   - Mars: orbital period 1.8808158 Earth years\n   - Jupiter: orbital period 11.862615 Earth years\n   - Saturn: orbital period 29.447498 Earth years\n   - Uranus: orbital period 84.016846 Earth years\n   - Neptune: orbital period 164.79132 Earth years\n\nSo if you were told someone were 1,000,000,000 seconds old, you should\nbe able to say that they're 31 Earth-years old.\n\nIf you're wondering why Pluto didn't make the cut, go watch [this\nyoutube video](http://www.youtube.com/watch?v=Z_2gbGXzFbs).\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nPartially inspired by Chapter 1 in Chris Pine's online Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=01)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/anagram",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "anagram",
      "name": "Anagram",
      "files": {
        "anagram_test.rb": "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < Minitest::Test\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(%w(tan stand at))\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(%w(stream pigeon maters))\n    assert_equal %w(maters stream), anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(%w(dog goody))\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams =\n      detector.match %w( gallery ballerina regally clergy largely leading)\n    assert_equal %w(gallery largely regally), anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend\n",
        "README.md": "# Anagram\n\nWrite a program that, given a word and a list of possible anagrams, selects the correct sublist.\n\nGiven `\"listen\"` and a list of candidates like `\"enlists\" \"google\"\n\"inlets\" \"banana\"` the program should return a list containing\n`\"inlets\"`.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/binary-search-tree",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "binary-search-tree",
      "name": "Binary Search Tree",
      "files": {
        "binary_search_tree_test.rb": "require 'minitest/autorun'\nrequire_relative 'bst'\n\nclass BstTest < Minitest::Test\n  def test_data_is_retained\n    assert_equal 4, Bst.new(4).data\n  end\n\n  def test_inserting_less\n    skip\n    four = Bst.new 4\n    four.insert 2\n    assert_equal 4, four.data\n    assert_equal 2, four.left.data\n  end\n\n  def test_inserting_same\n    skip\n    four = Bst.new 4\n    four.insert 4\n    assert_equal 4, four.data\n    assert_equal 4, four.left.data\n  end\n\n  def test_inserting_right\n    skip\n    four = Bst.new 4\n    four.insert 5\n    assert_equal 4, four.data\n    assert_equal 5, four.right.data\n  end\n\n  # rubocop:disable Metrics/AbcSize\n  def test_complex_tree # rubocop:disable Metrics/MethodLength\n    skip\n    four = Bst.new 4\n    four.insert 2\n    four.insert 6\n    four.insert 1\n    four.insert 3\n    four.insert 7\n    four.insert 5\n    assert_equal 4, four.data\n    assert_equal 2, four.left.data\n    assert_equal 1, four.left.left.data\n    assert_equal 3, four.left.right.data\n    assert_equal 6, four.right.data\n    assert_equal 5, four.right.left.data\n    assert_equal 7, four.right.right.data\n  end\n\n  def record_all_data(bst)\n    all_data = []\n    bst.each { |data| all_data << data }\n    all_data\n  end\n\n  def test_iterating_one_element\n    skip\n    assert_equal [4], record_all_data(Bst.new 4)\n  end\n\n  def test_iterating_over_smaller_element\n    skip\n    four = Bst.new 4\n    four.insert 2\n    assert_equal [2, 4], record_all_data(four)\n  end\n\n  def test_iterating_over_larger_element\n    skip\n    four = Bst.new 4\n    four.insert 5\n    assert_equal [4, 5], record_all_data(four)\n  end\n\n  def test_iterating_over_complex_tree\n    skip\n    four = Bst.new 4\n    four.insert 2\n    four.insert 1\n    four.insert 3\n    four.insert 6\n    four.insert 7\n    four.insert 5\n    assert_equal [1, 2, 3, 4, 5, 6, 7], record_all_data(four)\n  end\nend\n",
        "README.md": "# Binary Search Tree\n\nWrite a program that inserts numbers and searches in a binary tree.\n\nWhen we need to represent sorted data, an array does not make a good\ndata structure.\n\nSay we have the array `[1, 3, 4, 5]`, and we add 2 to it so it becomes\n`[1, 3, 4, 5, 2]` now we must sort the entire array again! We can\nimprove on this by realizing that we only need to make space for the new\nitem `[1, nil, 3, 4, 5]`, and then adding the item in the space we\nadded. But this still requires us to shift many elements down by one.\n\nBinary Search Trees, however, can operate on sorted data much more\nefficiently.\n\nA binary search tree consists of a series of connected nodes. Each node\ncontains a piece of data (e.g. the number 3), a variable named `left`,\nand a variable named `right`. The `left` and `right` variables point at\n`nil`, or other nodes. Since these other nodes in turn have other nodes\nbeneath them, we say that the left and right variables are pointing at\nsubtrees. All data in the left subtree is less than or equal to the\ncurrent node's data, and all data in the right subtree is greater than\nthe current node's data.\n\nFor example, if we had a node containing the data 4, and we added the\ndata 2, our tree would look like this:\n\n      4\n     /\n    2\n\nIf we then added 6, it would look like this:\n\n      4\n     / \\\n    2   6\n\nIf we then added 3, it would look like this\n\n       4\n     /   \\\n    2     6\n     \\\n      3\n\nAnd if we then added 1, 5, and 7, it would look like this\n\n          4\n        /   \\\n       /     \\\n      2       6\n     / \\     / \\\n    1   3   5   7\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJosh Cheek [view source](https://twitter.com/josh_cheek)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/crypto-square",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "crypto-square",
      "name": "Crypto Square",
      "files": {
        "crypto_square_test.rb": "require 'minitest/autorun'\nrequire_relative 'crypto'\n\nclass CryptoTest < Minitest::Test\n  def test_normalize_strange_characters\n    crypto = Crypto.new('s#$%^&plunk')\n    assert_equal 'splunk', crypto.normalize_plaintext\n  end\n\n  def test_normalize_uppercase_characters\n    skip\n    crypto = Crypto.new('WHOA HEY!')\n    assert_equal 'whoahey', crypto.normalize_plaintext\n  end\n\n  def test_normalize_with_numbers\n    skip\n    crypto = Crypto.new('1, 2, 3 GO!')\n    assert_equal '123go', crypto.normalize_plaintext\n  end\n\n  def test_size_of_small_square\n    skip\n    crypto = Crypto.new('1234')\n    assert_equal 2, crypto.size\n  end\n\n  def test_size_of_slightly_larger_square\n    skip\n    crypto = Crypto.new('123456789')\n    assert_equal 3, crypto.size\n  end\n\n  def test_size_of_non_perfect_square\n    skip\n    crypto = Crypto.new('123456789abc')\n    assert_equal 4, crypto.size\n  end\n\n  def test_size_is_determined_by_normalized_plaintext\n    skip\n    crypto = Crypto.new('Oh hey, this is nuts!')\n    assert_equal 4, crypto.size\n  end\n\n  def test_plaintext_segments\n    skip\n    crypto = Crypto.new('Never vex thine heart with idle woes')\n    expected = %w(neverv exthin eheart withid lewoes)\n    assert_equal expected, crypto.plaintext_segments\n  end\n\n  def test_other_plaintext_segments\n    skip\n    crypto = Crypto.new('ZOMG! ZOMBIES!!!')\n    assert_equal %w(zomg zomb ies), crypto.plaintext_segments\n  end\n\n  def test_ciphertext\n    skip\n    crypto = Crypto.new('Time is an illusion. Lunchtime doubly so.')\n    assert_equal 'tasneyinicdsmiohooelntuillibsuuml', crypto.ciphertext\n  end\n\n  def test_another_ciphertext\n    skip\n    crypto = Crypto.new('We all know interspecies romance is weird.')\n    assert_equal 'wneiaweoreneawssciliprerlneoidktcms', crypto.ciphertext\n  end\n\n  def test_normalized_ciphertext\n    skip\n    crypto = Crypto.new('Vampires are people too!')\n    assert_equal 'vrel aepe mset paoo irpo', crypto.normalize_ciphertext\n  end\n\n  def test_normalized_ciphertext_spills_into_short_segment\n    skip\n    crypto = Crypto.new('Madness, and then illumination.')\n    assert_equal 'msemo aanin dninn dlaet ltshu i', crypto.normalize_ciphertext\n  end\n\n  def test_another_normalized_ciphertext\n    skip\n    crypto = Crypto.new(\n      'If man was meant to stay on the ground god would have given us roots'\n    )\n    expected = 'imtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghns seoau'\n    assert_equal expected, crypto.normalize_ciphertext\n  end\n\n  def test_normalized_ciphertext_with_punctuation\n    skip\n    crypto = Crypto.new('Have a nice day. Feed the dog & chill out!')\n    expected = 'hifei acedl veeol eddgo aatcu nyhht'\n    assert_equal expected, crypto.normalize_ciphertext\n  end\n\n  def test_normalized_ciphertext_when_just_less_then_a_full_square\n    skip\n    crypto = Crypto.new('I am')\n    assert_equal 'im a', crypto.normalize_ciphertext\n  end\nend\n",
        "README.md": "# Crypto Square\n\nImplement the classic method for composing secret messages called a square code.\n\nThe input is first normalized: The spaces and punctuation are removed\nfrom the English text and the message is downcased.\n\nThen, the normalized characters are broken into rows.  These rows can be\nregarded as forming a rectangle when printed with intervening newlines.\n\nFor example, the sentence\n\n> If man was meant to stay on the ground god would have given us roots\n\nis 54 characters long.\n\nBroken into 8-character columns, it yields 7 rows.\n\nThose 7 rows produce this rectangle when printed one per line:\n\n```plain\nifmanwas\nmeanttos\ntayonthe\ngroundgo\ndwouldha\nvegivenu\nsroots\n```\n\nThe coded message is obtained by reading down the columns going left to\nright.\n\nFor example, the message above is coded as:\n\n```plain\nimtgdvs fearwer mayoogo anouuio ntnnlvt wttddes aohghn sseoau\n```\n\nWrite a program that, given an English text, outputs the encoded version\nof that text.\n\nThe size of the square (number of columns) should be decided by the\nlength of the message.\n\nIf the message is a length that creates a perfect square (e.g. 4, 9, 16,\n25, 36, etc), use that number of columns.\n\nIf the message doesn't fit neatly into a square, choose the number of\ncolumns that corresponds to the smallest square that is larger than the\nnumber of characters in the message.\n\nFor example, a message 4 characters long should use a 2 x 2 square. A\nmessage that is 81 characters long would use a square that is 9 colums\nwide.\n\nA message between 5 and 8 characters long should use a rectangle 3\ncharacters wide.\n\nOutput the encoded text grouped by column.\n\nFor example:\n\n- \"Have a nice day. Feed the dog & chill out!\"\n  - Normalizes to: \"haveanicedayfeedthedogchillout\"\n  - Which has length: 30\n  - And splits into 5 6-character rows:\n    - \"havean\"\n    - \"iceday\"\n    - \"feedth\"\n    - \"edogch\"\n    - \"illout\"\n  - Which yields a ciphertext beginning: \"hifei acedl vâ€¦\"\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/clock",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "clock",
      "name": "Clock",
      "files": {
        "clock_test.rb": "require 'minitest/autorun'\nrequire_relative 'clock'\n\nclass ClockTest < Minitest::Test\n  def test_on_the_hour\n    assert_equal '08:00', Clock.at(8).to_s\n    assert_equal '09:00', Clock.at(9).to_s\n  end\n\n  def test_past_the_hour\n    skip\n    assert_equal '11:09', Clock.at(11, 9).to_s\n  end\n\n  def test_add_a_few_minutes\n    skip\n    clock = Clock.at(10) + 3\n    assert_equal '10:03', clock.to_s\n  end\n\n  def test_add_over_an_hour\n    skip\n    clock = Clock.at(10) + 61\n    assert_equal '11:01', clock.to_s\n  end\n\n  def test_wrap_around_at_midnight\n    skip\n    clock = Clock.at(23, 30) + 60\n    assert_equal '00:30', clock.to_s\n  end\n\n  def test_subtract_minutes\n    skip\n    clock = Clock.at(10) - 90\n    assert_equal '08:30', clock.to_s\n  end\n\n  def test_equivalent_clocks\n    skip\n    clock1 = Clock.at(15, 37)\n    clock2 = Clock.at(15, 37)\n    assert_equal clock1, clock2\n  end\n\n  def test_inequivalent_clocks\n    skip\n    clock1 = Clock.at(15, 37)\n    clock2 = Clock.at(15, 36)\n    clock3 = Clock.at(14, 37)\n    refute_equal clock1, clock2\n    refute_equal clock1, clock3\n  end\n\n  def test_wrap_around_backwards\n    skip\n    clock = Clock.at(0, 30) - 60\n    assert_equal '23:30', clock.to_s\n  end\nend\n",
        "README.md": "# Clock\n\nImplement a clock that handles times without dates.\n\nCreate a clock that is independent of date.\n\nYou should be able to add and subtract minutes to it.\n\nTwo clocks that represent the same time should be equal to each other.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nPairing session with Erin Drummond [view source](https://twitter.com/ebdrummond)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/scrabble-score",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "scrabble-score",
      "name": "Scrabble Score",
      "files": {
        "scrabble_score_test.rb": "require 'minitest/autorun'\nrequire_relative 'scrabble'\n\nclass ScrabbleTest < Minitest::Test\n  def test_empty_word_scores_zero\n    assert_equal 0, Scrabble.new('').score\n  end\n\n  def test_whitespace_scores_zero\n    skip\n    assert_equal 0, Scrabble.new(\" \\t\\n\").score\n  end\n\n  def test_nil_scores_zero\n    skip\n    assert_equal 0, Scrabble.new(nil).score\n  end\n\n  def test_scores_very_short_word\n    skip\n    assert_equal 1, Scrabble.new('a').score\n  end\n\n  def test_scores_other_very_short_word\n    skip\n    assert_equal 4, Scrabble.new('f').score\n  end\n\n  def test_simple_word_scores_the_number_of_letters\n    skip\n    assert_equal 6, Scrabble.new('street').score\n  end\n\n  def test_complicated_word_scores_more\n    skip\n    assert_equal 22, Scrabble.new('quirky').score\n  end\n\n  def test_scores_are_case_insensitive\n    skip\n    assert_equal 20, Scrabble.new('MULTIBILLIONAIRE').score\n  end\n\n  def test_convenient_scoring\n    skip\n    assert_equal 13, Scrabble.score('alacrity')\n  end\nend\n",
        "README.md": "# Scrabble Score\n\nWrite a program that, given a word, computes the scrabble score for that word.\n\n## Letter Values\n\nYou'll need these:\n\n```plain\nLetter                           Value\nA, E, I, O, U, L, N, R, S, T       1\nD, G                               2\nB, C, M, P                         3\nF, H, V, W, Y                      4\nK                                  5\nJ, X                               8\nQ, Z                               10\n```\n\n## Examples\n\"cabbage\" should be scored as worth 14 points:\n\n- 3 points for C\n- 1 point for A, twice\n- 3 points for B, twice\n- 2 points for G\n- 1 point for E\n\nAnd to total:\n\n- `3 + 2*1 + 2*3 + 2 + 1`\n- = `3 + 2 + 6 + 3`\n- = `5 + 9`\n- = 14\n\n## Extensions\n- You can play a `:double` or a `:triple` letter.\n- You can play a `:double` or a `:triple` word.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by the Extreme Startup game [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/nucleotide-count",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "nucleotide-count",
      "name": "Nucleotide Count",
      "files": {
        "nucleotide_test.rb": "require 'minitest/autorun'\nrequire_relative 'nucleotide'\n\nclass NucleotideTest < Minitest::Test\n  def test_empty_dna_strand_has_no_adenosine\n    assert_equal 0, Nucleotide.from_dna('').count('A')\n  end\n\n  def test_repetitive_cytidine_gets_counted\n    skip\n    assert_equal 5, Nucleotide.from_dna('CCCCC').count('C')\n  end\n\n  def test_counts_only_thymidine\n    skip\n    assert_equal 1, Nucleotide.from_dna('GGGGGTAACCCGG').count('T')\n  end\n\n  def test_counts_a_nucleotide_only_once\n    skip\n    dna = Nucleotide.from_dna('CGATTGGG')\n    dna.count('T')\n    dna.count('T')\n    assert_equal 2, dna.count('T')\n  end\n\n  def test_empty_dna_strand_has_no_nucleotides\n    skip\n    expected = { 'A' => 0, 'T' => 0, 'C' => 0, 'G' => 0 }\n    assert_equal expected, Nucleotide.from_dna('').histogram\n  end\n\n  def test_repetitive_sequence_has_only_guanosine\n    skip\n    expected = { 'A' => 0, 'T' => 0, 'C' => 0, 'G' => 8 }\n    assert_equal expected, Nucleotide.from_dna('GGGGGGGG').histogram\n  end\n\n  def test_counts_all_nucleotides\n    skip\n    s = 'AGCTTTTCATTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATTAAAAAAAGAGTGTCTGATAGCAGC'\n    dna = Nucleotide.from_dna(s)\n    expected = { 'A' => 20, 'T' => 21, 'G' => 17, 'C' => 12 }\n    assert_equal expected, dna.histogram\n  end\n\n  def test_validates_dna\n    skip\n    assert_raises ArgumentError do\n      Nucleotide.from_dna('JOHNNYAPPLESEED')\n    end\n  end\nend\n",
        "README.md": "# Nucleotide Count\n\nGiven a DNA string, compute how many times each nucleotide occurs in the string.\n\nDNA is represented by an alphabet of the following symbols: 'A', 'C',\n'G', and 'T'.\n\nEach symbol represents a nucleotide, which is a fancy name for the\nparticular molecules that happen to make up a large part of DNA.\n\nShortest intro to biochemistry EVAR:\n\n- twigs are to birds nests as\n- nucleotides are to DNA and RNA as\n- amino acids are to proteins as\n- sugar is to starch as\n- oh crap lipids\n\nI'm not going to talk about lipids because they're crazy complex.\n\nSo back to nucleotides.\n\nDNA contains four types of them: adenine (`A`), cytosine (`C`), guanine\n(`G`), and thymine (`T`).\n\nRNA contains a slightly different set of nucleotides, but we don't care\nabout that for now.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Calculating DNA Nucleotides_problem at Rosalind [view source](http://rosalind.info/problems/dna/)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/hexadecimal",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "hexadecimal",
      "name": "Hexadecimal",
      "files": {
        "hexadecimal_test.rb": "require 'minitest/autorun'\nrequire_relative 'hexadecimal'\n\nclass HexadecimalTest < Minitest::Test\n  def test_hex_1_is_decimal_1\n    assert_equal 1, Hexadecimal.new('1').to_decimal\n  end\n\n  def test_hex_c_is_decimal_12\n    skip\n    assert_equal 12, Hexadecimal.new('c').to_decimal\n  end\n\n  def test_hex_10_is_decimal_16\n    skip\n    assert_equal 16, Hexadecimal.new('10').to_decimal\n  end\n\n  def test_hex_af_is_decimal_175\n    skip\n    assert_equal 175, Hexadecimal.new('af').to_decimal\n  end\n\n  def test_hex_100_is_decimal_256\n    skip\n    assert_equal 256, Hexadecimal.new('100').to_decimal\n  end\n\n  def test_hex_19ace_is_decimal_105166\n    skip\n    assert_equal 105_166, Hexadecimal.new('19ace').to_decimal\n  end\n\n  def test_invalid_hex_is_decimal_0\n    skip\n    assert_equal 0, Hexadecimal.new('carrot').to_decimal\n  end\n\n  def test_black\n    skip\n    assert_equal 0, Hexadecimal.new('000000').to_decimal\n  end\n\n  def test_white\n    skip\n    assert_equal 16_777_215, Hexadecimal.new('ffffff').to_decimal\n  end\n\n  def test_yellow\n    skip\n    assert_equal 16_776_960, Hexadecimal.new('ffff00').to_decimal\n  end\nend\n",
        "README.md": "# Hexadecimal\n\nWrite a program that will convert a hexadecimal number, represented as a string (e.g. \"10af8c\"), to its decimal equivalent using first principles (i.e. no, you may not use built-in ruby libraries or gems to accomplish the conversion).\n\nOn the web we use hexadecimal to represent colors, e.g. green: 008000,\nteal: 008080, navy: 000080).\n\nThe program should handle invalid hexadecimal strings.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nAll of Computer Science [view source](http://www.wolframalpha.com/examples/NumberBases.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/say",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "say",
      "name": "Say",
      "files": {
        "say_test.rb": "require 'minitest/autorun'\nrequire_relative 'say'\n\nclass SayTest < Minitest::Test\n  def test_0\n    assert_equal 'zero', Say.new(0).in_english\n  end\n\n  def test_one\n    skip\n    assert_equal 'one', Say.new(1).in_english\n  end\n\n  def test_14\n    skip\n    assert_equal 'fourteen', Say.new(14).in_english\n  end\n\n  def test_twenty\n    skip\n    # This really shouldn't be twenty-zero\n    assert_equal 'twenty', Say.new(20).in_english\n  end\n\n  def test_twenty_two\n    skip\n    assert_equal 'twenty-two', Say.new(22).in_english\n  end\n\n  def test_100\n    skip\n    assert_equal 'one hundred', Say.new(100).in_english\n  end\n\n  def test_120\n    skip\n    assert_equal 'one hundred twenty', Say.new(120).in_english\n  end\n\n  def test_123\n    skip\n    assert_equal 'one hundred twenty-three', Say.new(123).in_english\n  end\n\n  def test_1_thousand\n    skip\n    assert_equal 'one thousand', Say.new(1000).in_english\n  end\n\n  def test_1_thousand_234\n    skip\n    expected = 'one thousand two hundred thirty-four'\n    assert_equal expected, Say.new(1234).in_english\n  end\n\n  def test_1_million\n    skip\n    assert_equal 'one million', Say.new(10**6).in_english\n  end\n\n  def test_1_million_and_some_crumbs\n    skip\n    assert_equal 'one million two', Say.new(1_000_002).in_english\n  end\n\n  def test_1_million_2_thousand_345\n    skip\n    expected = 'one million two thousand three hundred forty-five'\n    assert_equal expected, Say.new(1_002_345).in_english\n  end\n\n  def test_1_billion\n    skip\n    assert_equal 'one billion', Say.new(10**9).in_english\n  end\n\n  def test_really_big_number\n    skip\n    expected = 'nine hundred eighty-seven billion '\n    expected << 'six hundred fifty-four million '\n    expected << 'three hundred twenty-one thousand '\n    expected << 'one hundred twenty-three'\n    assert_equal expected, Say.new(987_654_321_123).in_english\n  end\n\n  def test_lower_bound\n    skip\n    assert_raises ArgumentError do\n      Say.new(-1).in_english\n    end\n  end\n\n  def test_upper_bound\n    skip\n    assert_raises ArgumentError do\n      Say.new(1_000_000_000_000).in_english\n    end\n  end\nend\n",
        "README.md": "# Say\n\nWrite a program that will take a number from 0 to 999,999,999,999 and spell out that number in English.\n\n## Step 1\n\nHandle the basic case of 0 through 99.\n\nIf the input to the program is `22`, then the output should be\n`'twenty-two'`.\n\nYour program should complain loudly if given a number outside the\nblessed range.\n\nSome good test cases for this program are:\n\n- 0\n- 14\n- 50\n- 98\n- -1\n- 100\n\n### Extension\n\nIf you're on a Mac, shell out to Mac OS X's `say` program to talk out\nloud.\n\n## Step 2\n\nImplement breaking a number up into chunks of thousands.\n\nSo `1234567890` should yield a list like 1, 234, 567, and 890, while the\nfar simpler `1000` should yield just 1 and 0.\n\nThe program must also report any values that are out of range.\n\n## Step 3\n\nNow handle inserting the appropriate scale word between those chunks.\n\nSo `1234567890` should yield `'1 billion 234 million 567 thousand 890'`\n\nThe program must also report any values that are out of range.  It's\nfine to stop at \"trillion\".\n\n## Step 4\n\nPut it all together to get nothing but plain English.\n\n`12345` should give `twelve thousand three hundred forty-five`.\n\nThe program must also report any values that are out of range.\n\n### Extensions\n\nUse _and_ (correctly) when spelling out the number in English:\n\n- 14 becomes \"fourteen\".\n- 100 becomes \"one hundred\".\n- 120 becomes \"one hundred and twenty\".\n- 1002 becomes \"one thousand and two\".\n- 1323 becomes \"one thousand three hundred and twenty-three\".\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA variation on JavaRanch CattleDrive, exercise 4a [view source](http://www.javaranch.com/say.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/meetup",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "meetup",
      "name": "Meetup",
      "files": {
        "meetup_test.rb": "require 'minitest/autorun'\nrequire 'date'\nrequire_relative 'meetup'\n\n# Define a class Meetup with a constructor taking a montth and a year\n# and a method day(weekday, schedule)\n# where weekday is one of :monday, :tuesday, etc\n# and schedule is :first, :second, :third, :fourth, :last or :teenth.\n# rubocop:disable Style/AlignParameters\nclass MeetupTest < Minitest::Test\n  def test_monteenth_of_may_2013\n    assert_equal Date.new(2013, 5, 13),\n      Meetup.new(5, 2013).day(:monday, :teenth)\n  end\n\n  def test_monteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 19),\n      Meetup.new(8, 2013).day(:monday, :teenth)\n  end\n\n  def test_monteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 16),\n      Meetup.new(9, 2013).day(:monday, :teenth)\n  end\n\n  def test_tuesteenth_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 19),\n      Meetup.new(3, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_tuesteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 16),\n      Meetup.new(4, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_tuesteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 13),\n      Meetup.new(8, 2013).day(:tuesday, :teenth)\n  end\n\n  def test_wednesteenth_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 16),\n      Meetup.new(1, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_wednesteenth_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 13),\n      Meetup.new(2, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_wednesteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 19),\n      Meetup.new(6, 2013).day(:wednesday, :teenth)\n  end\n\n  def test_thursteenth_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 16),\n      Meetup.new(5, 2013).day(:thursday, :teenth)\n  end\n\n  def test_thursteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 13),\n      Meetup.new(6, 2013).day(:thursday, :teenth)\n  end\n\n  def test_thursteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 19),\n      Meetup.new(9, 2013).day(:thursday, :teenth)\n  end\n\n  def test_friteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 19),\n      Meetup.new(4, 2013).day(:friday, :teenth)\n  end\n\n  def test_friteenth_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 16),\n      Meetup.new(8, 2013).day(:friday, :teenth)\n  end\n\n  def test_friteenth_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 13),\n      Meetup.new(9, 2013).day(:friday, :teenth)\n  end\n\n  def test_saturteenth_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 16),\n      Meetup.new(2, 2013).day(:saturday, :teenth)\n  end\n\n  def test_saturteenth_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 13),\n      Meetup.new(4, 2013).day(:saturday, :teenth)\n  end\n\n  def test_saturteenth_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 19),\n      Meetup.new(10, 2013).day(:saturday, :teenth)\n  end\n\n  def test_sunteenth_of_map_2013\n    skip\n    assert_equal Date.new(2013, 5, 19),\n      Meetup.new(5, 2013).day(:sunday, :teenth)\n  end\n\n  def test_sunteenth_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 16),\n      Meetup.new(6, 2013).day(:sunday, :teenth)\n  end\n\n  def test_sunteenth_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 13),\n      Meetup.new(10, 2013).day(:sunday, :teenth)\n  end\n\n  def test_first_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 4),\n      Meetup.new(3, 2013).day(:monday, :first)\n  end\n\n  def test_first_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 1),\n      Meetup.new(4, 2013).day(:monday, :first)\n  end\n\n  def test_first_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 7),\n      Meetup.new(5, 2013).day(:tuesday, :first)\n  end\n\n  def test_first_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 4),\n      Meetup.new(6, 2013).day(:tuesday, :first)\n  end\n\n  def test_first_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 3),\n      Meetup.new(7, 2013).day(:wednesday, :first)\n  end\n\n  def test_first_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 7),\n      Meetup.new(8, 2013).day(:wednesday, :first)\n  end\n\n  def test_first_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 5),\n      Meetup.new(9, 2013).day(:thursday, :first)\n  end\n\n  def test_first_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 3),\n      Meetup.new(10, 2013).day(:thursday, :first)\n  end\n\n  def test_first_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 1),\n      Meetup.new(11, 2013).day(:friday, :first)\n  end\n\n  def test_first_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 6),\n      Meetup.new(12, 2013).day(:friday, :first)\n  end\n\n  def test_first_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 5),\n      Meetup.new(1, 2013).day(:saturday, :first)\n  end\n\n  def test_first_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 2),\n      Meetup.new(2, 2013).day(:saturday, :first)\n  end\n\n  def test_first_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 3),\n      Meetup.new(3, 2013).day(:sunday, :first)\n  end\n\n  def test_first_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 7),\n      Meetup.new(4, 2013).day(:sunday, :first)\n  end\n\n  def test_second_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 11),\n      Meetup.new(3, 2013).day(:monday, :second)\n  end\n\n  def test_second_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 8),\n      Meetup.new(4, 2013).day(:monday, :second)\n  end\n\n  def test_second_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 14),\n      Meetup.new(5, 2013).day(:tuesday, :second)\n  end\n\n  def test_second_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 11),\n      Meetup.new(6, 2013).day(:tuesday, :second)\n  end\n\n  def test_second_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 10),\n      Meetup.new(7, 2013).day(:wednesday, :second)\n  end\n\n  def test_second_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 14),\n      Meetup.new(8, 2013).day(:wednesday, :second)\n  end\n\n  def test_second_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 12),\n      Meetup.new(9, 2013).day(:thursday, :second)\n  end\n\n  def test_second_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 10),\n      Meetup.new(10, 2013).day(:thursday, :second)\n  end\n\n  def test_second_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 8),\n      Meetup.new(11, 2013).day(:friday, :second)\n  end\n\n  def test_second_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 13),\n      Meetup.new(12, 2013).day(:friday, :second)\n  end\n\n  def test_second_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 12),\n      Meetup.new(1, 2013).day(:saturday, :second)\n  end\n\n  def test_second_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 9),\n      Meetup.new(2, 2013).day(:saturday, :second)\n  end\n\n  def test_second_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 10),\n      Meetup.new(3, 2013).day(:sunday, :second)\n  end\n\n  def test_second_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 14),\n      Meetup.new(4, 2013).day(:sunday, :second)\n  end\n\n  def test_third_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 18),\n      Meetup.new(3, 2013).day(:monday, :third)\n  end\n\n  def test_third_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 15),\n      Meetup.new(4, 2013).day(:monday, :third)\n  end\n\n  def test_third_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 21),\n      Meetup.new(5, 2013).day(:tuesday, :third)\n  end\n\n  def test_third_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 18),\n      Meetup.new(6, 2013).day(:tuesday, :third)\n  end\n\n  def test_third_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 17),\n      Meetup.new(7, 2013).day(:wednesday, :third)\n  end\n\n  def test_third_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 21),\n      Meetup.new(8, 2013).day(:wednesday, :third)\n  end\n\n  def test_third_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 19),\n      Meetup.new(9, 2013).day(:thursday, :third)\n  end\n\n  def test_third_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 17),\n      Meetup.new(10, 2013).day(:thursday, :third)\n  end\n\n  def test_third_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 15),\n      Meetup.new(11, 2013).day(:friday, :third)\n  end\n\n  def test_third_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 20),\n      Meetup.new(12, 2013).day(:friday, :third)\n  end\n\n  def test_third_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 19),\n      Meetup.new(1, 2013).day(:saturday, :third)\n  end\n\n  def test_third_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 16),\n      Meetup.new(2, 2013).day(:saturday, :third)\n  end\n\n  def test_third_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 17),\n      Meetup.new(3, 2013).day(:sunday, :third)\n  end\n\n  def test_third_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 21),\n      Meetup.new(4, 2013).day(:sunday, :third)\n  end\n\n  def test_fourth_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 25),\n      Meetup.new(3, 2013).day(:monday, :fourth)\n  end\n\n  def test_fourth_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 22),\n      Meetup.new(4, 2013).day(:monday, :fourth)\n  end\n\n  def test_fourth_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 28),\n      Meetup.new(5, 2013).day(:tuesday, :fourth)\n  end\n\n  def test_fourth_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 25),\n      Meetup.new(6, 2013).day(:tuesday, :fourth)\n  end\n\n  def test_fourth_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 24),\n      Meetup.new(7, 2013).day(:wednesday, :fourth)\n  end\n\n  def test_fourth_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 28),\n      Meetup.new(8, 2013).day(:wednesday, :fourth)\n  end\n\n  def test_fourth_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 26),\n      Meetup.new(9, 2013).day(:thursday, :fourth)\n  end\n\n  def test_fourth_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 24),\n      Meetup.new(10, 2013).day(:thursday, :fourth)\n  end\n\n  def test_fourth_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 22),\n      Meetup.new(11, 2013).day(:friday, :fourth)\n  end\n\n  def test_fourth_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 27),\n      Meetup.new(12, 2013).day(:friday, :fourth)\n  end\n\n  def test_fourth_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 26),\n      Meetup.new(1, 2013).day(:saturday, :fourth)\n  end\n\n  def test_fourth_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 23),\n      Meetup.new(2, 2013).day(:saturday, :fourth)\n  end\n\n  def test_fourth_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 24),\n      Meetup.new(3, 2013).day(:sunday, :fourth)\n  end\n\n  def test_fourth_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 28),\n      Meetup.new(4, 2013).day(:sunday, :fourth)\n  end\n\n  def test_last_monday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 25),\n      Meetup.new(3, 2013).day(:monday, :last)\n  end\n\n  def test_last_monday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 29),\n      Meetup.new(4, 2013).day(:monday, :last)\n  end\n\n  def test_last_tuesday_of_may_2013\n    skip\n    assert_equal Date.new(2013, 5, 28),\n      Meetup.new(5, 2013).day(:tuesday, :last)\n  end\n\n  def test_last_tuesday_of_june_2013\n    skip\n    assert_equal Date.new(2013, 6, 25),\n      Meetup.new(6, 2013).day(:tuesday, :last)\n  end\n\n  def test_last_wednesday_of_july_2013\n    skip\n    assert_equal Date.new(2013, 7, 31),\n      Meetup.new(7, 2013).day(:wednesday, :last)\n  end\n\n  def test_last_wednesday_of_august_2013\n    skip\n    assert_equal Date.new(2013, 8, 28),\n      Meetup.new(8, 2013).day(:wednesday, :last)\n  end\n\n  def test_last_thursday_of_september_2013\n    skip\n    assert_equal Date.new(2013, 9, 26),\n      Meetup.new(9, 2013).day(:thursday, :last)\n  end\n\n  def test_last_thursday_of_october_2013\n    skip\n    assert_equal Date.new(2013, 10, 31),\n      Meetup.new(10, 2013).day(:thursday, :last)\n  end\n\n  def test_last_friday_of_november_2013\n    skip\n    assert_equal Date.new(2013, 11, 29),\n      Meetup.new(11, 2013).day(:friday, :last)\n  end\n\n  def test_last_friday_of_december_2013\n    skip\n    assert_equal Date.new(2013, 12, 27),\n      Meetup.new(12, 2013).day(:friday, :last)\n  end\n\n  def test_last_saturday_of_january_2013\n    skip\n    assert_equal Date.new(2013, 1, 26),\n      Meetup.new(1, 2013).day(:saturday, :last)\n  end\n\n  def test_last_saturday_of_february_2013\n    skip\n    assert_equal Date.new(2013, 2, 23),\n      Meetup.new(2, 2013).day(:saturday, :last)\n  end\n\n  def test_last_sunday_of_march_2013\n    skip\n    assert_equal Date.new(2013, 3, 31),\n      Meetup.new(3, 2013).day(:sunday, :last)\n  end\n\n  def test_last_sunday_of_april_2013\n    skip\n    assert_equal Date.new(2013, 4, 28),\n      Meetup.new(4, 2013).day(:sunday, :last)\n  end\nend\n",
        "README.md": "# Meetup\n\nCalculate the date of meetups.\n\nTypically meetups happen on the same day of the week.\n\nExamples are\n\n- the first Monday\n- the third Tuesday\n- the Wednesteenth\n- the last Thursday\n\nNote that \"Monteenth\", \"Tuesteenth\", etc are all made up words. There\nwas a meetup whose members realised that there are exactly 7 days that\nend in '-teenth'. Therefore, one is guaranteed that each day of the week\n(Monday, Tuesday, ...) will have exactly one date that is named with '-teenth'\nin every month.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJeremy Hinegardner mentioned a Boulder meetup that happens on the Wednesteenth of every month [view source](https://twitter.com/copiousfreetime)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/queen-attack",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "queen-attack",
      "name": "Queen Attack",
      "files": {
        "queen_attack_test.rb": "require 'minitest/autorun'\nrequire_relative 'queens'\n\nclass QueensTest < Minitest::Test\n  def test_default_positions\n    queens = Queens.new\n    assert_equal [0, 3], queens.white\n    assert_equal [7, 3], queens.black\n  end\n\n  def test_specific_placement\n    skip\n    queens = Queens.new(white: [3, 7], black: [6, 1])\n    assert_equal [3, 7], queens.white\n    assert_equal [6, 1], queens.black\n  end\n\n  def test_multiple_boards_simultaneously\n    skip\n    queens1 = Queens.new(white: [3, 7], black: [6, 1])\n    queens2 = Queens.new(white: [5, 4], black: [7, 7])\n    assert_equal [3, 7], queens1.white\n    assert_equal [6, 1], queens1.black\n    assert_equal [5, 4], queens2.white\n    assert_equal [7, 7], queens2.black\n  end\n\n  def test_cannot_occupy_same_space\n    skip\n    assert_raises ArgumentError do\n      Queens.new(white: [2, 4], black: [2, 4])\n    end\n  end\n\n  def test_string_representation # rubocop:disable Metrics/MethodLength\n    skip\n    queens = Queens.new(white: [2, 4], black: [6, 6])\n    board = <<-BOARD.chomp\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ W _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ B _\n_ _ _ _ _ _ _ _\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  def test_another_string_representation # rubocop:disable Metrics/MethodLength\n    skip\n    queens = Queens.new(white: [7, 1], black: [0, 0])\n    board = <<-BOARD.chomp\nB _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ W _ _ _ _ _ _\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  # rubocop:disable Metrics/MethodLength\n  def test_yet_another_string_representation\n    skip\n    queens = Queens.new(white: [4, 3], black: [3, 4])\n    board = <<-BOARD.chomp\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ B _ _ _\n_ _ _ W _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n    BOARD\n    assert_equal board, queens.to_s\n  end\n\n  def test_cannot_attack\n    skip\n    queens = Queens.new(white: [2, 3], black: [4, 7])\n    assert !queens.attack?\n  end\n  # rubocop:enable Metrics/MethodLength\n\n  def test_can_attack_on_same_row\n    skip\n    queens = Queens.new(white: [2, 4], black: [2, 7])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_same_column\n    skip\n    queens = Queens.new(white: [5, 4], black: [2, 4])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_diagonal\n    skip\n    queens = Queens.new(white: [1, 1], black: [6, 6])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_other_diagonal\n    skip\n    queens = Queens.new(white: [0, 6], black: [1, 7])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_yet_another_diagonal\n    skip\n    queens = Queens.new(white: [4, 1], black: [6, 3])\n    assert queens.attack?\n  end\n\n  def test_can_attack_on_a_diagonal_slanted_the_other_way\n    skip\n    queens = Queens.new(white: [6, 1], black: [1, 6])\n    assert queens.attack?\n  end\nend\n",
        "README.md": "# Queen Attack\n\nWrite a program that positions two queens on a chess board and indicates whether or not they are positioned so that they can attack each other.\n\nIn the game of chess, a queen can attack pieces which are on the same\nrow, column, or diagonal.\n\nA chessboard can be represented by an 8 by 8 array.\n\nSo if you're told the white queen is at (2, 3) and the black queen at\n(5, 6), then you'd know you've got a set-up like so:\n\n```plain\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ W _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ B _\n_ _ _ _ _ _ _ _\n_ _ _ _ _ _ _ _\n```\n\nYou'd also be able to answer whether the queens can attack each other.\nIn this case, that answer would be yes, they can, because both pieces\nshare a diagonal.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/palindrome-products",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "palindrome-products",
      "name": "Palindrome Products",
      "files": {
        "palindrome_products_test.rb": "require 'minitest/autorun'\nrequire_relative 'palindromes'\n\nclass PalindromesTest < Minitest::Test\n  def test_largest_palindrome_from_single_digit_factors\n    palindromes = Palindromes.new(max_factor: 9)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 9, largest.value\n    assert_includes [[[3, 3], [1, 9]], [[1, 9], [3, 3]]], largest.factors\n  end\n\n  def test_largest_palindrome_from_double_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 99, min_factor: 10)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 9009, largest.value\n    assert_equal [[91, 99]], largest.factors\n  end\n\n  def test_smallest_palindrome_from_double_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 99, min_factor: 10)\n    palindromes.generate\n    smallest = palindromes.smallest\n    assert_equal 121, smallest.value\n    assert_equal [[11, 11]], smallest.factors\n  end\n\n  def test_largest_palindrome_from_triple_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 999, min_factor: 100)\n    palindromes.generate\n    largest = palindromes.largest\n    assert_equal 906_609, largest.value\n    assert_equal [[913, 993]], largest.factors\n  end\n\n  def test_smallest_palindrome_from_triple_digit_factors\n    skip\n    palindromes = Palindromes.new(max_factor: 999, min_factor: 100)\n    palindromes.generate\n    smallest = palindromes.smallest\n    assert_equal 10_201, smallest.value\n    assert_equal [[101, 101]], smallest.factors\n  end\nend\n",
        "README.md": "# Palindrome Products\n\nWrite a program that can detect palindrome products in a given range.\n\nA palindromic number reads the same both ways. The largest palindrome\nmade from the product of two 2-digit numbers is 9009 = 91 x 99.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nProblem 4 at Project Euler [view source](http://projecteuler.net/problem=4)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/matrix",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "matrix",
      "name": "Matrix",
      "files": {
        "matrix_test.rb": "require 'minitest/autorun'\nrequire_relative 'matrix'\n\nclass MatrixTest < Minitest::Test\n  def test_extract_a_row\n    matrix = Matrix.new(\"1 2\\n10 20\")\n    assert_equal [1, 2], matrix.rows[0]\n  end\n\n  def test_extract_same_row_again\n    skip\n    matrix = Matrix.new(\"9 7\\n8 6\")\n    assert_equal [9, 7], matrix.rows[0]\n  end\n\n  def test_extract_other_row\n    skip\n    matrix = Matrix.new(\"9 8 7\\n19 18 17\")\n    assert_equal [19, 18, 17], matrix.rows[1]\n  end\n\n  def test_extract_other_row_again\n    skip\n    matrix = Matrix.new(\"1 4 9\\n16 25 36\")\n    assert_equal [16, 25, 36], matrix.rows[1]\n  end\n\n  def test_extract_a_column\n    skip\n    matrix = Matrix.new(\"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\")\n    assert_equal [1, 4, 7, 8], matrix.columns[0]\n  end\n\n  def test_extract_another_column\n    skip\n    matrix = Matrix.new(\"89 1903 3\\n18 3 1\\n9 4 800\")\n    assert_equal [1903, 3, 4], matrix.columns[1]\n  end\nend\n",
        "README.md": "# Matrix\n\nWrite a program that, given a string representing a matrix of numbers, can return the rows and columns of that matrix.\n\nSo given a string with embedded newlines like:\n\n> 9 8 7\n> 5 3 2\n> 6 6 7\n\nrepresenting this matrix:\n\n```plain\n    0  1  2\n  |---------\n0 | 9  8  7\n1 | 5  3  2\n2 | 6  6  7\n```\n\nyour code should be able to spit out:\n\n- A list of the rows, reading each row left-to-right while moving\n  top-to-bottom across the rows,\n- A list of the columns, reading each column top-to-bottom while moving\n  from left-to-right.\n\nThe rows for our example matrix:\n\n- 9, 8, 7\n- 5, 3, 2\n- 6, 6, 7\n\nAnd its columns:\n\n- 9, 5, 6\n- 8, 3, 6\n- 7, 2, 7\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWarmup to the `saddle-points` warmup. [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/saddle-points",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "saddle-points",
      "name": "Saddle Points",
      "files": {
        "saddle_points_test.rb": "require 'minitest/autorun'\nrequire_relative 'matrix'\n\nclass MatrixTest < Minitest::Test\n  def test_extract_a_row\n    matrix = Matrix.new(\"1 2\\n10 20\")\n    assert_equal [1, 2], matrix.rows[0]\n  end\n\n  def test_extract_same_row_again\n    skip\n    matrix = Matrix.new(\"9 7\\n8 6\")\n    assert_equal [9, 7], matrix.rows[0]\n  end\n\n  def test_extract_other_row\n    skip\n    matrix = Matrix.new(\"9 8 7\\n19 18 17\")\n    assert_equal [19, 18, 17], matrix.rows[1]\n  end\n\n  def test_extract_other_row_again\n    skip\n    matrix = Matrix.new(\"1 4 9\\n16 25 36\")\n    assert_equal [16, 25, 36], matrix.rows[1]\n  end\n\n  def test_extract_a_column\n    skip\n    matrix = Matrix.new(\"1 2 3\\n4 5 6\\n7 8 9\\n 8 7 6\")\n    assert_equal [1, 4, 7, 8], matrix.columns[0]\n  end\n\n  def test_extract_another_column\n    skip\n    matrix = Matrix.new(\"89 1903 3\\n18 3 1\\n9 4 800\")\n    assert_equal [1903, 3, 4], matrix.columns[1]\n  end\n\n  def test_no_saddle_point\n    skip\n    matrix = Matrix.new(\"2 1\\n1 2\")\n    assert_equal [], matrix.saddle_points\n  end\n\n  def test_a_saddle_point\n    skip\n    matrix = Matrix.new(\"1 2\\n3 4\")\n    assert_equal [[0, 1]], matrix.saddle_points\n  end\n\n  def test_another_saddle_point\n    skip\n    matrix = Matrix.new(\"18 3 39 19 91\\n38 10 8 77 320\\n3 4 8 6 7\")\n    assert_equal [[2, 2]], matrix.saddle_points\n  end\n\n  def test_multiple_saddle_points\n    skip\n    matrix = Matrix.new(\"4 5 4\\n3 5 5\\n1 5 4\")\n    assert_equal [[0, 1], [1, 1], [2, 1]], matrix.saddle_points\n  end\nend\n",
        "README.md": "# Saddle Points\n\nWrite a program that detects saddle points in a matrix.\n\nSo say you have a matrix like so:\n\n```plain\n    0  1  2\n  |---------\n0 | 9  8  7\n1 | 5  3  2     <--- saddle point at (1,0)\n2 | 6  6  7\n```\n\nIt has a saddle point at (1, 0).\n\nIt's called a \"saddle point\" because it is greater than or equal to\nevery element in its row and the less than or equal to every element in\nits column.\n\nA matrix may have zero or more saddle points.\n\nYour code should be able to provide the (possibly empty) list of all the\nsaddle points for any given matrix.\n\nNote that you may find other definitions of matrix saddle points online,\nbut the tests for this exercise follow the above unambiguous definition.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJ Dalbey's Programming Practice problems [view source](http://users.csc.calpoly.edu/~jdalbey/103/Projects/ProgrammingPractice.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/triangle",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "triangle",
      "name": "Triangle",
      "files": {
        "triangle_test.rb": "require 'minitest/autorun'\nrequire_relative 'triangle'\n\nclass TriangleTest < Minitest::Test\n  def test_equilateral_triangles_have_equal_sides\n    assert_equal :equilateral, Triangle.new(2, 2, 2).kind\n  end\n\n  def test_larger_equilateral_triangles_also_have_equal_sides\n    skip\n    assert_equal :equilateral, Triangle.new(10, 10, 10).kind\n  end\n\n  def test_isosceles_triangles_have_last_two_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(3, 4, 4).kind\n  end\n\n  def test_isosceles_triangles_have_first_and_last_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(4, 3, 4).kind\n  end\n\n  def test_isosceles_triangles_have_two_first_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(4, 4, 3).kind\n  end\n\n  def test_isosceles_triangles_have_in_fact_exactly_two_sides_equal\n    skip\n    assert_equal :isosceles, Triangle.new(10, 10, 2).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides\n    skip\n    assert_equal :scalene, Triangle.new(3, 4, 5).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides_at_a_larger_scale_too\n    skip\n    assert_equal :scalene, Triangle.new(10, 11, 12).kind\n  end\n\n  def test_scalene_triangles_have_no_equal_sides_in_descending_order_either\n    skip\n    assert_equal :scalene, Triangle.new(5, 4, 2).kind\n  end\n\n  def test_very_small_triangles_are_legal\n    skip\n    assert_equal :scalene, Triangle.new(0.4, 0.6, 0.3).kind\n  end\n\n  def test_triangles_with_no_size_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(0, 0, 0).kind\n    end\n  end\n\n  def test_triangles_with_negative_sides_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(3, 4, -5).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(1, 1, 3).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal_2\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(2, 4, 2).kind\n    end\n  end\n\n  def test_triangles_violating_triangle_inequality_are_illegal_3\n    skip\n    assert_raises(TriangleError) do\n      Triangle.new(7, 3, 2).kind\n    end\n  end\nend\n",
        "README.md": "# Triangle\n\nWrite a program that can tell you if a triangle is equilateral, isosceles, or scalene.\n\nThe program should raise an error if the triangle cannot exist.\n\nTests are provided, delete one `skip` at a time.\n\n## Hint\n\nThe sum of the lengths of any two sides of a triangle always exceeds the\nlength of the third side, a principle known as the _triangle\ninequality_.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Ruby Koans triangle project, parts 1 & 2 [view source](http://rubykoans.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/atbash-cipher",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "atbash-cipher",
      "name": "Atbash Cipher",
      "files": {
        "atbash_cipher_test.rb": "require 'minitest/autorun'\nrequire_relative 'atbash'\n\n# rubocop:disable Style/MethodName\nclass AtbashTest < Minitest::Test\n  def test_encode_no\n    assert_equal 'ml', Atbash.encode('no')\n  end\n\n  def test_encode_yes\n    skip\n    assert_equal 'bvh', Atbash.encode('yes')\n  end\n\n  def test_encode_OMG\n    skip\n    assert_equal 'lnt', Atbash.encode('OMG')\n  end\n\n  def test_encode_O_M_G\n    skip\n    assert_equal 'lnt', Atbash.encode('O M G')\n  end\n\n  def test_encode_long_word\n    skip\n    assert_equal 'nrmwy oldrm tob', Atbash.encode('mindblowingly')\n  end\n\n  def test_encode_numbers\n    skip\n    assert_equal('gvhgr mt123 gvhgr mt',\n                 Atbash.encode('Testing, 1 2 3, testing.'))\n  end\n\n  def test_encode_sentence\n    skip\n    assert_equal 'gifgs rhurx grlm', Atbash.encode('Truth is fiction.')\n  end\n\n  def test_encode_all_the_things\n    skip\n    plaintext = 'The quick brown fox jumps over the lazy dog.'\n    cipher = 'gsvjf rxpyi ldmul cqfnk hlevi gsvoz abwlt'\n    assert_equal cipher, Atbash.encode(plaintext)\n  end\nend\n",
        "README.md": "# Atbash Cipher\n\nCreate an implementation of the atbash cipher, an ancient encryption system created in the Middle East.\n\nThe Atbash cipher is a simple substitution cipher that relies on\ntransposing all the letters in the alphabet such that the resulting\nalphabet is backwards. The first letter is replaced with the last\nletter, the second with the second-last, and so on.\n\nAn Atbash cipher for the Latin alphabet would be as follows:\n\n```plain\nPlain:  abcdefghijklmnopqrstuvwxyz\nCipher: zyxwvutsrqponmlkjihgfedcba\n```\n\nIt is a very weak cipher because it only has one possible key, and it is\na simple monoalphabetic substitution cipher. However, this may not have\nbeen an issue in the cipher's time.\n\nCiphertext is written out in groups of fixed length, the traditional group size\nbeing 5 letters, and punctuation is excluded. This is to make it harder to guess\nthings based on word boundaries.\n\n## Examples\n- Encoding `test` gives `gvhg`\n- Decoding `gvhg` gives `test`\n- Decoding `gsvjf rxpyi ldmul cqfnk hlevi gsvoz abwlt` gives `The quick brown fox jumps over the lazy dog.`\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Atbash)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/house",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "house",
      "name": "House",
      "files": {
        "house_test.rb": "require 'minitest/autorun'\nrequire_relative 'house'\n\n# rubocop:disable Metrics/MethodLength\nclass HouseTest < Minitest::Test\n  def test_rhyme\n    expected = <<-RHYME\nThis is the house that Jack built.\n\nThis is the malt\nthat lay in the house that Jack built.\n\nThis is the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the horse and the hound and the horn\nthat belonged to the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n    RHYME\n    assert_equal expected, House.recite\n  end\nend\n",
        "README.md": "# House\n\nWrite a program that outputs the nursery rhyme 'This is the House that Jack Built'.\n\n> [The] process of placing a phrase of clause within another phrase of\n> clause is called embedding. It is through the processes of recursion\n> and embedding that we are able to take a finite number of forms (words\n> and phrases) and construct an infinite number of expressions.\n> Furthermore, embedding also allows us to construct an infinitely long\n> structure, in theory anyway.\n\n- [papyr.com](http://papyr.com/hypertextbooks/grammar/ph_noun.htm)\n\n\nThe nursery rhyme reads as follows:\n\n```plain\nThis is the house that Jack built.\n\nThis is the malt\nthat lay in the house that Jack built.\n\nThis is the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n\nThis is the horse and the hound and the horn\nthat belonged to the farmer sowing his corn\nthat kept the rooster that crowed in the morn\nthat woke the priest all shaven and shorn\nthat married the man all tattered and torn\nthat kissed the maiden all forlorn\nthat milked the cow with the crumpled horn\nthat tossed the dog\nthat worried the cat\nthat killed the rat\nthat ate the malt\nthat lay in the house that Jack built.\n```\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nBritish nursery rhyme [view source](http://en.wikipedia.org/wiki/This_Is_The_House_That_Jack_Built)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/secret-handshake",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "secret-handshake",
      "name": "Secret Handshake",
      "files": {
        "secret_handshake_test.rb": "require 'minitest/autorun'\nrequire_relative 'secret_handshake'\n\nclass SecretHandshakeTest < Minitest::Test\n  def test_handshake_1_to_wink\n    handshake = SecretHandshake.new(1)\n    assert_equal ['wink'], handshake.commands\n  end\n\n  def test_handshake_10_to_double_blink\n    skip\n    handshake = SecretHandshake.new(2)\n    assert_equal ['double blink'], handshake.commands\n  end\n\n  def test_handshake_100_to_close_your_eyes\n    skip\n    handshake = SecretHandshake.new(4)\n    assert_equal ['close your eyes'], handshake.commands\n  end\n\n  def test_handshake_1000_to_jump\n    skip\n    handshake = SecretHandshake.new(8)\n    assert_equal ['jump'], handshake.commands\n  end\n\n  def test_handshake_11_to_wink_and_double_blink\n    skip\n    handshake = SecretHandshake.new(3)\n    assert_equal ['wink', 'double blink'], handshake.commands\n  end\n\n  def test_handshake_10011_to_double_blink_and_wink\n    skip\n    handshake = SecretHandshake.new(19)\n    assert_equal ['double blink', 'wink'], handshake.commands\n  end\n\n  def test_handshake_11111_to_double_blink_and_wink\n    skip\n    handshake = SecretHandshake.new(31)\n    expected = ['jump', 'close your eyes', 'double blink', 'wink']\n    assert_equal expected, handshake.commands\n  end\n\n  def test_invalid_handshake\n    skip\n    handshake = SecretHandshake.new('piggies')\n    assert_equal [], handshake.commands\n  end\nend\n",
        "README.md": "# Secret Handshake\n\nWrite a program that will take a decimal number, and convert it to the appropriate sequence of events for a secret handshake.\n\n> There are 10 types of people in the world: Those who understand\n> binary, and those who don't.\n\nYou and your fellow cohort of those in the \"know\" when it comes to\nbinary decide to come up with a secret \"handshake\".\n\n```\n1 = wink\n10 = double blink\n100 = close your eyes\n1000 = jump\n\n\n10000 = Reverse the order of the operations in the secret handshake.\n```\n\n```\nhandshake = SecretHandshake.new 9\nhandshake.commands # => [\"wink\",\"jump\"]\n\nhandshake = SecretHandshake.new \"11001\"\nhandshake.commands # => [\"jump\",\"wink\"]\n```\n\nThe program should consider strings specifying an invalid binary as the\nvalue 0.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nBert, in Mary Poppins [view source](http://www.imdb.com/character/ch0011238/quotes)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/proverb",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "proverb",
      "name": "Proverb",
      "files": {
        "proverb_test.rb": "require 'minitest/autorun'\nrequire_relative 'proverb'\n\nclass ProverbTest < Minitest::Test\n  def test_a_single_consequence\n    proverb = Proverb.new('nail', 'shoe')\n    expected = \"For want of a nail the shoe was lost.\\n\" \\\n      'And all for the want of a nail.'\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_a_short_chain_of_consequences\n    skip\n    proverb = Proverb.new('nail', 'shoe', 'horse')\n    expected = \"For want of a nail the shoe was lost.\\n\" \\\n      \"For want of a shoe the horse was lost.\\n\" \\\n      'And all for the want of a nail.'\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_a_longer_chain_of_consequences\n    skip\n    proverb = Proverb.new('nail', 'shoe', 'horse', 'rider')\n    expected = \"For want of a nail the shoe was lost.\\n\" \\\n      \"For want of a shoe the horse was lost.\\n\" \\\n      \"For want of a horse the rider was lost.\\n\" \\\n      'And all for the want of a nail.'\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_proverb_does_not_hard_code_the_rhyme_dictionary\n    skip\n    proverb = Proverb.new('key', 'value')\n    expected = \"For want of a key the value was lost.\\n\" \\\n      'And all for the want of a key.'\n    assert_equal expected, proverb.to_s\n  end\n\n  def test_the_whole_proverb # rubocop:disable Metrics/MethodLength\n    skip\n    chain = %w(nail shoe horse rider message battle kingdom)\n    proverb = Proverb.new(*chain)\n    expected = \"For want of a nail the shoe was lost.\\n\" \\\n      \"For want of a shoe the horse was lost.\\n\" \\\n      \"For want of a horse the rider was lost.\\n\" \\\n      \"For want of a rider the message was lost.\\n\" \\\n      \"For want of a message the battle was lost.\\n\" \\\n      \"For want of a battle the kingdom was lost.\\n\" \\\n      'And all for the want of a nail.'\n    assert_equal expected, proverb.to_s\n  end\n\n  # rubocop:disable Metrics/MethodLength\n  def test_an_optional_qualifier_in_the_final_consequence\n    skip\n    chain = %w(nail shoe horse rider message battle kingdom)\n    proverb = Proverb.new(*chain, qualifier: 'horseshoe')\n    expected = \"For want of a nail the shoe was lost.\\n\" \\\n      \"For want of a shoe the horse was lost.\\n\" \\\n      \"For want of a horse the rider was lost.\\n\" \\\n      \"For want of a rider the message was lost.\\n\" \\\n      \"For want of a message the battle was lost.\\n\" \\\n      \"For want of a battle the kingdom was lost.\\n\" \\\n      'And all for the want of a horseshoe nail.'\n    assert_equal expected, proverb.to_s\n  end\n  # rubocop:enable Metrics/MethodLength\n\n  def test_proverb_is_same_each_time\n    skip\n    proverb = Proverb.new('nail', 'shoe')\n    assert_equal proverb.to_s, proverb.to_s\n  end\nend\n",
        "README.md": "# Proverb\n\nFor want of a horseshoe nail, a kingdom was lost, or so the saying goes. Write a program that outputs the full text of this proverbial rhyme.\n\nFor want of a nail the shoe was lost.\nFor want of a shoe the horse was lost.\nFor want of a horse the rider was lost.\nFor want of a rider the message was lost.\nFor want of a message the battle was lost.\nFor want of a battle the kingdom was lost.\nAnd all for the want of a horseshoe nail.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/For_Want_of_a_Nail)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/ocr-numbers",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "ocr-numbers",
      "name": "Ocr Numbers",
      "files": {
        "ocr_numbers_test.rb": "require 'minitest/autorun'\nrequire_relative 'ocr'\n\nclass OCRTest < Minitest::Test\n  def test_recognize_zero\n    text = <<-NUMBER.chomp\n _\n| |\n|_|\n\n    NUMBER\n    assert_equal '0', OCR.new(text).convert\n  end\n\n  def test_recognize_one\n    skip\n    text = <<-NUMBER.chomp\n\n  |\n  |\n\n    NUMBER\n    assert_equal '1', OCR.new(text).convert\n  end\n\n  def test_recognize_two\n    skip\n    text = <<-NUMBER.chomp\n _\n _|\n|_\n\n    NUMBER\n    assert_equal '2', OCR.new(text).convert\n  end\n\n  def test_recognize_three\n    skip\n    text = <<-NUMBER.chomp\n _\n _|\n _|\n\n    NUMBER\n    assert_equal '3', OCR.new(text).convert\n  end\n\n  def test_recognize_four\n    skip\n    text = <<-NUMBER.chomp\n\n|_|\n  |\n\n    NUMBER\n    assert_equal '4', OCR.new(text).convert\n  end\n\n  def test_recognize_five\n    skip\n    text = <<-NUMBER.chomp\n _\n|_\n _|\n\n    NUMBER\n    assert_equal '5', OCR.new(text).convert\n  end\n\n  def test_recognize_six\n    skip\n    text = <<-NUMBER.chomp\n _\n|_\n|_|\n\n    NUMBER\n    assert_equal '6', OCR.new(text).convert\n  end\n\n  def test_recognize_seven\n    skip\n    text = <<-NUMBER.chomp\n _\n  |\n  |\n\n    NUMBER\n    assert_equal '7', OCR.new(text).convert\n  end\n\n  def test_recognize_eight\n    skip\n    text = <<-NUMBER.chomp\n _\n|_|\n|_|\n\n    NUMBER\n    assert_equal '8', OCR.new(text).convert\n  end\n\n  def test_recognize_nine\n    skip\n    text = <<-NUMBER.chomp\n _\n|_|\n _|\n\n    NUMBER\n    assert_equal '9', OCR.new(text).convert\n  end\n\n  def test_identify_garble\n    skip\n    text = <<-NUMBER.chomp\n\n| |\n| |\n\n    NUMBER\n    assert_equal '?', OCR.new(text).convert\n  end\n\n  def test_identify_10\n    skip\n    text = <<-NUMBER.chomp\n    _\n  || |\n  ||_|\n\n    NUMBER\n    assert_equal '10', OCR.new(text).convert\n  end\n\n  def test_identify_110101100\n    skip\n    text = <<-NUMBER.chomp\n       _     _        _  _\n  |  || |  || |  |  || || |\n  |  ||_|  ||_|  |  ||_||_|\n\n    NUMBER\n    assert_equal '110101100', OCR.new(text).convert\n  end\n\n  def test_identify_with_garble\n    skip\n    text = <<-NUMBER.chomp\n       _     _           _\n  |  || |  || |     || || |\n  |  | _|  ||_|  |  ||_||_|\n\n    NUMBER\n    assert_equal '11?10?1?0', OCR.new(text).convert\n  end\n\n  def test_identify_1234567890\n    skip\n    text = <<-NUMBER.chomp\n    _  _     _  _  _  _  _  _\n  | _| _||_||_ |_   ||_||_|| |\n  ||_  _|  | _||_|  ||_| _||_|\n\n    NUMBER\n    assert_equal '1234567890', OCR.new(text).convert\n  end\n\n  def test_identify_123_456_789 # rubocop:disable Metrics/MethodLength\n    skip\n    text = <<-NUMBER.chomp\n    _  _\n  | _| _|\n  ||_  _|\n\n    _  _\n|_||_ |_\n  | _||_|\n\n _  _  _\n  ||_||_|\n  ||_| _|\n\nNUMBER\n    assert_equal '123,456,789', OCR.new(text).convert\n  end\nend\n",
        "README.md": "# Ocr Numbers\n\nWrite a program that, given a 3 x 4 grid of pipes, underscores, and spaces, can determine which number is represented, or whether it is garbled.\n\n## Step 1\n\nA simple binary font has been constructed using only pipes and\nunderscores.\n\nThe number is four rows high, three columns wide:\n\n     _   #\n    | |  # zero.\n    |_|  #\n         # the fourth row is always blank\n\n         #\n      |  # one.\n      |  #\n         # (blank fourth row)\n\nWrite a program that, given a 3 x 4 grid of pipes, underscores, and\nspaces, can determine whether the the grid represents a zero, a one, or\ngarble.\n\nAnything else is considered garble, and can be represented with a '?'\n\n## Step 2\n\nA simple numeric font has been constructed using only pipes and\nunderscores.\n\nThe number consists of four rows high, three columns wide:\n\n      _  _     _  _  _  _  _  _  #\n    | _| _||_||_ |_   ||_||_|| | # decimal numbers.\n    ||_  _|  | _||_|  ||_| _||_| #\n                                 # fourth line is always blank\n\nThere may be several numbers in the input text, one per line.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by the Bank OCR kata [view source](http://codingdojo.org/cgi-bin/wiki.pl?KataBankOCR)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/pig-latin",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "pig-latin",
      "name": "Pig Latin",
      "files": {
        "pig_latin_test.rb": "require 'minitest/autorun'\nrequire_relative 'pig_latin'\n\nclass PigLatinTest < Minitest::Test\n  def test_word_beginning_with_a\n    assert_equal 'appleay', PigLatin.translate('apple')\n  end\n\n  def test_other_word_beginning_e\n    skip\n    assert_equal 'earay', PigLatin.translate('ear')\n  end\n\n  def test_word_beginning_with_p\n    skip\n    assert_equal 'igpay', PigLatin.translate('pig')\n  end\n\n  def test_word_beginning_with_k\n    skip\n    assert_equal 'oalakay', PigLatin.translate('koala')\n  end\n\n  def test_word_beginning_with_ch\n    skip\n    assert_equal 'airchay', PigLatin.translate('chair')\n  end\n\n  def test_word_beginning_with_qu\n    skip\n    assert_equal 'eenquay', PigLatin.translate('queen')\n  end\n\n  def test_word_with_consonant_preceding_qu\n    skip\n    assert_equal 'aresquay', PigLatin.translate('square')\n  end\n\n  def test_word_beginning_with_th\n    skip\n    assert_equal 'erapythay', PigLatin.translate('therapy')\n  end\n\n  def test_word_beginning_with_thr\n    skip\n    assert_equal 'ushthray', PigLatin.translate('thrush')\n  end\n\n  def test_word_beginning_with_sch\n    skip\n    assert_equal 'oolschay', PigLatin.translate('school')\n  end\n\n  def test_translates_phrase\n    skip\n    assert_equal 'ickquay astfay unray', PigLatin.translate('quick fast run')\n  end\n\n  def test_word_beginning_with_ye\n    skip\n    assert_equal 'ellowyay', PigLatin.translate('yellow')\n  end\n\n  def test_word_beginning_with_yt\n    skip\n    assert_equal 'yttriaay', PigLatin.translate('yttria')\n  end\n\n  def test_word_beginning_with_xe\n    skip\n    assert_equal 'enonxay', PigLatin.translate('xenon')\n  end\n\n  def test_word_beginning_with_xr\n    skip\n    assert_equal 'xrayay', PigLatin.translate('xray')\n  end\nend\n",
        "README.md": "# Pig Latin\n\nImplement a program that translates from English to Pig Latin\n\nPig Latin is a made-up children's language that's intended to be\nconfusing. It obeys a few simple rules (below), but when it's spoken\nquickly it's really difficult for non-children (and non-native speakers)\nto understand.\n\n- **Rule 1**: If a word begins with a vowel sound, add an \"ay\" sound to\n  the end of the word.\n- **Rule 2**: If a word begins with a consonant sound, move it to the\n  end of the word, and then add an \"ay\" sound to the end of the word.\n\nThere are a few more rules for edge cases, and there are regional\nvariants too.\n\nSee <http://en.wikipedia.org/wiki/Pig_latin> for more details.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Pig Latin exercise at Test First Teaching by Ultrasaurus [view source](https://github.com/ultrasaurus/test-first-teaching/blob/master/learn_ruby/pig_latin/)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/simple-linked-list",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "simple-linked-list",
      "name": "Simple Linked List",
      "files": {
        "simple_linked_list_test.rb": "require 'minitest/autorun'\n\nrequire_relative 'linked_list'\n\nclass LinkedListTest < Minitest::Test\n  def setup\n    @one = Element.new(1, nil)\n    @two = Element.new(2, @one)\n  end\n\n  def test_constructor\n    assert_equal 1, @one.datum\n    # rubocop:disable Style/EmptyLines\n    assert_nil @one.next\n\n    assert_equal 2, @two.datum\n    assert_same @one, @two.next\n  end\n\n  def test_to_a\n    skip\n    assert_equal [], Element.to_a(nil)\n    assert_equal [1], Element.to_a(@one)\n    assert_equal [2, 1], Element.to_a(@two)\n  end\n\n  def test_reverse\n    skip\n    # one_r and @one need not be the same object\n    one_r = @one.reverse\n    assert_equal 1, one_r.datum\n    assert_nil one_r.next\n\n    two_r = @two.reverse\n    assert_equal 1, two_r.datum\n    assert_equal 2, two_r.next.datum\n\n    # ensure that nothing changed about the given objects\n    test_constructor\n  end\n\n  # rubocop:disable  Metrics/AbcSize\n  def test_from_a # rubocop:disable Metrics/MethodLength\n    skip\n    assert_nil Element.from_a([])\n\n    one_a = Element.from_a([1])\n    assert_equal 1, one_a.datum\n    assert_nil one_a.next\n\n    two_a = Element.from_a([2, 1])\n    assert_equal 2, two_a.datum\n    assert_equal 1, two_a.next.datum\n    assert_nil two_a.next.next\n\n    one_to_ten = Element.from_a(1..10)\n    assert_equal 10, one_to_ten.next.next.next.next.next.next.next.next.next.datum\n  end\n\n  def test_roundtrip\n    skip\n    assert_equal [1], Element.from_a([1]).to_a\n    assert_equal [2, 1], Element.from_a([2, 1]).to_a\n    # rubocop:disable Lint/ParenthesesAsGroupedExpression\n    assert_equal (1..10).to_a, Element.from_a(1..10).to_a\n  end\nend\n",
        "README.md": "# Simple Linked List\n\nWrite a simple linked list implementation that uses Elements and a loop\n\nThe linked list is a fundamental data structure in computer science,\noften used in the implementation of other data structures. They're\npervasive in functional programming languages, such as Clojure, Erlang,\nor Haskell, but far less common in imperative languages such as Ruby or\nPython.\n\nThe simplest kind of linked list is an immutable linked list, which is\nthe kind that's built-in to these functional programming languages.\nImmutable (or more specifically: persistent) data structures can be\ncopied in constant time (since a reference is equivalent to a copy), and\ncan save loads of time and memory for certain use cases because\nstructure can be shared between versions of the data structure.\n\nThis variant of linked lists is often used to represent sequences or\npush-down stacks (also called a LIFO stack; Last In, First Out).\n\nAs a first take, lets create a persistent linked list with just Element\nobjects containing the range (1..10), and provide functions to reverse a\nlinked list and convert to and from arrays.\n\nWhen implementing this in a language with built-in linked lists,\nimplement your own abstract data type.\n\nExamples (Ruby):\n\n    Element.to_a(nil) #=> []\n    Element.from_a([]) #=> nil\n    Element.reverse(nil) #=> nil\n    one = Element.new(1, nil)\n    one #=> <Element @datum=1, @next=nil>\n    one.datum #=> 1\n    one.next #=> nil\n    two = Element.new(2, one)\n    two #=> <Element @datum=2, @next=<Element @datum=1 @next=nil>>\n    Element.to_a(two) #=> [2, 1]\n    Element.reverse(two) #=> <Element @datum=1 @next=<Element @datum=2 @next=nil>>\n    range = Element.from_a(1..10)\n    range.datum #=> 1\n    range.next.next.next.next.next.next.next.next.next.next.datum #=> 10\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by 'Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby', singly linked-lists. [view source](http://www.brpreiss.com/books/opus8/html/page96.html#SECTION004300000000000000000)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/luhn",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "luhn",
      "name": "Luhn",
      "files": {
        "luhn_test.rb": "require 'minitest/autorun'\nrequire_relative 'luhn'\n\nclass LuhnTest < Minitest::Test\n  def test_addends\n    luhn = Luhn.new(12_121)\n    assert_equal [1, 4, 1, 4, 1], luhn.addends\n  end\n\n  def test_too_large_addend\n    skip\n    luhn = Luhn.new(8631)\n    assert_equal [7, 6, 6, 1], luhn.addends\n  end\n\n  def test_checksum\n    skip\n    luhn = Luhn.new(4913)\n    assert_equal 22, luhn.checksum\n  end\n\n  def test_checksum_again\n    skip\n    luhn = Luhn.new(201_773)\n    assert_equal 21, luhn.checksum\n  end\n\n  def test_invalid_number\n    skip\n    luhn = Luhn.new(738)\n    assert !luhn.valid?\n  end\n\n  def test_valid_number\n    skip\n    luhn = Luhn.new(8_739_567)\n    assert luhn.valid?\n  end\n\n  def test_create_valid_number\n    skip\n    number = Luhn.create(123)\n    assert_equal 1230, number\n  end\n\n  def test_create_other_valid_number\n    skip\n    number = Luhn.create(873_956)\n    assert_equal 8_739_567, number\n  end\n\n  def test_create_yet_another_valid_number\n    skip\n    number = Luhn.create(837_263_756)\n    assert_equal 8_372_637_564, number\n  end\nend\n",
        "README.md": "# Luhn\n\nWrite a program that can take a number and determine whether or not it is valid per the Luhn formula.\n\nThe Luhn formula is a simple checksum formula used to validate a variety\nof identification numbers, such as credit card numbers and Canadian\nSocial Insurance Numbers.\n\nThe formula verifies a number against its included check digit, which is\nusually appended to a partial number to generate the full number. This\nnumber must pass the following test:\n\n- Counting from rightmost digit (which is the check digit) and moving\n  left, double the value of every second digit.\n- For any digits that thus become 10 or more, subtract 9 from the\n  result.\n  - 1111 becomes 2121.\n  - 8763 becomes 7733 (from 2Ã—6=12 â†’ 12-9=3 and 2Ã—8=16 â†’ 16-9=7).\n- Add all these digits together.\n  - 1111 becomes 2121 sums as 2+1+2+1 to give a check digit of 6.\n  - 8763 becomes 7733, and 7+7+3+3 is 20.\n\nIf the total ends in 0 (put another way, if the total modulus 10 is\ncongruent to 0), then the number is valid according to the Luhn formula;\nelse it is not valid. So, 1111 is not valid (as shown above, it comes\nout to 6), while 8763 is valid (as shown above, it comes out to 20).\n\nWrite a program that, given a number\n\n- Can check if it is valid per the Luhn formula. This should treat, for\n  example, \"2323 2005 7766 3554\" as valid.\n- Can return the checksum, or the remainder from using the Luhn method.\n- Can add a check digit to make the number valid per the Luhn formula and\n  return the original number plus that digit. This should give \"2323 2005 7766\n  3554\" in response to \"2323 2005 7766 355\".\n\n## About Checksums\n\nA checksum has to do with error-detection. There are a number of different\nways in which a checksum could be calculated.\n\nWhen transmitting data, you might also send along a checksum that says how\nmany bytes of data are being sent. That means that when the data arrives on\nthe other side, you can count the bytes and compare it to the checksum. If\nthese are different, then the data has been garbled in transmission.\n\nIn the Luhn problem the final digit acts as a sanity check for all the prior\ndigits. Running those prior digits through a particular algorithm should give\nyou that final digit.\n\nIt doesn't actually tell you if it's a real credit card number, only that it's\na plausible one. It's the same thing with the bytes that get transmitted --\nyou could have the right number of bytes and still have a garbled message. So\nchecksums are a simple sanity-check, not a real in-depth verification of the\nauthenticity of some data. It's often a cheap first pass, and can be used to\nquickly discard obviously invalid things.\n\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nThe Luhn Algorithm on Wikipedia [view source](http://en.wikipedia.org/wiki/Luhn_algorithm)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/simple-cipher",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "simple-cipher",
      "name": "Simple Cipher",
      "files": {
        "simple_cipher_test.rb": "require 'minitest/autorun'\nrequire_relative 'cipher'\n\nclass RandomKeyCipherTest < Minitest::Test\n  def setup\n    @cipher = Cipher.new\n  end\n\n  def test_cipher_key_is_letters\n    assert_match(/[a-z]+/, @cipher.key)\n  end\n\n  # Here we take advantage of the fact that plaintext of \"aaa...\" doesn't\n  # outputs the key. This is a critical problem with shift ciphers, some\n  # characters will always output the key verbatim.\n  def test_cipher_encode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    assert_equal(@cipher.key[0, 10], @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    assert_equal(plaintext, @cipher.decode(@cipher.key[0, 10]))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = 'abcdefghij'\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\nend\n\nclass IncorrectKeyCipherTest < Minitest::Test\n  def test_cipher_with_caps_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new('ABCDEF')\n    end\n  end\n\n  def test_cipher_with_numeric_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new('12345')\n    end\n  end\n\n  def test_cipher_with_empty_key\n    skip\n    assert_raises ArgumentError do\n      Cipher.new('')\n    end\n  end\nend\n\nclass SubstitutionCipherTest < Minitest::Test\n  def setup\n    @key = 'abcdefghij'\n    @cipher = Cipher.new(@key)\n  end\n\n  def test_cipher_key_is_as_submitted\n    skip\n    assert_equal(@cipher.key, @key)\n  end\n\n  def test_cipher_encode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    ciphertext = 'abcdefghij'\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    ciphertext = 'abcdefghij'\n    assert_equal(plaintext, @cipher.decode(ciphertext))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = 'abcdefghij'\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\n\n  def test_double_shift_encode\n    skip\n    plaintext = 'iamapandabear'\n    ciphertext = 'qayaeaagaciai'\n    assert_equal(ciphertext, Cipher.new('iamapandabear').encode(plaintext))\n  end\n\n  def test_cipher_encode_wrap\n    skip\n    plaintext = 'zzzzzzzzzz'\n    ciphertext = 'zabcdefghi'\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\nend\n\nclass PseudoShiftCipherTest < Minitest::Test\n  def setup\n    @cipher = Cipher.new('dddddddddd')\n  end\n\n  def test_cipher_encode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    ciphertext = 'dddddddddd'\n    assert_equal(ciphertext, @cipher.encode(plaintext))\n  end\n\n  def test_cipher_decode\n    skip\n    plaintext = 'aaaaaaaaaa'\n    ciphertext = 'dddddddddd'\n    assert_equal(plaintext, @cipher.decode(ciphertext))\n  end\n\n  def test_cipher_reversible\n    skip\n    plaintext = 'abcdefghij'\n    assert_equal(plaintext, @cipher.decode(@cipher.encode(plaintext)))\n  end\nend\n",
        "README.md": "# Simple Cipher\n\nImplement a simple shift cipher like Caesar and a more secure substitution cipher\n\n## Step 1\n\n\"If he had anything confidential to say, he wrote it in cipher, that is,\nby so changing the order of the letters of the alphabet, that not a word\ncould be made out. If anyone wishes to decipher these, and get at their\nmeaning, he must substitute the fourth letter of the alphabet, namely D,\nfor A, and so with the others.\"\nâ€”Suetonius, Life of Julius Caesar\n\nCiphers are very straight-forward algorithms that allow us to render\ntext less readable while still allowing easy deciphering. They are\nvulnerable to many forms of cryptoanalysis, but we are lucky that\ngenerally our little sisters are not cryptoanalysts.\n\nThe Caeser Cipher was used for some messages from Julius Caesar that\nwere sent afield. Now Caeser knew that the cipher wasn't very good, but\nhe had one ally in that respect: almost nobody could read well. So even\nbeing a couple letters off was sufficient so that people couldn't\nrecognize the few words that they did know.\n\nYour task is to create a simple shift cipher like the Caesar Cipher.\nThis image is a great example of the Caesar Cipher: ![Caesar Cipher][1]\n\nHere are some examples:\n\n    @cipher = Cipher.new\n    @cipher.encode(\"iamapandabear\") #=> \"ldpdsdqgdehdu\"\n    @cipher.decode(\"ldpdsdqgdehdu\") #=> \"iamapandabear\"\n\n## Step 2\n\nShift ciphers are no fun though when your kid sister figures it out. Try\namending the code to allow us to specify a key and use that for the\nshift distance. This is called a substitution cipher.\n\nHere's an example:\n\n    @cipher = Cipher.new(\"aaaaaaaaaaaaaaaaaa\")\n    @cipher.encode(\"iamapandabear\") #=> \"iamapandabear\"\n    @cipher = Cipher.new(\"ddddddddddddddddd\")\n    @cipher.encode(\"imapandabear\") #=> \"lpdsdqgdehdu\"\n\nIn the example above, we've set a = 0 for the key value. So when the\nplaintext is added to the key, we end up with the same message coming\nout. So \"aaaa\" is not an ideal key. But if we set the key to \"dddd\", we\nwould get the same thing as the Caesar Cipher.\n\n## Step 3\n\nThe weakest link in any cipher is the human being. Let's make your\nsubstitution cipher a little more fault tolerant by providing a source\nof randomness and ensuring that they key is not composed of numbers or\ncapital letters.\n\nIf someone doesn't submit a key at all, generate a truly random key of\nat least 100 characters in length, accessible via Cipher#key (the #\nsyntax means instance variable)\n\nIf the key submitted has capital letters or numbers, throw an\nArgumentError with a message to that effect.\n\nSome examples:\n    @cipher = Cipher.new\n    @cipher.key #=> \"duxrceqyaimciuucnelkeoxjhdyduucpmrxmaivacmybmsdrzwqxvbxsygzsabdjmdjabeorttiwinfrpmpogvabiofqexnohrqu\"\n\n## Extensions\n\nShift ciphers work by making the text slightly odd, but are vulnerable\nto frequency analysis. Substitution ciphers help that, but are still\nvery vulnerable when the key is short or if spaces are preserved. Later\non you'll see one solution to this problem in the exercise\n\"crypto-square\".\n\nIf you want to go farther in this field, the questions begin to be about\nhow we can exchange keys in a secure way. Take a look at [Diffie-Hellman\non Wikipedia][dh] for one of the first implementations of this scheme.\n\n[1]: http://upload.wikimedia.org/wikipedia/en/7/75/Caesar3.png\n[dh]: http://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nSubstitution Cipher at Wikipedia [view source](http://en.wikipedia.org/wiki/Substitution_cipher)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/wordy",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "wordy",
      "name": "Wordy",
      "files": {
        "wordy_test.rb": "require 'minitest/autorun'\nrequire_relative 'word_problem'\n\nclass WordProblemTest < Minitest::Test\n  def test_add_1\n    assert_equal 2, WordProblem.new('What is 1 plus 1?').answer\n  end\n\n  def test_add_2\n    skip\n    assert_equal 55, WordProblem.new('What is 53 plus 2?').answer\n  end\n\n  def test_add_negative_numbers\n    skip\n    assert_equal(-11, WordProblem.new('What is -1 plus -10?').answer)\n  end\n\n  def test_add_more_digits\n    skip\n    assert_equal 45_801, WordProblem.new('What is 123 plus 45678?').answer\n  end\n\n  def test_subtract\n    skip\n    assert_equal 16, WordProblem.new('What is 4 minus -12?').answer\n  end\n\n  def test_multiply\n    skip\n    assert_equal(-75, WordProblem.new('What is -3 multiplied by 25?').answer)\n  end\n\n  def test_divide\n    skip\n    assert_equal(-11, WordProblem.new('What is 33 divided by -3?').answer)\n  end\n\n  def test_add_twice\n    skip\n    question = 'What is 1 plus 1 plus 1?'\n    assert_equal 3, WordProblem.new(question).answer\n  end\n\n  def test_add_then_subtract\n    skip\n    question = 'What is 1 plus 5 minus -2?'\n    assert_equal 8, WordProblem.new(question).answer\n  end\n\n  def test_subtract_twice\n    skip\n    question = 'What is 20 minus 4 minus 13?'\n    assert_equal 3, WordProblem.new(question).answer\n  end\n\n  def test_subtract_then_add\n    skip\n    question = 'What is 17 minus 6 plus 3?'\n    assert_equal 14, WordProblem.new(question).answer\n  end\n\n  def test_multiply_twice\n    skip\n    question = 'What is 2 multiplied by -2 multiplied by 3?'\n    assert_equal(-12, WordProblem.new(question).answer)\n  end\n\n  def test_add_then_multiply\n    skip\n    question = 'What is -3 plus 7 multiplied by -2?'\n    assert_equal(-8, WordProblem.new(question).answer)\n  end\n\n  def test_divide_twice\n    skip\n    question = 'What is -12 divided by 2 divided by -3?'\n    assert_equal 2, WordProblem.new(question).answer\n  end\n\n  def test_too_advanced\n    skip\n    assert_raises ArgumentError do\n      WordProblem.new('What is 53 cubed?').answer\n    end\n  end\n\n  def test_irrelevant\n    skip\n    assert_raises ArgumentError do\n      WordProblem.new('Who is the president of the United States?').answer\n    end\n  end\nend\n",
        "README.md": "# Wordy\n\nWrite a program that takes a word problem and returns the answer as an integer.\n\n## Step 1\n\nE.g.\n\n> What is 5 plus 13?\n\nThe program should handle large numbers and negative numbers.\n\nUse the tests to drive your solution by deleting the `skip` in one test\nat a time.\n\n## Step 2\n\nE.g.\n\n> What is 5 plus 13?\n\n> What is 7 minus 5?\n\n> What is 6 multiplied by 4?\n\n> What is 25 divided by 5?\n\n## Step 3\n\nE.g.\n\n> What is 5 plus 13 plus 6?\n\n> What is 7 minus 5 minus 1?\n\n> What is 9 minus 3 plus 5?\n\n> What is 3 plus 5 minus 8?\n\n## Step 4\n\nE.g.\n\n> What is 5 plus 13?\n\n> What is 7 minus 5?\n\n> What is 6 times 4?\n\n> What is 25 divided by 5?\n\n> What is 78 plus 5 minus 3?\n\n> What is 18 times 3 plus 16?\n\n> What is 4 times 3 divided by 6?\n\n> What is 4 plus 3 times 2?\n\n## Extensions\n\nImplement questions of the type:\n\n> What is 2 raised to the 5th power?\n\nRemember to write failing tests for this code.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by one of the generated questions in the Extreme Startup game. [view source](https://github.com/rchatley/extreme_startup)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/allergies",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "allergies",
      "name": "Allergies",
      "files": {
        "allergies_test.rb": "require 'minitest/autorun'\nrequire_relative 'allergies'\n\nclass AllergiesTest < Minitest::Test\n  def test_no_allergies_means_not_allergic\n    allergies = Allergies.new(0)\n    refute allergies.allergic_to?('peanuts')\n    refute allergies.allergic_to?('cats')\n    refute allergies.allergic_to?('strawberries')\n  end\n\n  def test_is_allergic_to_eggs\n    skip\n    allergies = Allergies.new(1)\n    assert allergies.allergic_to?('eggs')\n  end\n\n  def test_allergic_to_eggs_in_addition_to_other_stuff\n    skip\n    allergies = Allergies.new(5)\n    assert allergies.allergic_to?('eggs')\n    assert allergies.allergic_to?('shellfish')\n    refute allergies.allergic_to?('strawberries')\n  end\n\n  def test_no_allergies_at_all\n    skip\n    allergies = Allergies.new(0)\n    assert_equal [], allergies.list\n  end\n\n  def test_allergic_to_just_eggs\n    skip\n    allergies = Allergies.new(1)\n    assert_equal ['eggs'], allergies.list\n  end\n\n  def test_allergic_to_just_peanuts\n    skip\n    allergies = Allergies.new(2)\n    assert_equal ['peanuts'], allergies.list\n  end\n\n  def test_allergic_to_eggs_and_peanuts\n    skip\n    allergies = Allergies.new(3)\n    assert_equal %w(eggs peanuts), allergies.list\n  end\n\n  def test_allergic_to_lots_of_stuff\n    skip\n    allergies = Allergies.new(248)\n    expected = %w(strawberries tomatoes chocolate pollen cats)\n    assert_equal expected, allergies.list\n  end\n\n  def test_allergic_to_everything\n    skip\n    allergies = Allergies.new(255)\n    # rubocop:disable Metrics/LineLength\n    expected = %w(eggs peanuts shellfish strawberries tomatoes chocolate pollen cats)\n    assert_equal expected, allergies.list\n  end\n\n  def test_ignore_non_allergen_score_parts\n    skip\n    allergies = Allergies.new(509)\n    expected = %w(eggs shellfish strawberries tomatoes chocolate pollen cats)\n    assert_equal expected, allergies.list\n  end\nend\n",
        "README.md": "# Allergies\n\nWrite a program that, given a person's allergy score, can tell them whether or not they're allergic to a given item, and their full list of allergies.\n\nAn allergy test produces a single numeric score which contains the\ninformation about all the allergies the person has (that they were\ntested for).\n\nThe list of items (and their value) that were tested are:\n\n* eggs (1)\n* peanuts (2)\n* shellfish (4)\n* strawberries (8)\n* tomatoes (16)\n* chocolate (32)\n* pollen (64)\n* cats (128)\n\nSo if Tom is allergic to peanuts and chocolate, he gets a score of 34.\n\nNow, given just that score of 34, your program should be able to say:\n\n- Whether Tom is allergic to any one of those allergens listed above.\n- All the allergens Tom is allergic to.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nJumpstart Lab Warm-up [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/kindergarten-garden",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "kindergarten-garden",
      "name": "Kindergarten Garden",
      "files": {
        "kindergarten_garden_test.rb": "require 'minitest/autorun'\nrequire_relative 'garden'\n\nclass GardenTest < Minitest::Test\n  def test_alices_garden\n    garden = Garden.new(\"RC\\nGG\")\n    assert_equal [:radishes, :clover, :grass, :grass], garden.alice\n  end\n\n  def test_different_garden_for_alice\n    skip\n    garden = Garden.new(\"VC\\nRC\")\n    assert_equal [:violets, :clover, :radishes, :clover], garden.alice\n  end\n\n  def test_bobs_garden\n    skip\n    garden = Garden.new(\"VVCG\\nVVRC\")\n    assert_equal [:clover, :grass, :radishes, :clover], garden.bob\n  end\n\n  def test_bob_and_charlies_gardens\n    skip\n    garden = Garden.new(\"VVCCGG\\nVVCCGG\")\n    assert_equal [:clover, :clover, :clover, :clover], garden.bob\n    assert_equal [:grass, :grass, :grass, :grass], garden.charlie\n  end\nend\n\nclass TestFullGarden < Minitest::Test\n  def setup\n    skip\n    diagram = \"VRCGVVRVCGGCCGVRGCVCGCGV\\nVRCCCGCRRGVCGCRVVCVGCGCV\"\n    @garden = Garden.new(diagram)\n  end\n\n  attr_reader :garden\n\n  def test_alice\n    skip\n    assert_equal [:violets, :radishes, :violets, :radishes], garden.alice\n  end\n\n  def test_bob\n    skip\n    assert_equal [:clover, :grass, :clover, :clover], garden.bob\n  end\n\n  def test_charlie\n    skip\n    assert_equal [:violets, :violets, :clover, :grass], garden.charlie\n  end\n\n  def test_david\n    skip\n    assert_equal [:radishes, :violets, :clover, :radishes], garden.david\n  end\n\n  def test_eve\n    skip\n    assert_equal [:clover, :grass, :radishes, :grass], garden.eve\n  end\n\n  def test_fred\n    skip\n    assert_equal [:grass, :clover, :violets, :clover], garden.fred\n  end\n\n  def test_ginny\n    skip\n    assert_equal [:clover, :grass, :grass, :clover], garden.ginny\n  end\n\n  def test_harriet\n    skip\n    assert_equal [:violets, :radishes, :radishes, :violets], garden.harriet\n  end\n\n  def test_ileana\n    skip\n    assert_equal [:grass, :clover, :violets, :clover], garden.ileana\n  end\n\n  def test_joseph\n    skip\n    assert_equal [:violets, :clover, :violets, :grass], garden.joseph\n  end\n\n  def test_kincaid\n    skip\n    assert_equal [:grass, :clover, :clover, :grass], garden.kincaid\n  end\n\n  def test_larry\n    skip\n    assert_equal [:grass, :violets, :clover, :violets], garden.larry\n  end\nend\n\nclass DisorderedTest < Minitest::Test\n  def setup\n    skip\n    diagram = \"VCRRGVRG\\nRVGCCGCV\"\n    students = %w(Samantha Patricia Xander Roger)\n    @garden = Garden.new(diagram, students)\n  end\n\n  attr_reader :garden\n\n  def test_patricia\n    skip\n    assert_equal [:violets, :clover, :radishes, :violets], garden.patricia\n  end\n\n  def test_roger\n    skip\n    assert_equal [:radishes, :radishes, :grass, :clover], garden.roger\n  end\n\n  def test_samantha\n    skip\n    assert_equal [:grass, :violets, :clover, :grass], garden.samantha\n  end\n\n  def test_xander\n    skip\n    assert_equal [:radishes, :grass, :clover, :violets], garden.xander\n  end\nend\n\nclass TwoGardensDifferentStudents < Minitest::Test\n  def diagram\n    \"VCRRGVRG\\nRVGCCGCV\"\n  end\n\n  def garden_1\n    @garden_1 ||= Garden.new(diagram, %w(Alice Bob Charlie Dan))\n  end\n\n  def garden_2\n    @garden_2 ||= Garden.new(diagram, %w(Bob Charlie Dan Erin))\n  end\n\n  def test_bob_and_charlie_per_garden\n    skip\n    assert_equal [:radishes, :radishes, :grass, :clover], garden_1.bob\n    assert_equal [:violets, :clover, :radishes, :violets], garden_2.bob\n    assert_equal [:grass, :violets, :clover, :grass], garden_1.charlie\n    assert_equal [:radishes, :radishes, :grass, :clover], garden_2.charlie\n  end\nend\n",
        "README.md": "# Kindergarten Garden\n\nWrite a program that, given a diagram, can tell you which plants each child in the kindergarten class is responsible for.\n\nThe kindergarten class is learning about growing plants. The teachers\nthought it would be a good idea to give them actual seeds, plant them in\nactual dirt, and grow actual plants.\n\nThey've chosen to grow grass, clover, radishes, and violets.\n\nTo this end, they've put little styrofoam cups along the window sills,\nand planted one type of plant in each cup, choosing randomly from the\navailable types of seeds.\n\n```plain\n[window][window][window]\n........................ # each dot represents a styrofoam cup\n........................\n```\n\nThere are 12 children in the class:\n\n- Alice, Bob, Charlie, David,\n- Eve, Fred, Ginny, Harriet,\n- Ileana, Joseph, Kincaid, and Larry.\n\nEach child gets 4 cups, two on each row. The children are assigned to\ncups in alphabetical order.\n\nThe following diagram represents Alice's plants:\n\n```plain\n[window][window][window]\nVR......................\nRG......................\n```\n\nSo in the row nearest the window, she has a violet and a radish; in the\nrow behind that, she has a radish and some grass.\n\nYour program will be given the plants from left-to-right starting with\nthe row nearest the windows. From this, it should be able to determine\nwhich plants belong to which students.\n\nFor example, if it's told that the garden looks like so:\n\n```plain\n[window][window][window]\nVRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV\n```\n\nThen if asked for Alice's plants, it should provide:\n\n- Violets, radishes, violets, radishes\n\nWhile asking for Bob's plants would yield:\n\n- Clover, grass, clover, clover\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nRandom musings during airplane trip. [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/linked-list",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "linked-list",
      "name": "Linked List",
      "files": {
        "linked_list_test.rb": "require 'minitest/autorun'\nrequire_relative 'linked_list'\n\nclass DequeTest < Minitest::Test\n  def test_push_pop\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 20, deque.pop\n    assert_equal 10, deque.pop\n  end\n\n  def test_push_shift\n    skip\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 10, deque.shift\n    assert_equal 20, deque.shift\n  end\n\n  def test_unshift_shift\n    skip\n    deque = Deque.new\n    deque.unshift(10)\n    deque.unshift(20)\n    assert_equal 20, deque.shift\n    assert_equal 10, deque.shift\n  end\n\n  def test_unshift_pop\n    skip\n    deque = Deque.new\n    deque.unshift(10)\n    deque.unshift(20)\n    assert_equal 10, deque.pop\n    assert_equal 20, deque.pop\n  end\n\n  # rubocop:disable Metrics/AbcSize\n  def test_example # rubocop:disable Metrics/MethodLength\n    skip\n    deque = Deque.new\n    deque.push(10)\n    deque.push(20)\n    assert_equal 20, deque.pop\n    deque.push(30)\n    assert_equal 10, deque.shift\n    deque.unshift(40)\n    deque.push(50)\n    assert_equal 40, deque.shift\n    assert_equal 50, deque.pop\n    assert_equal 30, deque.shift\n  end\nend\n",
        "README.md": "# Linked List\n\nWrite a Singly-Linked List implementation that uses the Proxy pattern\n\nDeques have four fundamental operations (using Array terminology):\n\n* push (insert value at back)\n* unshift (insert value at front)\n* pop (remove value at back)\n* shift (remove value at front)\n\nThe difference between deque and Array performance is that a deque\nimplements all of these operations in constant time. Even clever\nimplemetations of Array will often have to copy the entire Array in\norder to unshift.\n\nUnder the hood we'll use an Element class with two fields, `next` and\n`prev`, that are both writable.\n\nTo make the API usable, you'll use a Deque class as a proxy for this\nlist. There two good ways to implement Deque: maintain separate\nreferences to the first and last Element, or maintain a reference to one\nof them and ensure that the list is circular.\n\nTo keep your implementation simple, the tests will not cover error\nconditions. Specifically: pop or shift will never be called on an empty\nDeque.\n\nIn languages that do not have good support for mutability (such as\nElixir or Erlang), you may choose to implement a functional Deque where\nshift and pop have amortized O(1) time. The simplest data structure for\nthis will have a pair of linked lists for the front and back, where\niteration order is front ++ reverse back.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by 'Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby', singly linked-lists. [view source](http://www.brpreiss.com/books/opus8/html/page96.html#SECTION004300000000000000000)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/pythagorean-triplet",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "pythagorean-triplet",
      "name": "Pythagorean Triplet",
      "files": {
        "pythagorean_triplet_test.rb": "require 'minitest/autorun'\nrequire_relative 'triplet'\n\nclass TripletTest < Minitest::Test\n  def test_sum\n    assert_equal 12, Triplet.new(3, 4, 5).sum\n  end\n\n  def test_product\n    skip\n    assert_equal 60, Triplet.new(3, 4, 5).product\n  end\n\n  def test_pythagorean\n    skip\n    assert Triplet.new(3, 4, 5).pythagorean?\n  end\n\n  def test_not_pythagorean\n    skip\n    assert !Triplet.new(5, 6, 7).pythagorean?\n  end\n\n  def test_triplets_upto_10\n    skip\n    triplets = Triplet.where(max_factor: 10)\n    products = triplets.map(&:product).sort\n    assert_equal [60, 480], products\n  end\n\n  def test_triplets_from_11_upto_20\n    skip\n    triplets = Triplet.where(min_factor: 11, max_factor: 20)\n    products = triplets.map(&:product).sort\n    assert_equal [3840], products\n  end\n\n  def test_triplets_where_sum_x\n    skip\n    triplets = Triplet.where(sum: 180, max_factor: 100)\n    products = triplets.map(&:product).sort\n    assert_equal [118_080, 168_480, 202_500], products\n  end\nend\n",
        "README.md": "# Pythagorean Triplet\n\nThere exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product a * b * c.\n\nA Pythagorean triplet is a set of three natural numbers, {a, b, c}, for\nwhich,\n\na**2 + b**2 = c**2\n\nFor example, 3**2 + 4**2 = 9 + 16 = 25 = 5**2.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nProblem 9 at Project Euler [view source](http://projecteuler.net/problem=9)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/robot-simulator",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "robot-simulator",
      "name": "Robot Simulator",
      "files": {
        "robot_simulator_test.rb": "require 'minitest/autorun'\nrequire_relative 'simulator'\n\nclass RobotTurningTest < Minitest::Test\n  attr_reader :robot\n\n  def setup\n    @robot = Robot.new\n  end\n\n  def test_robot_bearing\n    [:east, :west, :north, :south].each do |direction|\n      robot.orient(direction)\n      assert_equal direction, robot.bearing\n    end\n  end\n\n  def test_invalid_robot_bearing\n    skip\n    assert_raises ArgumentError do\n      robot.orient(:crood)\n    end\n  end\n\n  def test_turn_right_from_north\n    skip\n    robot.orient(:north)\n    robot.turn_right\n    assert_equal :east, robot.bearing\n  end\n\n  def test_turn_right_from_east\n    skip\n    robot.orient(:east)\n    robot.turn_right\n    assert_equal :south, robot.bearing\n  end\n\n  def test_turn_right_from_south\n    skip\n    robot.orient(:south)\n    robot.turn_right\n    assert_equal :west, robot.bearing\n  end\n\n  def test_turn_right_from_west\n    skip\n    robot.orient(:west)\n    robot.turn_right\n    assert_equal :north, robot.bearing\n  end\n\n  def test_turn_left_from_north\n    skip\n    robot.orient(:north)\n    robot.turn_left\n    assert_equal :west, robot.bearing\n  end\n\n  def test_turn_left_from_east\n    skip\n    robot.orient(:east)\n    robot.turn_left\n    assert_equal :north, robot.bearing\n  end\n\n  def test_turn_left_from_south\n    skip\n    robot.orient(:south)\n    robot.turn_left\n    assert_equal :east, robot.bearing\n  end\n\n  def test_turn_left_from_west\n    skip\n    robot.orient(:west)\n    robot.turn_left\n    assert_equal :south, robot.bearing\n  end\n\n  def test_robot_coordinates\n    skip\n    robot.at(3, 0)\n    assert_equal [3, 0], robot.coordinates\n  end\n\n  def test_other_robot_coordinates\n    skip\n    robot.at(-2, 5)\n    assert_equal [-2, 5], robot.coordinates\n  end\n\n  def test_advance_when_facing_north\n    skip\n    robot.at(0, 0)\n    robot.orient(:north)\n    robot.advance\n    assert_equal [0, 1], robot.coordinates\n  end\n\n  def test_advance_when_facing_east\n    skip\n    robot.at(0, 0)\n    robot.orient(:east)\n    robot.advance\n    assert_equal [1, 0], robot.coordinates\n  end\n\n  def test_advance_when_facing_south\n    skip\n    robot.at(0, 0)\n    robot.orient(:south)\n    robot.advance\n    assert_equal [0, -1], robot.coordinates\n  end\n\n  def test_advance_when_facing_west\n    skip\n    robot.at(0, 0)\n    robot.orient(:west)\n    robot.advance\n    assert_equal [-1, 0], robot.coordinates\n  end\nend\n\nclass RobotSimulatorTest < Minitest::Test\n  def simulator\n    @simulator ||= Simulator.new\n  end\n\n  def test_instructions_for_turning_left\n    skip\n    assert_equal [:turn_left], simulator.instructions('L')\n  end\n\n  def test_instructions_for_turning_right\n    skip\n    assert_equal [:turn_right], simulator.instructions('R')\n  end\n\n  def test_instructions_for_advancing\n    skip\n    assert_equal [:advance], simulator.instructions('A')\n  end\n\n  def test_series_of_instructions\n    skip\n    commands = [:turn_right, :advance, :advance, :turn_left]\n    assert_equal commands, simulator.instructions('RAAL')\n  end\n\n  def test_instruct_robot\n    skip\n    robot = Robot.new\n    simulator.place(robot, x: -2, y: 1, direction: :east)\n    simulator.evaluate(robot, 'RLAALAL')\n    assert_equal [0, 2], robot.coordinates\n    assert_equal :west, robot.bearing\n  end\n\n  # rubocop:disable Metrics/AbcSize\n  def test_instruct_many_robots # rubocop:disable Metrics/MethodLength\n    skip\n    robot1 = Robot.new\n    robot2 = Robot.new\n    robot3 = Robot.new\n    simulator.place(robot1, x: 0, y: 0, direction: :north)\n    simulator.place(robot2, x: 2, y: -7, direction: :east)\n    simulator.place(robot3, x: 8, y: 4, direction: :south)\n    simulator.evaluate(robot1, 'LAAARALA')\n    simulator.evaluate(robot2, 'RRAAAAALA')\n    simulator.evaluate(robot3, 'LAAARRRALLLL')\n\n    assert_equal [-4, 1], robot1.coordinates\n    assert_equal :west, robot1.bearing\n\n    assert_equal [-3, -8], robot2.coordinates\n    assert_equal :south, robot2.bearing\n\n    assert_equal [11, 5], robot3.coordinates\n    assert_equal :north, robot3.bearing\n  end\nend\n",
        "README.md": "# Robot Simulator\n\nWrite a robot simulator.\n\n## Step 1\n\nThe robot factory manufactures robots that have three possible\nmovements:\n\n- turn right\n- turn left\n- advance\n\nRobots are placed on a hypothetical infinite grid, facing a particular\ndirection (north, east, south, or west) at a set of {x,y} coordinates,\ne.g., {3,8}.\n\n## Step 2\n\nRobots can pivot left and right.\n\nThe robot factory manufactures robots that have three possible\nmovements:\n\n- turn right\n- turn left\n- advance\n\nThe factory's test facility needs a program to verify robot movements.\n\nThere are a number of different rooms of varying sizes, measured in\nRobot Units, the distance a robot moves when you instruct it to\n`advance`.\n\nThe floor of the room is a grid, each square of which measures 1 square\nRU (Robot Unit).\n\nThe rooms are always oriented so that each wall faces east, south, west,\nand north.\n\nThe test algorithm is to place a robot at a coordinate in the room,\nfacing in a particular direction.\n\nThe robot then receives a number of instructions, at which point the\ntesting facility verifies the robot's new position, and in which\ndirection it is pointing.\n\n## Step 3\n\nThe robot factory manufactures robots that have three possible\nmovements:\n\n- turn right\n- turn left\n- advance\n\nThe robot factory's test facility has a simulator which can take a\nstring of letters and feed this into a robot as instructions.\n\n- The letter-string \"RAALAL\" means:\n  - Turn right\n  - Advance twice\n  - Turn left\n  - Advance once\n  - Turn left yet again\n- Say a robot starts at {7, 3} facing north. Then running this stream\n  of instructions should leave it at {9, 4} facing west.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nInspired by an interview question at a famous company. [view source]()\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/twelve-days",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "twelve-days",
      "name": "Twelve Days",
      "files": {
        "twelve_days_test.rb": "require 'minitest/autorun'\nrequire_relative 'twelve_days'\n\nclass TwelveDaysTest < Minitest::Test\n  def song\n    @song ||= ::TwelveDaysSong.new\n  end\n\n  def teardown\n    @song = nil\n  end\n\n  # rubocop:disable Metrics/LineLength\n  def test_verse1\n    expected = \"On the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(1)\n  end\n\n  def test_verse2\n    skip\n    expected = \"On the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(2)\n  end\n\n  def test_verse3\n    skip\n    expected = \"On the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(3)\n  end\n\n  def test_verse4\n    skip\n    expected = \"On the fourth day of Christmas my true love gave to me, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(4)\n  end\n\n  def test_verse5\n    skip\n    expected = \"On the fifth day of Christmas my true love gave to me, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(5)\n  end\n\n  def test_verse6\n    skip\n    expected = \"On the sixth day of Christmas my true love gave to me, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(6)\n  end\n\n  def test_verse7\n    skip\n    expected = \"On the seventh day of Christmas my true love gave to me, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(7)\n  end\n\n  def test_verse8\n    skip\n    # rubocop:disable Metrics/LineLength\n    expected = \"On the eighth day of Christmas my true love gave to me, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(8)\n  end\n\n  def test_verse9\n    skip\n    expected = \"On the ninth day of Christmas my true love gave to me, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(9)\n  end\n\n  def test_verse10\n    skip\n    expected = \"On the tenth day of Christmas my true love gave to me, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(10)\n  end\n\n  def test_verse11\n    skip\n    expected = \"On the eleventh day of Christmas my true love gave to me, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(11)\n  end\n\n  def test_verse12\n    skip\n    expected = \"On the twelfth day of Christmas my true love gave to me, twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\"\n    assert_equal expected, song.verse(12)\n  end\n\n  def test_multiple_verses\n    skip\n    expected =\n      \"On the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\\n\\n\" \\\n      \"On the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\\n\\n\" \\\n      \"On the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\\n\\n\"\n    assert_equal expected, song.verses(1, 3)\n  end\n\n  def test_the_whole_song\n    skip\n    assert_equal song.verses(1, 12), song.sing\n  end\nend\n",
        "README.md": "# Twelve Days\n\nWrite a program that outputs the lyrics to 'The Twelve Days of Christmas'\n\n```ruby\nOn the first day of Christmas my true love gave to me, a Partridge in a Pear Tree.\n\nOn the second day of Christmas my true love gave to me, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the third day of Christmas my true love gave to me, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the fourth day of Christmas my true love gave to me, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the fifth day of Christmas my true love gave to me, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the sixth day of Christmas my true love gave to me, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the seventh day of Christmas my true love gave to me, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the eighth day of Christmas my true love gave to me, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the ninth day of Christmas my true love gave to me, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the tenth day of Christmas my true love gave to me, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the eleventh day of Christmas my true love gave to me, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n\nOn the twelfth day of Christmas my true love gave to me, twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.\n```\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/The_Twelve_Days_of_Christmas_(song))\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/circular-buffer",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "circular-buffer",
      "name": "Circular Buffer",
      "files": {
        "circular_buffer_test.rb": "require 'minitest/autorun'\nrequire_relative 'circular_buffer'\n\nclass CircularBufferTest < Minitest::Test\n  def test_read_empty_buffer_throws_buffer_empty_exception\n    buffer = CircularBuffer.new(1)\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n\n  def test_write_and_read_back_one_item\n    skip\n    buffer = CircularBuffer.new(1)\n    buffer.write '1'\n    assert_equal '1', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n\n  def test_write_and_read_back_multiple_items\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    assert_equal '1', buffer.read\n    assert_equal '2', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n\n  # rubocop:disable Metrics/AbcSize\n  def test_clearing_buffer\n    skip\n    buffer = CircularBuffer.new(3)\n    (1..3).each { |i| buffer.write String(i) }\n    buffer.clear\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n    buffer.write '1'\n    buffer.write '2'\n    assert_equal '1', buffer.read\n    buffer.write '3'\n    assert_equal '2', buffer.read\n  end\n\n  def test_alternate_write_and_read\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    assert_equal '1', buffer.read\n    buffer.write '2'\n    assert_equal '2', buffer.read\n  end\n\n  def test_reads_back_oldest_item\n    skip\n    buffer = CircularBuffer.new(3)\n    buffer.write '1'\n    buffer.write '2'\n    buffer.read\n    buffer.write '3'\n    assert_equal '2', buffer.read\n    assert_equal '3', buffer.read\n  end\n\n  def test_writes_of_nil_should_not_occupy_buffer\n    skip\n    buffer = CircularBuffer.new(5)\n    buffer.write nil\n    (1..3).each { |i| buffer.write String(i) }\n    assert_equal '1', buffer.read\n  end\n\n  def test_writing_to_a_full_buffer_throws_an_exception\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    assert_raises(CircularBuffer::BufferFullException) { buffer.write 'A' }\n  end\n\n  def test_overwriting_oldest_item_in_a_full_buffer\n    skip\n    buffer = CircularBuffer.new(2)\n    buffer.write '1'\n    buffer.write '2'\n    buffer.write! 'A'\n    assert_equal '2', buffer.read\n    assert_equal 'A', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n\n  # rubocop:disable Metrics/MethodLength\n  def test_alternate_read_and_write_into_buffer_overflow\n    skip\n    buffer = CircularBuffer.new(5)\n    (1..3).each { |i| buffer.write String(i) }\n    buffer.read\n    buffer.read\n    buffer.write '4'\n    buffer.read\n    (5..8).each { |i| buffer.write String(i) }\n    buffer.write! 'A'\n    buffer.write! 'B'\n    (6..8).each do |i|\n      assert_equal String(i), buffer.read\n    end\n    assert_equal 'A', buffer.read\n    assert_equal 'B', buffer.read\n    assert_raises(CircularBuffer::BufferEmptyException) { buffer.read }\n  end\n  # rubocop:enable Metrics/MethodLength\nend\n",
        "README.md": "# Circular Buffer\n\nA data structure that uses a single, fixed-size buffer as if it were connected end-to-end.\n\nA circular buffer, cyclic buffer or ring buffer is a data structure that\nuses a single, fixed-size buffer as if it were connected end-to-end.\n\nA circular buffer first starts empty and of some predefined length. For\nexample, this is a 7-element buffer:\n\n    [ ][ ][ ][ ][ ][ ][ ]\n\nAssume that a 1 is written into the middle of the buffer (exact starting\nlocation does not matter in a circular buffer):\n\n    [ ][ ][ ][1][ ][ ][ ]\n\nThen assume that two more elements are added â€” 2 & 3 â€” which get\nappended after the 1:\n\n    [ ][ ][ ][1][2][3][ ]\n\nIf two elements are then removed from the buffer, the oldest values\ninside the buffer are removed. The two elements removed, in this case,\nare 1 & 2, leaving the buffer with just a 3:\n\n    [ ][ ][ ][ ][ ][3][ ]\n\nIf the buffer has 7 elements then it is completely full:\n\n    [6][7][8][9][3][4][5]\n\nWhen the buffer is full an error will be raised, alerting the client\nthat further writes are blocked until a slot becomes free.\n\nThe client can opt to overwrite the oldest data with a forced write. In\nthis case, two more elements â€” A & B â€” are added and they overwrite the\n3 & 4:\n\n    [6][7][8][9][A][B][5]\n\nFinally, if two elements are now removed then what would be returned is\nnot 3 & 4 but 5 & 6 because A & B overwrote the 3 & the 4 yielding the\nbuffer with:\n\n    [ ][7][8][9][A][B][ ]\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Circular_buffer)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/largest-series-product",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "largest-series-product",
      "name": "Largest Series Product",
      "files": {
        "largest_series_product_test.rb": "require 'minitest/autorun'\nrequire_relative 'series'\n\n# Rubocop directives\n# rubocop:disable Lint/ParenthesesAsGroupedExpression\n#\nclass Seriestest < Minitest::Test\n  def test_digits\n    assert_equal (0..9).to_a, Series.new('0123456789').digits\n  end\n\n  def test_same_digits_reversed\n    skip\n    assert_equal (0..9).to_a.reverse, Series.new('9876543210').digits\n  end\n\n  def test_fewer_digits\n    skip\n    assert_equal (4..8).to_a.reverse, Series.new('87654').digits\n  end\n\n  def test_some_other_digits\n    skip\n    assert_equal [9, 3, 6, 9, 2, 3, 4, 6, 8], Series.new('936923468').digits\n  end\n\n  def test_slices_of_zero\n    skip\n    assert_equal [], Series.new('').digits\n  end\n\n  def test_slices_of_2\n    skip\n    series = Series.new('01234')\n    expected = [[0, 1], [1, 2], [2, 3], [3, 4]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_other_slices_of_2\n    skip\n    series = Series.new('98273463')\n    expected = [[9, 8], [8, 2], [2, 7], [7, 3], [3, 4], [4, 6], [6, 3]]\n    assert_equal expected, series.slices(2)\n  end\n\n  def test_slices_of_3\n    skip\n    series = Series.new('01234')\n    expected = [[0, 1, 2], [1, 2, 3], [2, 3, 4]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_other_slices_of_3\n    skip\n    series = Series.new('982347')\n    expected = [[9, 8, 2], [8, 2, 3], [2, 3, 4], [3, 4, 7]]\n    assert_equal expected, series.slices(3)\n  end\n\n  def test_largest_product_of_2\n    skip\n    series = Series.new('0123456789')\n    assert_equal 72, series.largest_product(2)\n  end\n\n  def test_largest_product_of_a_tiny_number\n    skip\n    series = Series.new('12')\n    assert_equal 2, series.largest_product(2)\n  end\n\n  def test_another_tiny_number\n    skip\n    series = Series.new('19')\n    assert_equal 9, series.largest_product(2)\n  end\n\n  def test_largest_product_of_2_shuffled\n    skip\n    series = Series.new('576802143')\n    assert_equal 48, series.largest_product(2)\n  end\n\n  def test_largest_product_of_3\n    skip\n    series = Series.new('0123456789')\n    assert_equal 504, series.largest_product(3)\n  end\n\n  def test_largest_product_of_3_shuffled\n    skip\n    series = Series.new('1027839564')\n    assert_equal 270, series.largest_product(3)\n  end\n\n  def test_largest_product_of_5\n    skip\n    series = Series.new('0123456789')\n    assert_equal 15_120, series.largest_product(5)\n  end\n\n  def test_some_big_number\n    skip\n    s = '73167176531330624919225119674426574742355349194934'\n    series = Series.new(s)\n    assert_equal 23_520, series.largest_product(6)\n  end\n\n  def test_some_other_big_number\n    skip\n    s = '52677741234314237566414902593461595376319419139427'\n    series = Series.new(s)\n    assert_equal 28_350, series.largest_product(6)\n  end\n\n  def test_identity\n    skip\n    series = Series.new('')\n    assert_equal 1, series.largest_product(0)\n  end\n\n  def test_slices_bigger_than_number\n    skip\n    series = Series.new('123')\n    assert_raises ArgumentError do\n      series.largest_product(4)\n    end\n  end\nend\n",
        "README.md": "# Largest Series Product\n\nWrite a program that, when given a string of digits, can calculate the largest product for a series of consecutive digits of length n.\n\nFor example, for the input `'0123456789'`, the largest product for a\nseries of 3 digits is 504 (7 * 8 * 9), and the largest product for a\nseries of 5 digits is 15120 (5 * 6 * 7 * 8 * 9).\n\nFor the input `'73167176531330624919225119674426574742355349194934'`,\nthe largest product for a series of 6 digits is 23520.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nA variation on Problem 8 at Project Euler [view source](http://projecteuler.net/problem=8)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/binary-search",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "binary-search",
      "name": "Binary Search",
      "files": {
        "binary_search_test.rb": "require 'minitest/autorun'\nrequire_relative 'binary'\n\nclass BinarySearchTest < Minitest::Test\n  def test_it_has_list_data\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal [1, 3, 4, 6, 8, 9, 11], binary.list\n  end\n\n  def test_it_raises_error_for_unsorted_list\n    skip\n    assert_raises ArgumentError do\n      BinarySearch.new([2, 1, 4, 3, 6])\n    end\n  end\n\n  def test_it_raises_error_for_data_not_in_list\n    skip\n    assert_raises RuntimeError do\n      BinarySearch.new([1, 3, 6]).search_for(2)\n    end\n  end\n\n  def test_it_finds_position_of_middle_item\n    skip\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal 3, binary.middle\n  end\n\n  def test_it_finds_position_of_search_data\n    skip\n    binary = BinarySearch.new([1, 3, 4, 6, 8, 9, 11])\n    assert_equal 5, binary.search_for(9)\n  end\n\n  def test_it_finds_position_in_a_larger_list\n    skip\n    binary = BinarySearch.new([1, 3, 5, 8, 13, 21, 34, 55, 89, 144])\n    assert_equal 1, binary.search_for(3)\n    assert_equal 7, binary.search_for(55)\n  end\n\n  def test_it_finds_correct_position_in_a_list_with_an_even_number_of_elements\n    skip\n    binary = BinarySearch.new([1, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377])\n    assert_equal 5, binary.search_for(21)\n    assert_equal 6, binary.search_for(34)\n  end\nend\n",
        "README.md": "# Binary Search\n\nWrite a program that implements a binary search algorithm.\n\nSearching a sorted collection is a common task. A dictionary is a sorted\nlist of word definitions. Given a word, one can find its definition. A\ntelephone book is a sorted list of people's names, addresses, and\ntelephone numbers. Knowing someone's name allows one to quickly find\ntheir telephone number and address.\n\nIf the list to be searched contains more than a few items (a dozen, say)\na binary search will require far fewer comparisons than a linear search,\nbut it imposes the requirement that the list be sorted.\n\nIn computer science, a binary search or half-interval search algorithm\nfinds the position of a specified input value (the search \"key\") within\nan array sorted by key value.\n\nIn each step, the algorithm compares the search key value with the key\nvalue of the middle element of the array.\n\nIf the keys match, then a matching element has been found and its index,\nor position, is returned.\n\nOtherwise, if the search key is less than the middle element's key, then\nthe algorithm repeats its action on the sub-array to the left of the\nmiddle element or, if the search key is greater, on the sub-array to the\nright.\n\nIf the remaining array to be searched is empty, then the key cannot be\nfound in the array and a special \"not found\" indication is returned.\n\nA binary search halves the number of items to check with each iteration,\nso locating an item (or determining its absence) takes logarithmic time.\nA binary search is a dichotomic divide and conquer search algorithm.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nWikipedia [view source](http://en.wikipedia.org/wiki/Binary_search_algorithm)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/pascals-triangle",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "pascals-triangle",
      "name": "Pascals Triangle",
      "files": {
        "pascals_triangle_test.rb": "require 'minitest/autorun'\nrequire_relative 'triangle'\n\nclass TriangleTest < Minitest::Test\n  def test_one_row\n    triangle = Triangle.new(1)\n    assert_equal [[1]], triangle.rows\n  end\n\n  def test_two_rows\n    skip\n    triangle = Triangle.new(2)\n    assert_equal [[1], [1, 1]], triangle.rows\n  end\n\n  def test_three_rows\n    skip\n    triangle = Triangle.new(3)\n    assert_equal [[1], [1, 1], [1, 2, 1]], triangle.rows\n  end\n\n  def test_fourth_row\n    skip\n    triangle = Triangle.new(4)\n    assert_equal [1, 3, 3, 1], triangle.rows.last\n  end\n\n  def test_fifth_row\n    skip\n    triangle = Triangle.new(5)\n    assert_equal [1, 4, 6, 4, 1], triangle.rows.last\n  end\n\n  def test_twentieth_row\n    skip\n    triangle = Triangle.new(20)\n    expected = [\n      1, 19, 171, 969, 3876, 11_628, 27_132, 50_388, 75_582, 92_378, 92_378,\n      75_582, 50_388, 27_132, 11_628, 3876, 969, 171, 19, 1\n    ]\n    assert_equal expected, triangle.rows.last\n  end\nend\n",
        "README.md": "# Pascals Triangle\n\nWrite a program that computes Pascal's triangle up to a given number of rows.\n\nIn Pascal's Triangle each number is computed by adding the numbers to\nthe right and left of the current position in the previous row.\n\n```plain\n    1\n   1 1\n  1 2 1\n 1 3 3 1\n1 4 6 4 1\n# ... etc\n```\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nPascal's Triangle at Wolfram Math World [view source](http://mathworld.wolfram.com/PascalsTriangle.html)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/custom-set",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "custom-set",
      "name": "Custom Set",
      "files": {
        "custom_set_test.rb": "require 'minitest/autorun'\nrequire_relative 'custom_set'\n\nclass CustomSetTest < Minitest::Test\n  def test_equal\n    assert_equal CustomSet.new([1, 3]), CustomSet.new([3, 1])\n  end\n\n  def test_no_duplicates\n    assert_equal CustomSet.new([1, 1]), CustomSet.new([1])\n  end\n\n  def test_delete\n    skip\n    assert_equal CustomSet.new([1, 3]), CustomSet.new([3, 2, 1]).delete(2)\n    assert_equal CustomSet.new([1, 2, 3]), CustomSet.new([3, 2, 1]).delete(4)\n    assert_equal CustomSet.new([1, 2, 3]), CustomSet.new([3, 2, 1]).delete(2.0)\n    assert_equal CustomSet.new([1, 3]), CustomSet.new([3, 2.0, 1]).delete(2.0)\n  end\n\n  def test_difference\n    skip\n    assert_equal CustomSet.new([1, 3]),\n                 CustomSet.new([1, 2, 3]).difference(CustomSet.new([2, 4]))\n\n    assert_equal CustomSet.new([1, 2.0, 3]),\n                 CustomSet.new([1, 2.0, 3]).difference(CustomSet.new([2, 4]))\n  end\n\n  def test_disjoint?\n    skip\n    assert CustomSet.new([1, 2]).disjoint?(CustomSet.new([3, 4]))\n    refute CustomSet.new([1, 2]).disjoint?(CustomSet.new([2, 3]))\n    assert CustomSet.new([1.0, 2.0]).disjoint?(CustomSet.new([2, 3]))\n    assert CustomSet.new.disjoint?(CustomSet.new)\n  end\n\n  def test_empty\n    skip\n    assert_equal CustomSet.new, CustomSet.new([1, 2]).empty\n    assert_equal CustomSet.new, CustomSet.new.empty\n  end\n\n  # rubocop:disable Metrics/LineLength\n  def test_intersection\n    skip\n    assert_equal CustomSet.new([:a, :c]),\n                 CustomSet.new([:a, :b, :c]).intersection(CustomSet.new([:a, :c, :d]))\n\n    assert_equal CustomSet.new([3]),\n                 CustomSet.new([1, 2, 3]).intersection(CustomSet.new([1.0, 2.0, 3]))\n  end\n\n  def test_member?\n    skip\n    assert CustomSet.new([1, 2, 3]).member?(2)\n    assert CustomSet.new(1..3).member?(2)\n    refute CustomSet.new(1..3).member?(2.0)\n    refute CustomSet.new(1..3).member?(4)\n  end\n\n  def test_put\n    skip\n    assert_equal CustomSet.new([1, 2, 3, 4]),\n                 CustomSet.new([1, 2, 4]).put(3)\n\n    assert_equal CustomSet.new([1, 2, 3]),\n                 CustomSet.new([1, 2, 3]).put(3)\n\n    assert_equal CustomSet.new([1, 2, 3, 3.0]),\n                 CustomSet.new([1, 2, 3]).put(3.0)\n  end\n\n  def test_size\n    skip\n    assert_equal 0, CustomSet.new.size\n    assert_equal 3, CustomSet.new([1, 2, 3]).size\n    assert_equal 3, CustomSet.new([1, 2, 3, 2]).size\n  end\n\n  def test_subset?\n    skip\n    assert CustomSet.new([1, 2, 3]).subset?(CustomSet.new([1, 2, 3]))\n    assert CustomSet.new([4, 1, 2, 3]).subset?(CustomSet.new([1, 2, 3]))\n    refute CustomSet.new([4, 1, 3]).subset?(CustomSet.new([1, 2, 3]))\n    refute CustomSet.new([1, 2, 3, 4]).subset?(CustomSet.new([1, 2, 3.0]))\n    assert CustomSet.new([4, 1, 3]).subset?(CustomSet.new)\n    assert CustomSet.new.subset?(CustomSet.new)\n  end\n\n  def test_to_a\n    skip\n    assert_equal [], CustomSet.new.to_a.sort\n    assert_equal [1, 2, 3], CustomSet.new([3, 1, 2]).to_a.sort\n    assert_equal [1, 2, 3], CustomSet.new([3, 1, 2, 1]).to_a.sort\n  end\n\n  def test_union # rubocop:disable Metrics/MethodLength\n    skip\n    assert_equal CustomSet.new([3, 2, 1]),\n                 CustomSet.new([1, 3]).union(CustomSet.new([2]))\n    assert_equal CustomSet.new([3.0, 3, 2, 1]),\n                 CustomSet.new([1, 3]).union(CustomSet.new([2, 3.0]))\n    assert_equal CustomSet.new([3, 1]),\n                 CustomSet.new([1, 3]).union(CustomSet.new)\n    assert_equal CustomSet.new([2]),\n                 CustomSet.new([2]).union(CustomSet.new)\n    assert_equal CustomSet.new([]),\n                 CustomSet.new.union(CustomSet.new)\n  end\nend\n",
        "README.md": "# Custom Set\n\nCreate a custom set type.\n\nSometimes it is necessary to define a custom data structure of some\ntype, like a set. In this exercise you will define your own set. How it\nworks internally doesn't matter, as long as it behaves like a set of\nunique elements.\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/minesweeper",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "minesweeper",
      "name": "Minesweeper",
      "files": {
        "minesweeper_test.rb": "require 'minitest/autorun'\nrequire_relative 'minesweeper.rb'\n\nclass MinesweeperTest < Minitest::Test\n  def test_transform1\n    inp = ['+------+', '| *  * |', '|  *   |', '|    * |', '|   * *|',\n           '| *  * |', '|      |', '+------+']\n    out = ['+------+', '|1*22*1|', '|12*322|', '| 123*2|', '|112*4*|',\n           '|1*22*2|', '|111111|', '+------+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform2\n    skip\n    inp = ['+-----+', '| * * |', '|     |', '|   * |', '|  * *|',\n           '| * * |', '+-----+']\n    out = ['+-----+', '|1*2*1|', '|11322|', '| 12*2|', '|12*4*|',\n           '|1*3*2|', '+-----+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform3\n    skip\n    inp = ['+-----+', '| * * |', '+-----+']\n    out = ['+-----+', '|1*2*1|', '+-----+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform4\n    skip\n    inp = ['+-+', '|*|', '| |', '|*|', '| |', '| |', '+-+']\n    out = ['+-+', '|*|', '|2|', '|*|', '|1|', '| |', '+-+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform5\n    skip\n    inp = ['+-+', '|*|', '+-+']\n    out = ['+-+', '|*|', '+-+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform6\n    skip\n    inp = ['+--+', '|**|', '|**|', '+--+']\n    out = ['+--+', '|**|', '|**|', '+--+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform7\n    skip\n    inp = ['+--+', '|**|', '|**|', '+--+']\n    out = ['+--+', '|**|', '|**|', '+--+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform8\n    skip\n    inp = ['+---+', '|***|', '|* *|', '|***|', '+---+']\n    out = ['+---+', '|***|', '|*8*|', '|***|', '+---+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_transform9\n    skip\n    inp = ['+-----+', '|     |', '|   * |', '|     |', '|     |',\n           '| *   |', '+-----+']\n    out = ['+-----+', '|  111|', '|  1*1|', '|  111|', '|111  |',\n           '|1*1  |', '+-----+']\n    assert_equal out, Board.transform(inp)\n  end\n\n  def test_different_len\n    skip\n    inp = ['+-+', '| |', '|*  |', '|  |', '+-+']\n    assert_raises(ValueError) do\n      Board.transform(inp)\n    end\n  end\n\n  def test_faulty_border\n    skip\n    inp = ['+-----+', '*   * |', '+-- --+']\n    assert_raises(ValueError) do\n      Board.transform(inp)\n    end\n  end\n\n  def test_invalid_char\n    skip\n    inp = ['+-----+', '|X  * |', '+-----+']\n    assert_raises(ValueError) do\n      Board.transform(inp)\n    end\n  end\nend\n",
        "README.md": "# Minesweeper\n\nWrite a program that adds the numbers to a minesweeper board\n\nMinesweeper is a popular game where the user has to find the mines using\nnumeric hints that indicate how many mines are directly adjacent\n(horizontally, vertically, diagonally) to a square.\n\nIn this exercise you have to create some code that counts the number of\nmines adjacent to a square and transforms boards like this (where `*`\nindicates a mine):\n\n    +-----+\n    | * * |\n    |  *  |\n    |  *  |\n    |     |\n    +-----+\n\ninto this:\n\n    +-----+\n    |1*3*1|\n    |13*31|\n    | 2*2 |\n    | 111 |\n    +-----+\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/scale-generator",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "scale-generator",
      "name": "Scale Generator",
      "files": {
        "scale_generator_test.rb": "require 'minitest/autorun'\nrequire_relative 'scale'\n\nclass ScaleGeneratorTest < Minitest::Test\n  def test_naming_scale\n    chromatic = Scale.new('c', :chromatic)\n    expected = 'C chromatic'\n    actual = chromatic.name\n    assert_equal expected, actual\n  end\n\n  def test_chromatic_scale\n    skip\n    chromatic = Scale.new('C', :chromatic)\n    expected = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    actual = chromatic.pitches\n    assert_equal expected, actual\n  end\n\n  def test_another_chromatic_scale\n    skip\n    chromatic = Scale.new('F', :chromatic)\n    expected = %w(F Gb G Ab A Bb B C Db D Eb E)\n    actual = chromatic.pitches\n    assert_equal expected, actual\n  end\n\n  def test_major_scale\n    skip\n    major = Scale.new('C', :major, 'MMmMMMm')\n    expected = %w(C D E F G A B)\n    actual = major.pitches\n    assert_equal expected, actual\n  end\n\n  def test_another_major_scale\n    skip\n    major = Scale.new('G', :major, 'MMmMMMm')\n    expected = ['G', 'A', 'B', 'C', 'D', 'E', 'F#']\n    actual = major.pitches\n    assert_equal expected, actual\n  end\n\n  def test_minor_scale\n    skip\n    minor = Scale.new('f#', :minor, 'MmMMmMM')\n    expected = ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E']\n    actual = minor.pitches\n    assert_equal expected, actual\n  end\n\n  def test_another_minor_scale\n    skip\n    minor = Scale.new('bb', :minor, 'MmMMmMM')\n    expected = %w(Bb C Db Eb F Gb Ab)\n    actual = minor.pitches\n    assert_equal expected, actual\n  end\n\n  def test_dorian_mode\n    skip\n    dorian = Scale.new('d', :dorian, 'MmMMMmM')\n    expected = %w(D E F G A B C)\n    actual = dorian.pitches\n    assert_equal expected, actual\n  end\n\n  def test_mixolydian_mode\n    skip\n    mixolydian = Scale.new('Eb', :mixolydian, 'MMmMMmM')\n    expected = %w(Eb F G Ab Bb C Db)\n    actual = mixolydian.pitches\n    assert_equal expected, actual\n  end\n\n  def test_lydian_mode\n    skip\n    lydian = Scale.new('a', :lydian, 'MMMmMMm')\n    expected = ['A', 'B', 'C#', 'D#', 'E', 'F#', 'G#']\n    actual = lydian.pitches\n    assert_equal expected, actual\n  end\n\n  def test_phrygian_mode\n    skip\n    phrygian = Scale.new('e', :phrygian, 'mMMMmMM')\n    expected = %w(E F G A B C D)\n    actual = phrygian.pitches\n    assert_equal expected, actual\n  end\n\n  def test_locrian_mode\n    skip\n    locrian = Scale.new('g', :locrian, 'mMMmMMM')\n    expected = %w(G Ab Bb C Db Eb F)\n    actual = locrian.pitches\n    assert_equal expected, actual\n  end\n\n  def test_harmonic_minor\n    skip\n    harmonic_minor = Scale.new('d', 'harmonic_minor', 'MmMMmAm')\n    expected = %w(D E F G A Bb Db)\n    actual = harmonic_minor.pitches\n    assert_equal expected, actual\n  end\n\n  def test_octatonic\n    skip\n    octatonic = Scale.new('C', :octatonic, 'MmMmMmMm')\n    expected = ['C', 'D', 'D#', 'F', 'F#', 'G#', 'A', 'B']\n    actual = octatonic.pitches\n    assert_equal expected, actual\n  end\n\n  def test_hexatonic\n    skip\n    hexatonic = Scale.new('Db', :hexatonic, 'MMMMMM')\n    expected = %w(Db Eb F G A B)\n    actual = hexatonic.pitches\n    assert_equal expected, actual\n  end\n\n  def test_pentatonic\n    skip\n    pentatonic = Scale.new('A', :pentatonic, 'MMAMA')\n    expected = ['A', 'B', 'C#', 'E', 'F#']\n    actual = pentatonic.pitches\n    assert_equal expected, actual\n  end\n\n  def test_enigmatic\n    skip\n    enigmatic = Scale.new('G', :enigma, 'mAMMMmM')\n    expected = ['G', 'G#', 'B', 'C#', 'D#', 'F', 'F#']\n    actual = enigmatic.pitches\n    assert_equal expected, actual\n  end\nend\n",
        "README.md": "# Scale Generator\n\nWrite a program that can generate musical scales, given a starting note and a set of intervals. \n\nWrite a program that can generate musical scales. It should accept\na tonic, or starting note, and a set of intervals. It should be able to\noutput the notes in the given scale, starting with the tonic and\nfollowing the specified interval pattern.\n\nScales in Western music are based on the chromatic (12-note) scale.This\nscale can be expressed as the following group of pitches:\n\nA, A#, B, C, C#, D, D#, E, F, F#, G, G#\n\nA given sharp note (indicated by a #), can also be expressed as the flat\nof the note above it (indicated by a b), so the chromatic scale can also be\nwritten like this:\n\nA, Bb, B, C, Db, D, Eb, E, F, Gb, G, Ab\n\nThe major and minor scale and modes are subsets of this twelve-pitch\ncollection. They have seven pitches, and are called diatonic scales.\nThe collection of notes in these scales is written with either sharps or\nflats, depending on the tonic. Here is a list of which are which:\n\nNo Accidentals:\nC major\nA minor\n\nUse Sharps:\nG, D, A, E, B, F# major\ne, b, f#, c#, g#, d# minor\n\nUse Flats:\nF, Bb, Eb, Ab, Db, Gb major\nd, g, c, f, bb, eb minor\n\n\nThe diatonic scales, and all other scales that derive from the\nchromatic scale, are built upon intervals. An interval is the space\nbetween two pitches.\n\nThe simplest interval is between two adjacent notes, and is called a\n\"half step\", or \"minor second\" (sometimes written as a lower-case \"m\").\nThe interval between two notes that have an interceding note is called\na \"whole step\" or \"major second\" (written as an upper-case \"M\"). The\ndiatonic scales are built using only these two intervals between\nadjacent notes.\n\nNon-diatonic scales can contain the same letter twice, and can contain other intervals.\nSometimes they may be smaller than usual (diminished, written \"D\"), or larger\n(augmented, written \"A\").  Intervals larger than an augmented second have other names.\n\nHere is a table of pitches with the names of their interval distance from the tonic (A).\n\n    A    |    A#   |    B    |    C    |    C#   |    D    |    D#   |\n----------------------------------------------------------------------\n  Unison | Min 2nd | Maj 2nd | Min 3rd | Maj 3rd | Per 4th | Tritone |\n         |         | Dim 3rd | Aug 2nd | Dim 4th |         | Aug 4th |\n                                                           | Dim 5th |\n\n\n    E    |    F    |    F#   |    G    |    G#   |    A   |\n-----------------------------------------------------------\n Per 5th | Min 6th | Maj 6th | Min 7th | Maj 7th | Octave |\n Dim 5th | Aug 5th | Dim 7th | Aug 6th | Dim 8ve |        |\n\n\n\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\n [view source]()\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/protein-translation",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "protein-translation",
      "name": "Protein Translation",
      "files": {
        "protein_translation_test.rb": "require 'minitest/autorun'\nrequire_relative 'translation'\n\n# rubocop:disable Style/MethodName\nclass TranslationTest < Minitest::Test\n  def test_AUG_translates_to_methionine\n    assert_equal 'Methionine', Translation.of_codon('AUG')\n  end\n\n  def test_identifies_Phenylalanine_codons\n    skip\n    assert_equal 'Phenylalanine', Translation.of_codon('UUU')\n    assert_equal 'Phenylalanine', Translation.of_codon('UUC')\n  end\n\n  def test_identifies_Leucine_codons\n    skip\n    %w(UUA UUG).each do |codon|\n      assert_equal 'Leucine', Translation.of_codon(codon)\n    end\n  end\n\n  def test_identifies_Serine_codons\n    skip\n    %w(UCU UCC UCA UCG).each do |codon|\n      assert_equal 'Serine', Translation.of_codon(codon)\n    end\n  end\n\n  def test_identifies_Tyrosine_codons\n    skip\n    %w(UAU UAC).each do |codon|\n      assert_equal 'Tyrosine', Translation.of_codon(codon)\n    end\n  end\n\n  def test_identifies_Cystine_codons\n    skip\n    %w(UGU UGC).each do |codon|\n      assert_equal 'Cystine', Translation.of_codon(codon)\n    end\n  end\n\n  def test_identifies_Tryptophan_codons\n    skip\n    assert_equal 'Tryptophan', Translation.of_codon('UGG')\n  end\n\n  def test_identifies_stop_codons\n    skip\n    %w(UAA UAG UGA).each do |codon|\n      assert_equal 'STOP', Translation.of_codon(codon)\n    end\n  end\n\n  def test_translates_rna_strand_into_correct_protein\n    skip\n    strand = 'AUGUUUUGG'\n    expected = %w(Methionine Phenylalanine Tryptophan)\n    assert_equal expected, Translation.of_rna(strand)\n  end\n\n  def test_stops_translation_if_stop_codon_present\n    skip\n    strand = 'AUGUUUUAA'\n    expected = %w(Methionine Phenylalanine)\n    assert_equal expected, Translation.of_rna(strand)\n  end\n\n  def test_stops_translation_of_longer_strand\n    skip\n    strand = 'UGGUGUUAUUAAUGGUUU'\n    expected = %w(Tryptophan Cystine Tyrosine)\n    assert_equal expected, Translation.of_rna(strand)\n  end\n\n  def test_invalid_codons\n    skip\n    strand = 'CARROT'\n    assert_raises(InvalidCodonError) do\n      Translation.of_rna(strand)\n    end\n  end\nend\n",
        "README.md": "# Protein Translation\n\nWrite a program that will translate RNA sequences into proteins.\n\nLets write a program that will translate RNA sequences into proteins. [general ref](http://en.wikipedia.org/wiki/Translation_(biology)\n\nRNA can be broken into three nucleotide sequences called codons, and then translated to a polypeptide like so:\n \nRNA: `\"AUGUUUUCU\"` => translates to\n\nCodons: `\"AUG\", \"UUU\", \"UCU\"` \n=> which become a polypeptide with the following sequence =>\n\nProtein: `\"Methionine\", \"Phenylalanine\", \"Serine\"`\n \nThere are 64 codons which in turn correspond to 20 amino acids; however, all of the codon sequences and resulting amino acids are not important in this exercise.  If it works for one codon, the program should work for all of them. \nHowever, feel free to expand the list in the test suite to include them all.  \n\nThere are also four terminating codons (also known as 'STOP' codons); if any of these codons are encountered(by the ribosome), all tranlsation ends and the protein is terminated.\n\nAll subsequent codons after are ignored, like this:\n\nRNA: `\"AUGUUUUCUUAAAUG\"` => \n\nCodons: `\"AUG\", \"UUU\", \"UCU\", \"UAG\", \"AUG\"` => \n\nProtein: `\"Methionine\", \"Phenylalanine\", \"Serine\"`\n\nNote the stop codon terminates the translation and the final methionine is not translated into the protein sequence.  \n \nBelow are the codons and resulting Amino Acids needed for the exercise.  \n**|Codon|               **|Protein\n---------------------------------------\nAUG                   |Methionine\n\nUUU, UUC              |Phenylalanine\n\nUUA, UUG              |Leucine\n\nUCU, UCC, UCA, UCG    |Serine\n\nUAU, UAC              |Tyrosine\n\nUGU, UGC              |Cystine\n\nUGG                   |Tryptophan\n\nUAA, UAG, UGA         |STOP\n\nYou will need the Minitest gem. To install it, open a\nterminal window and run:\n\n    gem install minitest\n\n## Source\n\nTyler Long [view source]()\n"
      },
      "fresh": false
    }
  ]
}

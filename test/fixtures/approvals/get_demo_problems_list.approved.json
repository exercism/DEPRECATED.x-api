{
  "problems": [
    {
      "id": "clojure/bob",
      "track_id": "clojure",
      "language": "Clojure",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob_test.clj": "(ns bob-test\n  (:require [clojure.test :refer :all]))\n\n(load-file \"bob.clj\")\n\n(deftest responds-to-something\n  (is (= \"Whatever.\" (bob/response-for \"Tom-ay-to, tom-aaaah-to.\"))))\n\n(deftest responds-to-shouts\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WATCH OUT!\"))))\n\n(deftest responds-to-questions\n  (is (= \"Sure.\" (bob/response-for \"Does this cryogenic chamber make me look fat?\"))))\n\n(deftest responds-to-forceful-talking\n  (is (= \"Whatever.\" (bob/response-for \"Let's go make out behind the gym!\"))))\n\n(deftest responds-to-acronyms\n  (is (= \"Whatever.\" (bob/response-for \"It's OK if you don't want to go to the DMV.\"))))\n\n(deftest responds-to-forceful-questions\n  (is (= \"Whoa, chill out!\" (bob/response-for \"WHAT THE HELL WERE YOU THINKING?\"))))\n\n(deftest responds-to-shouting-with-special-characters\n  (is (= \"Whoa, chill out!\" (bob/response-for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"))))\n\n(deftest responds-to-shouting-numbers\n  (is (= \"Whoa, chill out!\" (bob/response-for \"1, 2, 3 GO!\"))))\n\n(deftest responds-to-shouting-with-no-exclamation-mark\n  (is (= \"Whoa, chill out!\" (bob/response-for \"I HATE YOU\"))))\n\n(deftest responds-to-statement-containing-question-mark\n  (is (= \"Whatever.\" (bob/response-for \"Ending with ? means a question.\"))))\n\n(deftest responds-to-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"\"))))\n\n(deftest responds-to-prolonged-silence\n  (is (= \"Fine. Be that way!\" (bob/response-for \"    \"))))\n\n(deftest responds-to-only-numbers\n  (is (= \"Whatever.\" (bob/response-for \"1, 2, 3\"))))\n\n(deftest responds-to-number-question\n  (is (= \"Sure.\" (bob/response-for \"4?\"))))\n\n(run-tests)\n",
        "project.clj": "(defproject bob \"0.1.0-SNAPSHOT\"\n  :description \"bob exercise.\"\n  :url \"https://github.com/exercism/xclojure/tree/master/bob\"\n  :source-paths [\"\"]\n  :test-paths [\"\"]\n  :dependencies [[org.clojure/clojure \"1.7.0\"]])\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "coffeescript/hello-world",
      "track_id": "coffeescript",
      "language": "CoffeeScript",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello_world.spec.coffee": "HelloWorld = require \"./hello_world\"\ndescribe \"HelloWorld\", ->\n  hello_world = new HelloWorld()\n  it \"given no name\", ->\n    result = hello_world.hello()\n    expect(result).toEqual \"Hello, World!\"\n  it \"given the name 'Alice'\", ->\n    result = hello_world.hello 'Alice'\n    expect(result).toEqual \"Hello, Alice!\"\n  it \"given the name 'Bob'\", ->\n    result = hello_world.hello 'Bob'\n    expect(result).toEqual \"Hello, Bob!\"\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nRefer to the [Exercism help page](http://help.exercism.io/getting-started-with-coffeescript.html) for getting started with CoffeeScript.\n\nIn order to run the test, you can run the test file from the exercise directory. For example, if the test suite is called hello_world.spec.coffee, you can run the following command:\n    jasmine-node --coffee hello_world.spec.coffee\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "cpp/bob",
      "track_id": "cpp",
      "language": "C++",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "CMakeLists.txt": "# Get the exercise name from the current directory\nget_filename_component(exercise ${CMAKE_CURRENT_SOURCE_DIR} NAME)\n\n# Basic CMake project\ncmake_minimum_required(VERSION 2.8.11)\n\n# Name the project after the exercise\nproject(${exercise} CXX)\n\n# Locate Boost libraries: unit_test_framework, date_time and regex\nset(Boost_USE_STATIC_LIBS ON)\nset(Boost_USE_MULTITHREADED ON)\nset(Boost_USE_STATIC_RUNTIME OFF)\nfind_package(Boost 1.55 REQUIRED COMPONENTS unit_test_framework date_time regex)\n\n# Enable C++11 features on gcc/clang\nif(\"${CMAKE_CXX_COMPILER_ID}\" MATCHES \"(GNU|Clang)\")\n    set(CMAKE_CXX_FLAGS \"-std=c++11\")\nendif()\n\n# Configure to run all the tests?\nif(${EXERCISM_RUN_ALL_TESTS})\n    add_definitions(-DEXERCISM_RUN_ALL_TESTS)\nendif()\n\n# Get a source filename from the exercise name by replacing -'s with _'s\nstring(REPLACE \"-\" \"_\" file ${exercise})\n\n# Implementation could be only a header\nif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${file}.cpp)\n    set(exercise_cpp ${file}.cpp)\nelse()\n    set(exercise_cpp \"\")\nendif()\n\n# Build executable from sources and headers\nadd_executable(${exercise} ${file}_test.cpp ${exercise_cpp} ${file}.h)\n\n# We need boost includes\ntarget_include_directories(${exercise} PRIVATE ${Boost_INCLUDE_DIRS})\n\n# We need boost libraries\ntarget_link_libraries(${exercise} ${Boost_LIBRARIES})\n\n# Tell MSVC not to warn us about unchecked iterators in debug builds\nif(${MSVC})\n    set_target_properties(${exercise} PROPERTIES\n        COMPILE_DEFINITIONS_DEBUG _SCL_SECURE_NO_WARNINGS)\nendif()\n\n# Run the tests on every build\nadd_custom_command(TARGET ${exercise} POST_BUILD COMMAND ${exercise})\n",
        "bob_test.cpp": "#include \"bob.h\"\n#define BOOST_TEST_MAIN\n#include <boost/test/unit_test.hpp>\n\nBOOST_AUTO_TEST_CASE(stating_something)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Tom-ay-to, tom-aaaah-to.\"));\n}\n\n#if defined(EXERCISM_RUN_ALL_TESTS)\nBOOST_AUTO_TEST_CASE(shouting)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WATCH OUT!\"));\n}\n\nBOOST_AUTO_TEST_CASE(asking_a_question)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Does this cryogenic chamber make me look fat?\"));\n}\n\nBOOST_AUTO_TEST_CASE(talking_forcefully)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Let's go make out behind the gym!\"));\n}\n\nBOOST_AUTO_TEST_CASE(using_acronyms_in_regular_speech)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"It's OK if you don't want to go to the DMV.\"));\n}\n\nBOOST_AUTO_TEST_CASE(forceful_questions)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"WHAT THE HELL WERE YOU THINKING?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"1, 2, 3 GO!\"));\n}\n\nBOOST_AUTO_TEST_CASE(only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"1, 2, 3\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_only_numbers)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"4?\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_special_characters)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\"));\n}\n\nBOOST_AUTO_TEST_CASE(shouting_with_no_exclamation_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whoa, chill out!\", bob::hey(\"I HATE YOU\"));\n}\n\nBOOST_AUTO_TEST_CASE(statement_containing_question_mark)\n{\n    BOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\"Ending with a ? means a question.\"));\n}\n\nBOOST_AUTO_TEST_CASE(prattling_on)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Wait! Hang on.  Are you going to be OK?\"));\n}\n\nBOOST_AUTO_TEST_CASE(question_with_trailing_whitespace)\n{\n    BOOST_REQUIRE_EQUAL(\"Sure.\", bob::hey(\"Are you ok? \"));\n}\n\nBOOST_AUTO_TEST_CASE(silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"\"));\n}\n\nBOOST_AUTO_TEST_CASE(prolonged_silence)\n{\n    BOOST_REQUIRE_EQUAL(\"Fine. Be that way!\", bob::hey(\"   \"));\n}\n\nBOOST_AUTO_TEST_CASE(not_all_silence)                                                                         \n{                                                                                                             \n\tBOOST_REQUIRE_EQUAL(\"Whatever.\", bob::hey(\" A bit of silence can be nice.  \"));                           \n}\n#endif\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Getting Started\n\nMake sure you have read the [getting started with C++](http://help.exercism.io/getting-started-with-cpp.html)\npage on the [exercism help site](http://help.exercism.io/).  This covers\nthe basic information on setting up the development environment expected\nby the exercises.\n\n## Passing the Tests\n\nGet the first test compiling, linking and passing by following the [three\nrules of test-driven development](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd).\nCreate just enough structure by declaring namespaces, functions, classes,\netc., to satisfy any compiler errors and get the test to fail.  Then write\njust enough code to get the test to pass.  Once you've done that,\nuncomment the next test by moving the following line past the next test.\n\n```C++\n#if defined(EXERCISM_RUN_ALL_TESTS)\n```\n\nThis may result in compile errors as new constructs may be invoked that\nyou haven't yet declared or defined.  Again, fix the compile errors minimally\nto get a failing test, then change the code minimally to pass the test,\nrefactor your implementation for readability and expressiveness and then\ngo on to the next test.\n\nTry to use standard C++11 facilities in preference to writing your own\nlow-level algorithms or facilities by hand.  [CppReference](http://en.cppreference.com/)\nis a wiki reference to the C++ language and standard library.  If you\nare new to C++, but have programmed in C, beware of\n[C traps and pitfalls](http://www.slideshare.net/LegalizeAdulthood/c-traps-and-pitfalls-for-c-programmers).\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "csharp/leap",
      "track_id": "csharp",
      "language": "C#",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "LeapTest.cs": "using NUnit.Framework;\n\n[TestFixture]\npublic class LeapTest\n{\n    [Test]\n    public void Valid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1996), Is.True);\n    }\n\n    [Ignore]\n    [Test]\n    public void Invalid_leap_year()\n    {\n        Assert.That(Year.IsLeap(1997), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_20th_century_is_not_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(1900), Is.False);\n    }\n\n    [Ignore]\n    [Test]\n    public void Turn_of_the_25th_century_is_a_leap_year()\n    {\n        Assert.That(Year.IsLeap(2400), Is.True);\n    }\n}",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure you're exercise file you're submitting is in the `exercism/csharp/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.cs` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/csharp/bob/bob.cs`.\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "ecmascript/hello-world",
      "track_id": "ecmascript",
      "language": "ECMAScript",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "gulpfile.js": "function getInputDirectory(argv) {\n  if (argv.input) {\n    return argv.input;\n  }\n  return '.';\n}\n\nfunction getOutputDirectory(argv) {\n  if (argv.output) {\n    return argv.output;\n  }\n  return 'traceur-output';\n}\n\nvar gulp = require('gulp'),\n  jasmine = require('gulp-jasmine'),\n  babel = require('gulp-babel'),\n  polyfill = require('babel/polyfill'),\n  del = require('del'),\n  argv  = require('yargs').argv,\n  inputDir = getInputDirectory(argv),\n  outputDir = getOutputDirectory(argv);\n\n// Gulp tasks definition\n\ngulp.task('default', [ 'test' ]);\n\ngulp.task('test', [ 'babel' ], function () {\n  return gulp.src([ outputDir + '/*.spec.js' ])\n    .pipe(jasmine());\n});\n\ngulp.task('babel', function () {\n  return gulp.src([ inputDir + '/*.js' ])\n    .pipe(babel())\n    .pipe(gulp.dest(outputDir));\n});\n\ngulp.task('clean', function (cb) {\n  del([ outputDir ], cb);\n});\n\n",
        "hello-world.js": "//\n// This is only a SKELETON file for the 'Hello World' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nclass HelloWorld {\n  hello(name) {\n    //\n    // YOUR CODE GOES HERE\n    //\n  }\n}\n\nexport default HelloWorld;\n\n",
        "hello-world.spec.js": "import HelloWorld from './hello-world';\n\ndescribe('Hello World', () => {\n  var helloWorld = new HelloWorld();\n\n  it('says hello world with no name', () => {\n    expect(helloWorld.hello('')).toEqual('Hello, World!');\n  });\n\n  xit('says hello to bob', () => {\n    expect(helloWorld.hello('Bob')).toEqual('Hello, Bob!');\n  });\n\n  xit('says hello to sally', () => {\n    expect(helloWorld.hello('Sally')).toEqual('Hello, Sally!');\n  });\n});\n\n",
        "package.json": "{\n  \"name\": \"assignment\",\n  \"version\": \"0.0.1\",\n  \"description\": \"Exercism ECMAScript assignment\",\n  \"scripts\": {\n    \"test\": \"gulp test\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/exercism/xecmascript\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/exercism/xecmascript/issues\"\n  },\n  \"homepage\": \"https://github.com/exercism/xecmascript\",\n  \"devDependencies\": {\n    \"gulp\": \"~3.9.0\",\n    \"gulp-jasmine\": \"~2.0.1\",\n    \"gulp-clean\": \"~0.3.1\",\n    \"del\": \"~2.0.2\",\n    \"yargs\": \"~3.27.0\",\n    \"gulp-babel\": \"~5.3.0\",\n    \"babel\": \"~5.8.29\"\n  }\n}\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n## Setup\n\nGo through the setup instructions for ECMAScript to\ninstall the necessary dependencies:\n\nhttp://help.exercism.io/getting-started-with-ecmascript.html\n\n## Requirements\n\nThey are already described in the link above, but just as a\nquick reference:\n\nInstall globally a tool to run [Gulp](http://gulpjs.com) if\nit is not installed yet:\n\n```bash\n$ npm install -g gulp-cli\n```\n\nInstall assignment dependencies:\n\n```bash\n$ npm install\n```\n\n## Making the test suite pass\n\nExecute the tests with:\n\n```bash\n$ gulp test\n```\n\nIn many test suites all but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "elisp/hello-world",
      "track_id": "elisp",
      "language": "Emacs Lisp",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello-world-test.el": ";;; hello-world-test.el --- Tests for Hello World (exercism)\n\n;;; Commentary:\n\n;;; Code:\n\n(load-file \"hello-world.el\")\n\n(ert-deftest no-args ()\n  (should (equal (hello) \"Hello, World!\")))\n\n(ert-deftest with-args ()\n  (should (equal (hello \"Emacs\") \"Hello, Emacs!\"))\n  (should (equal (hello \"Exercism\") \"Hello, Exercism!\")))\n\n(provide 'hello-world-test)\n\n;;; hello-world-test.el ends here\n",
        "hello-world.el": ";;; hello-world.el --- Hello World Exercise (exercism)\n\n;;; Commentary:\n\n;;; Code:\n\n\n(provide 'hello-world)\n;;; hello-world.el ends here\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "elixir/bob",
      "track_id": "elixir",
      "language": "Elixir",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob.exs": "defmodule Teenager do\n  def hey(input) do\n    cond do\n        true -> raise \"Your implementation goes here\"\n\n    end\n  end\nend\n",
        "bob_test.exs": "if System.get_env(\"EXERCISM_TEST_EXAMPLES\") do\n  Code.load_file(\"example.exs\")\nelse\n  Code.load_file(\"bob.exs\")\nend\n\nExUnit.start\nExUnit.configure(exclude: :pending)\n\ndefmodule TeenagerTest do\n  use ExUnit.Case, async: true\n\n  test \"stating something\" do\n    assert Teenager.hey(\"Tom-ay-to, tom-aaaah-to.\") == \"Whatever.\"\n  end\n\n  @tag :pending\n  test \"shouting\" do\n    assert Teenager.hey(\"WATCH OUT!\") == \"Whoa, chill out!\"\n  end\n\n  @tag :pending\n  test \"asking a question\" do\n    assert Teenager.hey(\"Does this cryogenic chamber make me look fat?\") == \"Sure.\"\n  end\n\n  @tag :pending\n  test \"talking forcefully\" do\n    assert Teenager.hey(\"Let's go make out behind the gym!\") == \"Whatever.\"\n  end\n\n  @tag :pending\n  test \"talking in capitals\" do\n    assert Teenager.hey(\"This Isn't Shouting!\") == \"Whatever.\"\n  end\n\n  @tag :pending\n  test \"shouting numbers\" do\n    assert Teenager.hey(\"1, 2, 3 GO!\") == \"Whoa, chill out!\"\n  end\n\n  @tag :pending\n  test \"shouting with special characters\" do\n    assert Teenager.hey(\"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\") == \"Whoa, chill out!\"\n  end\n\n  @tag :pending\n  test \"shouting with no exclamation mark\" do\n    assert Teenager.hey(\"I HATE YOU\") == \"Whoa, chill out!\"\n  end\n\n  @tag :pending\n  test \"statement containing question mark\" do\n    assert Teenager.hey(\"Ending with ? means a question.\") == \"Whatever.\"\n  end\n\n  @tag :pending\n  test \"silence\" do\n    assert Teenager.hey(\"\") == \"Fine. Be that way!\"\n  end\n\n  @tag :pending\n  test \"prolonged silence\" do\n    assert Teenager.hey(\"  \") == \"Fine. Be that way!\"\n  end\n\n  @tag :pending\n  test \"only numbers\" do\n    assert Teenager.hey(\"1, 2, 3\") == \"Whatever.\"\n  end\n\n  @tag :pending\n  test \"question with numbers\" do\n    assert Teenager.hey(\"4?\") == \"Sure.\"\n  end\n\n  @tag :pending\n  test \"shouting in Russian\" do\n    # Hopefully this is Russian for \"GET OUT\"\n    assert Teenager.hey(\"УХОДИТЬ\") == \"Whoa, chill out!\"\n  end\nend\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Running tests\n\n```bash\n$ elixir bob_test.exs\n```\n\n(Replace `bob_test.exs` with the name of the test file.)\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "erlang/leap",
      "track_id": "erlang",
      "language": "Erlang",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "leap_tests.erl": "% To run tests:\n% erl -make\n% erl -noshell -eval \"eunit:test(leap, [verbose])\" -s init stop\n%\n\n-module(leap_tests).\n\n-include_lib(\"eunit/include/eunit.hrl\").\n\nleap_year_test() ->\n  ?assert(leap:leap_year(1996)).\n\nnon_leap_year_test() ->\n  ?assertNot(leap:leap_year(1997)).\n\ncentury_test() ->\n  ?assertNot(leap:leap_year(1900)).\n\nfourth_century_test() ->\n  ?assert(leap:leap_year(2400)).\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "fsharp/sum-of-multiples",
      "track_id": "fsharp",
      "language": "F#",
      "slug": "sum-of-multiples",
      "name": "Sum Of Multiples",
      "files": {
        "SumOfMultiplesTest.fs": "﻿module SumOfMultiplesTest\n\nopen NUnit.Framework\nopen SumOfMultiples\n\n[<TestFixture>]\ntype SumOfMultiplesTest() =\n    let mutable sumOfMultiples = SumOfMultiples()\n    \n    [<Test>]\n    member tc.Sum_to_1() = \n        Assert.That(sumOfMultiples.To(0), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_3() = \n        Assert.That(sumOfMultiples.To(3), Is.EqualTo(0))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Sum_to_10() = \n        Assert.That(sumOfMultiples.To(10), Is.EqualTo(23))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_7_13_17_to_20() = \n        Assert.That(SumOfMultiples([7; 13; 17]).To(20), Is.EqualTo(51))\n\n    [<Test>]\n    [<Ignore>]\n    member tc.Configurable_43_47_to_10000() = \n        Assert.That(SumOfMultiples([43; 47]).To(10000), Is.EqualTo(2203160))",
        "README.md": "# Sum Of Multiples\n\nWrite a program that, given a number, can find the sum of all the multiples of particular numbers up to but not including that number.\n\nIf we list all the natural numbers up to but not including 15 that are\nmultiples of either 3 or 5, we get 3, 5, 6 and 9, 10, and 12.\n\nThe sum of these multiples is 45.\n\nWrite a program that can find the sum of the multiples of a given set of\nnumbers.\n\n\n## Source\n\nA variation on Problem 1 at Project Euler [view source](http://projecteuler.net/problem=1)\n"
      },
      "fresh": false
    },
    {
      "id": "go/leap",
      "track_id": "go",
      "language": "Go",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "cases_test.go": "package leap\n\n// Source: exercism/x-common\n// Commit: 945d08e Merge pull request #50 from soniakeys/master\n\nvar testCases = []struct {\n\tyear        int\n\texpected    bool\n\tdescription string\n}{\n\t{1996, true, \"leap year\"},\n\t{1997, false, \"non-leap year\"},\n\t{1998, false, \"non-leap even year\"},\n\t{1900, false, \"century\"},\n\t{2400, true, \"fourth century\"},\n\t{2000, true, \"Y2K\"},\n}\n",
        "leap.go": "// This is a \"stub\" file.  It's a little start on your solution.\n// It's not a complete solution though; you have to write some code.\n\n// This next comment is a \"build constraint.\"  It's here for, well, kind of\n// complicated testing purposes you don't need to worry about now.\n// Actually, you can delete it.\n\n// +build !example\n\n// The package name is expected by the test program.\n// It has to stay just the way it is.\npackage leap\n\n// TestVersion indentifies the version of the test program that you are\n// writing your code to.  If the test program changes in the future --\n// after you have posted this code to the Exercism site -- nitpickers\n// will see that your code can't necessarily be expected to pass the\n// current test suite because it was written to an earlier test version.\nconst TestVersion = 1\n\n// It's good style to write a comment here documenting IsLeapYear.\n// (But delete all these instructional comments!)\nfunc IsLeapYear(int) bool {\n\t// Write some code here to pass the test suite.\n}\n\n// Finally, remove all the stock comments here that you didn't write or edit.\n// They're here to to help you get started but they only clutter a finished\n// solution.  If you leave them in, nitpickers are likely to protest!\n",
        "leap_test.go": "package leap\n\nimport \"testing\"\n\n// Define a function IsLeapYear(int) bool.\n//\n// Also define an exported TestVersion with a value that matches\n// the internal testVersion here.\n\nconst testVersion = 1\n\n// Retired testVersions\n// (none) 4a9e144a3c5dc0d9773f4cf641ffe3efe48641d8\n\nfunc TestLeapYears(t *testing.T) {\n\tif TestVersion != testVersion {\n\t\tt.Fatalf(\"Found TestVersion = %v, want %v\", TestVersion, testVersion)\n\t}\n\tfor _, test := range testCases {\n\t\tobserved := IsLeapYear(test.year)\n\t\tif observed != test.expected {\n\t\t\tt.Fatalf(\"IsLeapYear(%d) = %t, want %t (%s)\",\n\t\t\t\ttest.year, observed, test.expected, test.description)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLeapYears(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range testCases {\n\t\t\tIsLeapYear(test.year)\n\t\t}\n\t}\n}\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nTo run the tests simply run the command `go test` in the exercise directory.\n\nIf the test suite contains benchmarks, you can run these with the `-bench`\nflag:\n\n    go test -bench .\n\nFor more detailed info about the Go track see the [help\npage](http://help.exercism.io/getting-started-with-go.html).\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "haskell/leap",
      "track_id": "haskell",
      "language": "Haskell",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "leap_test.hs": "import Test.HUnit (Assertion, (@=?), runTestTT, Test(..), Counts(..))\nimport System.Exit (ExitCode(..), exitWith)\nimport LeapYear (isLeapYear)\n\nexitProperly :: IO Counts -> IO ()\nexitProperly m = do\n  counts <- m\n  exitWith $ if failures counts /= 0 || errors counts /= 0 then ExitFailure 1 else ExitSuccess\n\ntestCase :: String -> Assertion -> Test\ntestCase label assertion = TestLabel label (TestCase assertion)\n\nmain :: IO ()\nmain = exitProperly $ runTestTT $ TestList\n       [ TestList isLeapYearTests ]\n\nisLeapYearTests :: [Test]\nisLeapYearTests =\n  [ testCase \"vanilla leap year\" $\n    True @=? isLeapYear 1996\n  , testCase \"any old year\" $\n    False @=? isLeapYear 1997\n  , testCase \"century\" $\n    False @=? isLeapYear 1900\n  , testCase \"exceptional century\" $\n    True @=? isLeapYear 2400\n  ]\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\nCheck out [Exercism\nHelp](http://help.exercism.io/getting-started-with-haskell.html) for\ninstructions to get started writing Haskell.\n\n## Running Tests\n\nUse `runhaskell` (included in the Haskell Platform) to compile and run your\nHaskell code.\n\n    $ runhaskell -Wall bob_test.hs\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "java/etl",
      "track_id": "java",
      "language": "Java",
      "slug": "etl",
      "name": "Etl",
      "files": {
        "build.gradle": "apply plugin: \"java\"\napply plugin: \"eclipse\"\napply plugin: \"idea\"\n\nrepositories {\n  mavenCentral()\n}\n\ndependencies {\n  testCompile \"junit:junit:4.10\"\n  testCompile \"org.easytesting:fest-assert-core:2.0M10\"\n  testCompile \"com.google.guava:guava:16+\"\n}\n",
        "src/main/java/Etl.java": "import java.util.List;\nimport java.util.Map;\n\npublic class Etl {\n   public Map<String, Integer> transform(Map<Integer, List<String>> old) {\n      return null;\n   }\n}\n",
        "src/test/java/EtlTest.java": "import com.google.common.collect.ImmutableMap;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.fest.assertions.api.Assertions.assertThat;\n\npublic class EtlTest {\n    private final Etl etl = new Etl();\n\n    @Test\n    public void testTransformOneValue() {\n        Map<Integer, List<String>> old = ImmutableMap.of(1, Arrays.asList(\"A\"));\n        Map<String, Integer> expected = ImmutableMap.of(\"a\", 1);\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testTransformMoreValues() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"i\", 1,\n                \"o\", 1,\n                \"u\", 1\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testMoreKeys() {\n        Map<Integer, List<String>> old = ImmutableMap.of(\n                1, Arrays.asList(\"A\", \"E\"),\n                2, Arrays.asList(\"D\", \"G\")\n        );\n        Map<String, Integer> expected = ImmutableMap.of(\n                \"a\", 1,\n                \"e\", 1,\n                \"d\", 2,\n                \"g\", 2\n        );\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n\n    @Test\n    public void testFullDataset() {\n        Map<Integer, List<String>> old = ImmutableMap.<Integer, List<String>>builder().\n                put(1, Arrays.asList(\"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\")).\n                put(2, Arrays.asList(\"D\", \"G\")).\n                put(3, Arrays.asList(\"B\", \"C\", \"M\", \"P\")).\n                put(4, Arrays.asList(\"F\", \"H\", \"V\", \"W\", \"Y\")).\n                put(5, Arrays.asList(\"K\")).\n                put(8, Arrays.asList(\"J\", \"X\")).\n                put(10, Arrays.asList(\"Q\", \"Z\")).\n                build();\n        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder().\n                put(\"a\", 1).put(\"b\", 3).put(\"c\", 3).put(\"d\", 2).put(\"e\", 1).\n                put(\"f\", 4).put(\"g\", 2).put(\"h\", 4).put(\"i\", 1).put(\"j\", 8).\n                put(\"k\", 5).put(\"l\", 1).put(\"m\", 3).put(\"n\", 1).put(\"o\", 1).\n                put(\"p\", 3).put(\"q\", 10).put(\"r\", 1).put(\"s\", 1).put(\"t\", 1).\n                put(\"u\", 1).put(\"v\", 4).put(\"w\", 4).put(\"x\", 8).put(\"y\", 4).\n                put(\"z\", 10).build();\n\n        assertThat(etl.transform(old)).isEqualTo(expected);\n    }\n}\n",
        "README.md": "# Etl\n\nWe are going to do the `Transform` step of an Extract-Transform-Load.\n\n### ETL\nExtract-Transform-Load (ETL) is a fancy way of saying, \"We have some crufty, legacy data over in this system, and now we need it in this shiny new system over here, so\nwe're going to migrate this.\"\n\n(Typically, this is followed by, \"We're only going to need to run this\nonce.\" That's then typically followed by much forehead slapping and\nmoaning about how stupid we could possibly be.)\n\n### The goal\nWe're going to extract some scrabble scores from a legacy system.\n\nThe old system stored a list of letters per score:\n\n- 1 point: \"A\", \"E\", \"I\", \"O\", \"U\", \"L\", \"N\", \"R\", \"S\", \"T\",\n- 2 points: \"D\", \"G\",\n- 3 points: \"B\", \"C\", \"M\", \"P\",\n- 4 points: \"F\", \"H\", \"V\", \"W\", \"Y\",\n- 5 points: \"K\",\n- 8 points: \"J\", \"X\",\n- 10 points: \"Q\", \"Z\",\n\nThe shiny new scrabble system instead stores the score per letter, which\nmakes it much faster and easier to calculate the score for a word. It\nalso stores the letters in lower-case regardless of the case of the\ninput letters:\n\n- \"a\" is worth 1 point.\n- \"b\" is worth 3 points.\n- \"c\" is worth 3 points.\n- \"d\" is worth 2 points.\n- Etc.\n\nYour mission, should you choose to accept it, is to write a program that\ntransforms the legacy data format to the shiny new format.\n\n### Notes\nNote that both the old and the new system use strings to represent\nletters, even in languages that have a separate data type for\ncharacters.\n\nA final note about scoring, Scrabble is played around the world in a\nvariety of languages, each with its own unique scoring table. For\nexample, an \"A\" is scored at 14 in the Basque-language version of the\ngame while being scored at 9 in the Latin-language version.\n\n\n## Source\n\nThe Jumpstart Lab team [view source](http://jumpstartlab.com)\n"
      },
      "fresh": false
    },
    {
      "id": "javascript/hello-world",
      "track_id": "javascript",
      "language": "JavaScript",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello-world.js": "//\n// This is only a SKELETON file for the 'Hello World' exercise. It's been provided as a\n// convenience to get you started writing code faster.\n// Make sure to look at test.script.js--that should give you some hints about what is\n// expected here.\n\nvar HelloWorld = function() {};\n\nHelloWorld.prototype.hello = function(input) {\n//\n// YOUR CODE GOES HERE\n//\n};\n\nmodule.exports = HelloWorld;\n",
        "hello-world.spec.js": "var HelloWorld = require('./hello-world');\n\ndescribe('Hello World', function() {\n  var helloWorld = new HelloWorld();\n\n  it('says hello world with no name', function() {\n    expect(helloWorld.hello('')).toEqual('Hello, World!');\n  });\n\n  xit('says hello to bob', function() {\n    expect(helloWorld.hello('Bob')).toEqual('Hello, Bob!');\n  });\n\n  xit('says hello to sally', function() {\n    expect(helloWorld.hello('Sally')).toEqual('Hello, Sally!');\n  });\n});\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n## Setup\n\nGo through the setup instructions for JavaScript to\ninstall the necessary dependencies:\n\nhttp://help.exercism.io/getting-started-with-javascript.html\n\n## Making the Test Suite Pass\n\nExecute the tests with:\n\n```bash\n$ jasmine-node .\n```\n\nIn many test suites all but the first test have been skipped.\n\nOnce you get a test passing, you can unskip the next one by\nchanging `xit` to `it`.\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "lfe/leap",
      "track_id": "lfe",
      "language": "Lisp Flavoured Erlang (LFE)",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "Makefile": "ERL     = $(shell which erl)\nLFETOOL = $(shell which lfetool)\nREBAR   = $(shell which rebar)\n\nifeq ($(ERL),)\n  $(error Can't find Erlang executable 'erl')\nelse ifeq ($(LFETOOL),)\n  $(error Can't find lfetool)\nelse ifeq ($(REBAR),)\n  $(error Can't find rebar)\nendif\n\nget-deps: ; $(REBAR) get-deps compile\n\nclean: ; rebar clean\n\ncompile: ; $(REBAR) compile\n\ntest: compile; $(LFETOOL) tests unit\n",
        "rebar.config": "{erl_opts, [debug_info, {src_dirs, [\"test\"]}]}.\n{lfe_first_files, []}.\n{deps_dir, [\"deps\"]}.\n{eunit_compile_opts,\n [{src_dirs, [\"test\"]}]}.\n{deps,\n [{lfe,   \".*\", {git, \"git://github.com/rvirding/lfe.git\", {tag, \"v0.9.2\"}}},\n  {ltest, \".*\", {git, \"git://github.com/lfex/ltest.git\",   {tag, \"0.6.1\"}}}]}.\n",
        "src/leap.app.src": "%% -*- erlang -*-\n{application, 'leap',\n [{description, \"\"},\n  {vsn, \"0.0.1\"},\n  {modules,\n   ['leap']},\n  {registered, []},\n  {applications,\n   [kernel, stdlib]},\n  {included_applications, []},\n  {env, []}]}.\n",
        "test/leap-tests.lfe": "(defmodule leap-tests\n  (behaviour ltest-unit)\n  (export all))\n\n(include-lib \"eunit/include/eunit.hrl\")\n(include-lib \"ltest/include/ltest-macros.lfe\")\n\n(deftest leap-year\n  (is (leap:leap-year 1996)))\n\n(deftest non-leap-year\n  (is-not (leap:leap-year 1997)))\n\n(deftest century\n  (is-not (leap:leap-year 1900)))\n\n(deftest fourth-century\n  (is (leap:leap-year 2400)))\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n* * * *\n\nFor installation and learning resources, refer to the\n[exercism help page](http://help.exercism.io/getting-started-with-lfe.html).\n\nFor running the tests provided, you will need `make`.  Open a terminal\nwindow and run the following from the exercise directory:\n\n    make test\n\nAnd you should now be able to see the results of the test suite for\nthe exercise.\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "lisp/point-mutations",
      "track_id": "lisp",
      "language": "Common Lisp",
      "slug": "point-mutations",
      "name": "Point Mutations",
      "files": {
        "dna.lisp": "(defpackage #:dna\n  (:use #:cl)\n  (:export #:hamming-distance))\n(in-package #:dna)\n\n(defun hamming-distance (dna1 dna2)\n  \"Determine number of mutations between DNA strands by computing the Hamming Distance.\"\n  )\n",
        "point-mutations-test.lisp": "(ql:quickload \"lisp-unit\")\n\n(defpackage #:point-mutations-test\n  (:use #:common-lisp #:lisp-unit))\n\n#-xlisp-test (load \"dna\")\n\n(in-package #:point-mutations-test)\n\n(define-test no-difference-between-empty-strands\n  (assert-equal 0 (dna:hamming-distance \"\" \"\")))\n\n(define-test no-difference-between-identical-strands\n  (assert-equal 0 (dna:hamming-distance \"GGACTGA\" \"GGACTGA\")))\n\n(define-test complete-hamming-distance-in-small-strand\n  (assert-equal 3 (dna:hamming-distance \"ACT\" \"GGA\")))\n\n(define-test small-hamming-distance-in-middle-somewhere\n  (assert-equal 1 (dna:hamming-distance \"GGACG\" \"GGTCG\")))\n\n(define-test larger-distance\n  (assert-equal 2 (dna:hamming-distance \"ACCAGGG\" \"ACTATGG\")))\n\n(define-test invalid-to-get-distance-for-different-length-strings\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGACAACAGCCAGCCGCCGGATT\" \"AGACATCTTTCAGCCGCCGGATTAGGCAA\"))\n  (assert-equal nil (dna:hamming-distance \"AGG\" \"AGACAACAGCCAGCCGCCGGATT\")))\n\n#-xlisp-test\n(let ((*print-errors* t)\n      (*print-failures* t))\n  (run-tests :all :point-mutations-test))\n",
        "README.md": "# Point Mutations\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. Hence you\nmay assume that only sequences of equal length will be passed to your hamming\ndistance function.\n\nCheck out\n[Exercism Help](http://help.exercism.io/getting-started-with-lisp.html)\nfor instructions to get started writing Common Lisp. That page will\nexplain how to install and setup a Lisp implementation and how to run\nthe tests.\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "id": "lua/hello-world",
      "track_id": "lua",
      "language": "Lua",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello-world_test.lua": "local HelloWorld = require('hello_world')\n\ndescribe('Hello World', function()\n\n  it('says hello world with no name', function()\n    local result = HelloWorld.hello()\n    assert.are.equals('Hello, world!', result)\n  end)\n\n  it('says hello to Bob', function()\n    local result = HelloWorld.hello('Bob')\n    assert.are.equals('Hello, Bob!', result)\n  end)\n\n  it('says hello to Sally', function()\n    local result = HelloWorld.hello('Sally')\n    assert.are.equals('Hello, Sally!', result)\n  end)\nend)\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n### Getting started\nFirst install lua using [homebrew][1]\n\n    $ brew install lua\n\nThen install [luarocks][2] to install packages for lua\n\n    $ brew install luarocks\n\nThen install [busted][3] testing framework for lua\n\n    $ luarocks install busted\n    \nThen run your test\n\n    $ busted bob_test.lua \n    \nOther resources\n\n  1. [Lua Style Guide][4]\n  2. [Learn Lua in 15 minutes][5] \n\n[1]: http://brew.sh/\n[2]: http://luarocks.org/\n[3]: http://olivinelabs.com/busted/\n[4]: https://github.com/Olivine-Labs/lua-style-guide\n[5]: http://tylerneylon.com/a/learn-lua/\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "objective-c/hello-world",
      "track_id": "objective-c",
      "language": "Objective-C",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "HelloWorldTest.m": "#import <XCTest/XCTest.h>\n#import \"HelloWorld.h\"\n\n@interface test_suite : XCTestCase\n\n@end\n\n@implementation test_suite\n\n- (HelloWorld *)helloWorld {\n  return [[HelloWorld alloc] init];\n}\n\n- (void)testNoName {\n  NSString *input = nil;\n  NSString *expected = @\"Hello, World!\";\n  NSString *result = [[self helloWorld] hello:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n- (void)testSampleName {\n  NSString *input = @\"Alice\";\n  NSString *expected = @\"Hello, Alice!\";\n  NSString *result = [[self helloWorld] hello:input];\n  XCTAssertEqualObjects(expected, result);\n}\n  \n- (void)testOtherSampleName {\n  NSString *input = @\"Bob\";\n  NSString *expected = @\"Hello, Bob!\";\n  NSString *result = [[self helloWorld] hello:input];\n  XCTAssertEqualObjects(expected, result);\n}\n\n@end\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n## Setup\n\nThere are two different methods of getting set up to run the tests with Objective-C:\n\n- Create an Xcode project with a test target which will run the tests.\n- Use the ruby gem `objc` as a test runner utility.\n\nBoth are described in more detail here: http://help.exercism.io/getting-started-with-objective-c.html\n\n\n### Submitting Exercises\n\nWhen submitting an exercise, make sure your solution file is in the same directory as the test code.\n\nFor example, if you're submitting `Bob.m` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/objective-c/bob/Bob.m`.\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "ocaml/bob",
      "track_id": "ocaml",
      "language": "OCaml",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "Makefile": "test: test.native\n\t@./test.native\n\ntest.native: *.ml *.mli\n\t@corebuild -quiet -pkg oUnit test.native\n\nclean:\n\trm -rf _build\n\n.PHONY: clean\n",
        "bob.mli": "(*\nAnswers to `hey` like a teenager.\n\n## Examples\n\n  # response_for \"\"\n  \"Fine. Be that way!\"\n\n  # response_for \"Do you like math?\"\n  \"Sure.\"\n\n  # response_for \"HELLO!\"\n  \"Woah, chill out!\"\n\n  # response_for \"Coding is cool.\"\n  \"Whatever.\"\n*)\nval response_for : string -> string\n",
        "test.ml": "open Core.Std\nopen OUnit2\nopen Bob\n\nlet ae exp got _test_ctxt = assert_equal ~printer:String.to_string exp got\n\nlet tests =\n  [\"something\">::\n     ae \"Whatever.\" (response_for \"Tom-ay-to, tom-aaaah-to.\");\n   \"shouts\">::\n     ae \"Whoa, chill out!\" (response_for \"WATCH OUT!\");\n   \"questions\">::\n     ae \"Sure.\" (response_for \"Does this cryogenic chamber make me look fat?\");\n   \"forceful talking\">::\n     ae \"Whatever.\" (response_for \"Let's go make out behind the gym!\");\n   \"acronyms\">::\n     ae \"Whatever.\" (response_for \"It's ok if you don't want to go to the DMV.\");\n   \"forceful questions\">::\n     ae \"Whoa, chill out!\" (response_for \"WHAT THE HELL WERE YOU THINKING?\");\n   \"shouting with special characters\">::\n     ae \"Whoa, chill out!\"\n       (response_for \"ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!\");\n   \"shouting numbers\">::\n     ae \"Whoa, chill out!\" (response_for \"1, 2, 3, GO!\");\n   \"statement containing question mark\">::\n     ae \"Whatever.\" (response_for \"Ending with ? means a question.\");\n   \"silence\">::\n     ae \"Fine. Be that way!\" (response_for \"\");\n   \"prolonged silence\">::\n     ae \"Fine. Be that way!\" (response_for \"   \");\n   \"non-letters with question\">::\n     ae \"Sure.\" (response_for \":) ?\");\n   \"multiple line questons\">::\n     ae \"Whatever.\"\n       (response_for \"\\nDoes this cryogenic chamber make me look fat? \\nno\");\n   \"other whitespace\">::\n     (* No unicode whitespace as OCaml Core doesn't seem to handle Unicode.\n      * Not it seems does it see ASCII 11 (\\v) as whitespace.\n     *)\n     ae \"Fine. Be that way!\" (response_for \"\\n\\r \\t\");\n   \"only numbers\">::\n     ae \"Whatever.\" (response_for \"1, 2, 3\");\n   \"question with only numbers\">::\n     ae \"Sure.\" (response_for \"4?\");\n  ]\n\nlet () =\n  run_test_tt_main (\"bob tests\" >::: tests)\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n## Running Tests\n\nBecause OCaml is a compiled language you need to compile your submission and the test code before you can run the tests. Compile with\n\n```bash\n$ corebuild -quiet test.native\n```\n\nand when successful run the tests by running the `test.native` executable:\n\n```bash\n./test.native\n```\n\nAlternatively just type\n\n```bash\nmake\n```\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "perl5/bob",
      "track_id": "perl5",
      "language": "Perl 5",
      "slug": "bob",
      "name": "Bob",
      "files": {
        "bob.pm": "#\n# This is a SKELETON file and has been provided to enable you to get working on the\n# first exercise more quickly.\n#\n\nuse 5.006;\nuse strict;\nuse warnings;\n\npackage Bob;\n\nour $VERSION = '1.000';\n\nuse Exporter 5.57 qw(import);\n\nour @EXPORT_OK = qw(hey);\n\nsub hey {\n#\n# YOUR CODE GOES HERE\n#\n}\n\n1;\n",
        "bob.t": "use strict;\nuse warnings;\nuse open ':std', ':encoding(utf8)';\nuse utf8;\n\nmy $module = $ENV{EXERCISM} ? 'Example' : 'Bob';\n\nuse Test::More;\n\nmy @cases = map {\n    {\n        input   => $_->[0],\n        expect  => $_->[1],\n        desc    => $_->[2],\n    }\n} (\n    # input                                             expected output       title\n    ['Tom-ay-to, tom-aaaah-to.',                       'Whatever.',          'stating something'],\n    ['WATCH OUT!',                                     'Whoa, chill out!',   'shouting'],\n    ['Does this cryogenic chamber make me look fat?',  'Sure.',              'question'],\n    ['You are, what, like 15?',                        'Sure.',              'numeric question'],\n    [\"Let's go make out behind the gym!\",              'Whatever.',          'talking forcefully'],\n    [\"It's OK if you don't want to go to the DMV.\",    'Whatever.',          'using acronyms in regular speech'],\n    ['WHAT THE HELL WERE YOU THINKING?',               'Whoa, chill out!',   'forceful questions'],\n    ['1, 2, 3 GO!',                                    'Whoa, chill out!',   'shouting numbers'],\n    ['1, 2, 3',                                        'Whatever.',          'only numbers'],\n    ['4?',                                             'Sure.',              'question with only numbers'],\n    ['ZOMG THE %^*@#$(*^ ZOMBIES ARE COMING!!11!!1!',  'Whoa, chill out!',   'shouting with special characters'],\n    [\"ÜMLÄÜTS!\",                                       'Whoa, chill out!',   'shouting with umlauts'],\n    [\"\\xdcML\\xc4\\xdcTS!\",                              'Whoa, chill out!',   'shouting with umlauts'],\n    ['_A',                                             'Whoa, chill out!',   'underscore shout - before'],\n    ['A_',                                             'Whoa, chill out!',   'underscore shout - after'],\n    ['$A',                                             'Whoa, chill out!',   'Dollar sign shout - before'],\n    ['A$',                                             'Whoa, chill out!',   'Dollar sign shout - after'],\n    [\"ÜMLäÜTS!\",                                       'Whatever.',          'speaking calmly with umlauts'],\n    ['I HATE YOU',                                     'Whoa, chill out!',   'shouting with no exclamation mark'],\n    ['Ending with ? means a question.',                'Whatever.',          'statement containing question mark'],\n    [\"Wait! Hang on. Are you going to be OK?\",         'Sure.',              'prattling on'],\n    ['',                                               'Fine. Be that way!', 'silence'],\n    ['    ',                                           'Fine. Be that way!', 'prolonged silence'],\n    [\"   \\nI just remembered...\",                      'Whatever.',          'Silence, then more'],\n);\n\nok -e \"$module.pm\", \"missing $module.pm\"\n    or BAIL_OUT(\"You need to create a module called $module.pm with a function called hey() that gets one parameter: The text Bob hears.\");\n\nuse_ok($module)\n    or BAIL_OUT(\"Does $module.pm compile?  Does it end with 1; ?\");\n\ncan_ok($module, 'hey')\n    or BAIL_OUT(\"Missing package $module; or missing sub hey()\");\n\nmy $sub = $module->can('hey');\n\nforeach my $c (@cases) {\n    #diag uc $c->{input};\n    my $title = $c->{desc} ? \"$c->{desc}: $c->{input}\" : $c->{input};\n    is $sub->( $c->{input} ), $c->{expect}, $title;\n}\n\ndone_testing();\n",
        "README.md": "# Bob\n\nBob is a lackadaisical teenager. In conversation, his responses are very limited.\n\nBob answers 'Sure.' if you ask him a question.\n\nHe answers 'Whoa, chill out!' if you yell at him.\n\nHe says 'Fine. Be that way!' if you address him without actually saying\nanything.\n\nHe answers 'Whatever.' to anything else.\n\n## Instructions\n\nRun the test file, and fix each of the errors in turn. When you get the\nfirst test to pass, go to the first pending or skipped test, and make\nthat pass as well. When all of the tests are passing, feel free to\nsubmit.\n\nRemember that passing code is just the first step. The goal is to work\ntowards a solution that is as readable and expressive as you can make\nit.\n\nPlease make your solution as general as possible. Good code doesn't just\npass the test suite, it works with any input that fits the\nspecification.\n\nHave fun!\n\n\n\n## Source\n\nInspired by the 'Deaf Grandma' exercise in Chris Pine's Learn to Program tutorial. [view source](http://pine.fm/LearnToProgram/?Chapter=06)\n"
      },
      "fresh": false
    },
    {
      "id": "php/hamming",
      "track_id": "php",
      "language": "PHP",
      "slug": "hamming",
      "name": "Hamming",
      "files": {
        "hamming.php": "<?php\n\n//\n// This is only a SKELETON file for the \"Hamming\" exercise. It's been provided as a\n// convenience to get you started writing code faster.\n//\n\nfunction distance($a, $b)\n{\n    //\n    // YOUR CODE GOES HERE\n    //\n}\n",
        "hamming_test.php": "<?php\n\nrequire \"hamming.php\";\n\nclass HammingComparatorTest extends PHPUnit_Framework_TestCase\n{\n\n    public function testNoDifferenceBetweenIdenticalStrands()\n    {\n        $this->assertEquals(0, distance('A', 'A'));\n    }\n\n    public function testCompleteHammingDistanceOfForSingleNucleotideStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('A', 'G'));\n    }\n\n    public function testCompleteHammingDistanceForSmallStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(2, distance('AG', 'CT'));\n    }\n\n    public function testSmallHammingDistance()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('AT', 'CT'));\n    }\n\n    public function testSmallHammingDistanceInLongerStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(1, distance('GGACG', 'GGTCG'));\n    }\n\n    public function testLargeHammingDistance()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(4, distance('GATACA', 'GCATAA'));\n    }\n\n    public function testHammingDistanceInVeryLongStrand()\n    {\n        $this->markTestSkipped();\n        $this->assertEquals(9, distance('GGACGGATTCTG', 'AGGACGGATTCT'));\n    }\n\n    public function testExceptionThrownWhenStrandsAreDifferentLength()\n    {\n        $this->markTestSkipped();\n        $this->setExpectedException('InvalidArgumentException', 'DNA strands must be of equal length.');\n        distance('GGACG', 'AGGACGTGG');\n    }\n}\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n## Making the Test Suite Pass\n\n1. Get [PHPUnit].\n\n        % wget --no-check-certificate https://phar.phpunit.de/phpunit.phar\n        % chmod +x phpunit.phar\n\n2. Execute the tests for an assignment.\n\n        % phpunit.phar wordy/wordy_test.php\n\n[PHPUnit]: http://phpunit.de\n\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "id": "plsql/hamming",
      "track_id": "plsql",
      "language": "PL/SQL",
      "slug": "hamming",
      "name": "Hamming",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match.\n\n## Setup\n\nYou'll need access to a mounted Oracle DB. If you don't have one already\ninstalled, here are a few options:\n* download VirtualBox from Oracle and run one of the freely\navailable images; at the time of writing, the easiest to get started with\nat the time of writing might be _Database App Development VM_. The\nimage is quite large...\n* download and install the a version of the Oracle DB itself. Developer licenses\nare free.\n* get a free workspace at https://apex.oracle.com\n\n**Note**: if you're using the online version of APEX, compilation errors will\nnot be indicated very clearly when working in _SQL Commands_ - you will simply\nget \"Error at line XX: PL/SQL: Statement ignored\"... More insight can be\nfound using the _Object Browser_ and navigating to the object you created\n(select either _Packages_ or _Procedures_ in the dropdown menu showing _Tables_,\ndepending on what you created for the exercise). Also, when you run statements,\n\"run\" each individual `create` statement individually by selecting its text.\nAPEX does not seem to like doing too much work at once...\n\nTo work on individual problems, a nice and free way is to use SQL Developer. If \nyou don't want to use yet another IDE, you can simply copy and paste your code\ninto a terminal / command prompt connected to the database. The files are\nprepared in a way that will simply overwrite the previously compiled version.\n\n#Exercise\n\n## Step 1\n\nCompile the test suite. You can easily do that by copy / pasting (let's call\nthat _installing_ for simplicity) into your terminal connected to a mounted\nOracle database.\n\nThis will fail, complaining that there is no package called `HAMMING#`.\n\nTo fix the error create the package by installing the prepared solution stub.\nNote that you will have to re-install the package body of `UT_HAMMING#`.\n\nA few words about naming: the `#` at the end of the name signifies that this\nis a package. `UT` means _unit test_. _PL/SQL_ has a maximum identifier length\nof 30 characters, which is why you will find that many words are abbreviated.\n\nIf you've worked with PL/SQL before, you might wonder why the template is a\npackage and not simply a standalone function. That would of course also be a\npossibility, but in practice standalone procedures or functions are rarely used.\n\n## Step 2\n\nTry to run the test. You will notice that you are missing the function's\nimplementation. Create it (see the test package for examples).\n\nNote that functions have to return a value, so for now just `return null;`.\n\n## Step 3\n\nRun the test again. It should now execute, but the test will fail.\nThat's where you get to actually implement the function!\n\n## Wash, Rinse, Repeat\n\nOnly the first test is enabled at first, the others are commented out. To enable\nthem, simply delete the `--` in front of the procedure call and they'll run\nwhen you next install the test package!\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hamming#.plsql\n\n",
        "hamming#.plsql": "create or replace package hamming#\nis\n  --+--------------------------------------------------------------------------+\n  -- Computes the Hamming distance between two starnds.\n  --\n  -- @param i_first  sequence to compare\n  -- @param i_second sequence to compare\n  --\n  -- @return         Hamming distance between i_first and i_second\n  --+--------------------------------------------------------------------------+\n  function distance (\n    i_first                                       varchar2\n   ,i_second                                      varchar2\n  ) return pls_integer;\n\nend hamming#;\n/\n\ncreate or replace package body hamming#\nis\n\nend hamming#;\n/\n",
        "ut_hamming#.plsql": "create or replace package ut_hamming#\nis\n  procedure run;\nend ut_hamming#;\n/\n\ncreate or replace package body ut_hamming#\nis\n\n  procedure test (\n    i_descn                                       varchar2\n   ,i_exp                                         pls_integer\n   ,i_act                                         pls_integer\n  )\n  is\n  begin\n    if i_exp = i_act then\n      dbms_output.put_line('SUCCESS: ' || i_descn);\n    else\n      dbms_output.put_line(\n           'FAILURE: '   || i_descn\n        || ': expected ' || nvl('' || i_exp, 'null')\n        || ', but got '  || nvl('' || i_act, 'null')\n        || '!'\n      );\n    end if;\n  end test;\n\n  procedure run\n  is\n  begin\n    test('test_no_difference_between_identical_strands'                    , 0, hamming#.distance(i_first => 'A'           , i_second => 'A'           ));\n    --test('test_complete_hamming_distance_of_for_single_nucleotide_strand', 1, hamming#.distance(i_first => 'A'           , i_second => 'G'           ));\n    --test('test_complete_hamming_distance_of_for_small_strand'            , 2, hamming#.distance(i_first => 'AG'          , i_second => 'CT'          ));\n    --test('test_small_hamming_distance'                                   , 1, hamming#.distance(i_first => 'AG'          , i_second => 'AT'          ));\n    --test('test_small_hamming_distance_in_longer_strand'                  , 1, hamming#.distance(i_first => 'GGACG'       , i_second => 'GGTCG'       ));\n    --test('test_nonunique_characters_within_first_strand'                 , 1, hamming#.distance(i_first => 'AGA'         , i_second => 'AGG'         ));\n    --test('test_nonunique_characters_within_second_strand'                , 1, hamming#.distance(i_first => 'AGG'         , i_second => 'AGA'         ));\n    --test('test_large_hamming_distance'                                   , 4, hamming#.distance(i_first => 'GATACA'      , i_second => 'GCATAA'      ));\n    --test('test_hamming_distance_in_very_long_strand'                     , 9, hamming#.distance(i_first => 'GGACGGATTCTG', i_second => 'AGGACGGATTCT'));\n  exception\n    when others then\n      dbms_output.put_line('Test execution failed.');\n      dbms_output.put_line(sqlerrm);\n  end run;\n\nend ut_hamming#;\n/\n\nbegin\n  ut_hamming#.run;\nend;\n/\n",
        "README.md": "# Hamming\n\nWrite a program that can calculate the Hamming difference between two DNA strands.\n\nA mutation is simply a mistake that occurs during the creation or\ncopying of a nucleic acid, in particular DNA. Because nucleic acids are\nvital to cellular functions, mutations tend to cause a ripple effect\nthroughout the cell. Although mutations are technically mistakes, a very\nrare mutation may equip the cell with a beneficial attribute. In fact,\nthe macro effects of evolution are attributable by the accumulated\nresult of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point\nmutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands\ntaken from different genomes with a common ancestor, we get a measure of\nthe minimum number of point mutations that could have occurred on the\nevolutionary path between the two strands.\n\nThis is called the 'Hamming distance'.\n\nIt is found by comparing two DNA strands and counting how many of the\nnucleotides are different from their equivalent in the other string.\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n\n# Implementation notes\n\nThe Hamming distance is only defined for sequences of equal length. This means\nthat based on the definition, each language could deal with getting sequences\nof equal length differently.\n\n## Setup\n\nGo through the setup instructions for PL/SQL to get ready to code:\n\nhttp://help.exercism.io/getting-started-with-plsql.html\n\n## Running the Tests\n\nExecute the tests by calling the `run` method in the respective `ut_<exercise>#` package.\nThe necessary code should be contained at the end of the test package.\nAs an example, the test for the _hamming_ exercise would be run using\n\n```\nbegin\n  ut_hamming#.run;\nend;\n/\n```\n\n## Source\n\nThe Calculating Point Mutations problem at Rosalind [view source](http://rosalind.info/problems/hamm/)\n"
      },
      "fresh": false
    },
    {
      "id": "python/hello-world",
      "track_id": "python",
      "language": "Python",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello_world.py": "#\n# Skeleton file for the Python \"Hello World\" exercise.\n#\n\n\ndef hello(name=''):\n    return\n",
        "hello_world_test.py": "# -*- coding: utf-8 -*-\n\nfrom __future__ import unicode_literals\nimport unittest\n\nimport hello_world\n\n\nclass BobTests(unittest.TestCase):\n\n    def test_hello_without_name(self):\n        self.assertEqual(\n            'Hello, World!',\n            hello_world.hello()\n        )\n\n    def test_hello_with_name(self):\n        self.assertEqual(\n            'Hello, Jane!',\n            hello_world.hello('Jane')\n        )\n\n    def test_hello_with_umlaut_name(self):\n        self.assertEqual(\n            'Hello, Jürgen!',\n            hello_world.hello('Jürgen')\n        )\n\nif __name__ == '__main__':\n    unittest.main()\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n### Submitting Exercises\n\nNote that, when trying to submit an exercise, make sure the solution is in the `exercism/python/<exerciseName>` directory.\n\nFor example, if you're submitting `bob.py` for the Bob exercise, the submit command would be something like `exercism submit <path_to_exercism_dir>/python/bob/bob.py`.\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "ruby/hello-world",
      "track_id": "ruby",
      "language": "Ruby",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "GETTING_STARTED.md": "# Getting Started\n\nThese exercises lean on Test-Driven Development (TDD), but they're not an\nexact match. If you want a gentle introduction to TDD using minitest in\nRuby, see the \"Intro to TDD\" over at JumpstartLab:\nhttp://tutorials.jumpstartlab.com/topics/testing/intro-to-tdd.html\n\nThe following steps assume that you are in the same directory as the test\nsuite.\n\nYou must have the `minitest` gem installed:\n\n    $ gem install minitest\n\n## Step 1\n\nRun the test suite. It's written using the Minitest framework, and can be\nrun with ruby:\n\n    $ ruby hello_world_test.rb\n\nThis will fail, complaining that there is no file called `hello_world`.\n\nTo fix the error create an empty file called `hello_world.rb` in the same\ndirectory as the `hello_world_test.rb` file.\n\n## Step 2\n\nRun the test again. It will give you a new error, since now the file exists,\nbut is empty and does not contain the expected code.\n\nDepending on what platform you are on, the error will look different, but\nthe way to fix it will be the same.\n\nOn Windows, it will complain about:\n\n    syntax error, unexpected end-of-input, expecting '('\n\nOn OS X and Linux, the error will be something like:\n\n    # Running:\n\n    ESSS\n\n    Finished in 0.001539s, 2599.0903 runs/s, 0.0000 assertions/s.\n\n    1) Error:\n    HelloWorldTest#test_no_name:\n    NameError: uninitialized constant HelloWorldTest::HelloWorld\n      hello-world/hello_world_test.rb:5:in `test_no_name'\n\nWithin the first test, we are referencing a constant named `HelloWorld` when\nwe say `HelloWorld.hello`. When Ruby sees a capitalized name like\n`HelloWorld`, it looks it up in a big huge list of all the constants it knows about,\nto see what it points to. It could point to anything, and often in Ruby we have\nconstants that point to definitions of classes or modules.\n\nWhen it looks `HelloWorld` up in its list, it doesn't find anything, so we need\nto make one.\n\n### Fixing the Error\n\nTo fix it, open up the hello_world.rb file and add the following code:\n\n    class HelloWorld\n    end\n\n### Understanding Test Failures\n\nWhether you are on Windows, Mac OS X or Linux, you will eventually be faced with\nerrors and failures that look a lot like the Mac OS X / Linux error above.\n\nThe letters `ESSS` show that there are four tests altogether,\nthat one of them has an error (`E`), and that three of them are skipped (`S`).\n\nThe goal is to have four passing tests, which will show as four dots: `....`.\n\nThe tests are run in randomized order, which will cause the letters to display\nin random order as well.\n\n## Step 3\n\nRun the test again.\n\n    1) Error:\n    HelloWorldTest#test_no_name:\n    NoMethodError: undefined method `hello' for HelloWorld:Class\n        hello_world_test.rb:5:in `test_no_name'\n\nThis time we have a `HelloWorld`, but we're trying tell it to `hello`, and\n`HelloWorld` doesn't understand that message.\n\nOpen up hello_world.rb and add a method definition inside the class:\n\n    class HelloWorld\n      def self.hello\n      end\n    end\n\n## Step 4\n\nRun the test again.\n\n    1) Failure:\n    HelloWorldTest#test_no_name [hello_world_test.rb:11]:\n    When given no name, we should greet the world!.\n    Expected: \"Hello, world!\"\n      Actual: nil\n\nUp until now we've been getting errors, this time we get a failure.\n\nAn error means that Ruby cannot even run properly because of things like missing\nfiles or syntax errors, or referring to things that don't exist.\n\nA failure is different. A failure is when Ruby is running just fine\nand the test is expecting one outcome, but getting another.\n\nThe test is expecting the `hello` method to return the string `\"Hello, world!\"`. The easiest way\nto make it pass, is to simply stick the string `\"Hello, world!\"` inside the method definition.\n\n## Step 6\n\nRun the test again.\n\nIf it fails you're going to need to read the error message carefully to figure\nout what went wrong, and then try again.\n\nIf it passes, then you're ready to move to the next step.\n\nOpen the hello_world_test.rb file, and find the word \"skip\". All but the first test\nstart with \"skip\", which tells Minitest to ignore the test. This is so that\nyou don't have to deal with all the failures at once.\n\nTo activate the next test, delete the \"skip\", and run the test suite again.\n\n## Wash, Rinse, Repeat\n\nDelete one \"skip\" at a time, and make each test pass before you move to the\nnext one.\n\n## Submit\n\nWhen everything is passing, you can submit your code with the following\ncommand:\n\n    $ exercism submit hello_world.rb\n\n",
        "hello_world_test.rb": "#!/usr/bin/env ruby\nbegin\n  gem 'minitest', '>= 5.0.0'\n  require 'minitest/autorun'\n  require_relative 'hello_world'\nrescue Gem::LoadError => e\n  puts \"\\nMissing Dependency:\\n#{e.backtrace.first} #{e.message}\"\n  puts 'Minitest 5.0 gem must be installed for the xRuby track.'\nrescue LoadError => e\n  puts \"\\nError:\\n#{e.backtrace.first} #{e.message}\"\n  puts DATA.read\n  exit 1\nend\n\n# Test data version:\n# 7668b09 Added hello world test definition\n\nclass HelloWorldTest < Minitest::Test\n  def test_no_name\n    assert_equal 'Hello, World!', HelloWorld.hello\n  end\n\n  def test_sample_name\n    skip\n    assert_equal 'Hello, Alice!', HelloWorld.hello('Alice')\n  end\n\n  def test_other_sample_name\n    skip\n    assert_equal 'Hello, Bob!', HelloWorld.hello('Bob')\n  end\nend\n\n__END__\n\n*****************************************************\nYou got an error, which is exactly as it should be.\nThis is the first step in the Test-Driven Development\n(TDD) process.\n\nThe most important part of the error is\n\n   cannot load such file\n\nIt's looking for a file named hello_world.rb that doesn't\nexist yet.\n\nTo fix the error, create an empty file named hello_world.rb\nin the same directory as the hello_world_test.rb file.\n\nThen run the test again.\n\nFor more guidance as you work on this exercise, see\nGETTING_STARTED.md.\n*****************************************************\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n* * * *\n\nFor installation and learning resources, refer to the\n[exercism help page](http://help.exercism.io/getting-started-with-ruby.html).\n\nFor running the tests provided, you will need the Minitest gem. Open a\nterminal window and run the following command to install minitest:\n\n    gem install minitest\n\nIf you would like color output, you can `require 'minitest/pride'` in\nthe test file, or note the alternative instruction, below, for running\nthe test file.\n\nIn order to run the test, you can run the test file from the exercise\ndirectory. For example, if the test suite is called\n`hello_world_test.rb`, you can run the following command:\n\n    ruby hello_world_test.rb\n\nTo include color from the command line:\n\n    ruby -rminitest/pride hello_world_test.rb\n\nThe test files may have the execution bit set so you may also be able to\nrun it like this:\n\n    ./hello_world_test.rb\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "rust/leap",
      "track_id": "rust",
      "language": "Rust",
      "slug": "leap",
      "name": "Leap",
      "files": {
        "Cargo.lock": "[root]\nname = \"leap\"\nversion = \"0.0.0\"\n\n",
        "Cargo.toml": "[package]\nname = \"leap\"\nversion = \"0.0.0\"\n",
        "tests/leap.rs": "extern crate leap;\n\n#[test]\nfn test_vanilla_leap_year() {\n    assert_eq!(leap::is_leap_year(1996), true);\n}\n\n#[test]\n#[ignore]\nfn test_any_old_year() {\n    assert_eq!(leap::is_leap_year(1997), false);\n}\n\n#[test]\n#[ignore]\nfn test_century() {\n    assert_eq!(leap::is_leap_year(1900), false);\n}\n\n#[test]\n#[ignore]\nfn test_exceptional_century() {\n    assert_eq!(leap::is_leap_year(2000), true);\n}\n",
        "README.md": "# Leap\n\nWrite a program that will take a year and report if it is a leap year.\n\nThe tricky thing here is that a leap year occurs:\n\n```plain\non every year that is evenly divisible by 4\n  except every year that is evenly divisible by 100\n    unless the year is also evenly divisible by 400\n```\n\nFor example, 1997 is not a leap year, but 1996 is.  1900 is not a leap\nyear, but 2000 is.\n\nIf your language provides a method in the standard library that does\nthis look-up, pretend it doesn't exist and implement it yourself.\n\n## Notes\n\nFor a delightful, four minute explanation of the whole leap year\nphenomenon, go watch [this youtube video][video].\n\n[video]: http://www.youtube.com/watch?v=xX96xng7sAE\n\n## Rust Installation\n\nRefer to the [exercism help page][help-page] for Rust installation and learning\nresources.\n\n## Writing the Code\n\nExecute the tests with:\n\n```bash\n$ cargo test\n```\n\nAll but the first test have been ignored.  After you get the first test to\npass, remove the ignore flag (`#[ignore]`) from the next test and get the tests\nto pass again.  The test file is located in the `tests` directory.   You can\nalso remove the ignore flag from all the tests to get them to run all at once\nif you wish.\n\nMake sure to read the [Crates and Modules](crates-and-modules) chapter if you\nhaven't already, it will help you with organizing your files.\n\n[help-page]: http://help.exercism.io/getting-started-with-rust.html\n[crates-and-modules]: http://doc.rust-lang.org/stable/book/crates-and-modules.html\n\n## Source\n\nJavaRanch Cattle Drive, exercise 3 [view source](http://www.javaranch.com/leap.jsp)\n"
      },
      "fresh": false
    },
    {
      "id": "scala/hello-world",
      "track_id": "scala",
      "language": "Scala",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "build.sbt": "scalaVersion := \"2.11.7\"\n\nlibraryDependencies += \"org.scalatest\" % \"scalatest_2.11\" % \"2.2.5\" % \"test\"\n",
        "src/test/scala/HelloWorldTest.scala": "import org.scalatest.{Matchers, FunSuite}\n\nclass HelloWorldTest extends FunSuite with Matchers {\n  test(\"Without name\") {\n    HelloWorld.hello() should be (\"Hello, World!\")\n  }\n\n  test(\"with name\") {\n    HelloWorld.hello(\"Jane\") should be (\"Hello, Jane!\")\n  }\n\n  test(\"with umlaut name\") {\n    HelloWorld.hello(\"Jürgen\") should be (\"Hello, Jürgen!\")\n  }\n}\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\nThe Scala exercises assume an SBT project scheme. The exercise solution source\nshould be placed within the exercise directory/src/main/scala. The exercise\nunit tests can be found within the exercise directory/src/test/scala.\n\nTo run the tests simply run the command `sbt test` in the exercise directory.\n\nFor more detailed info about the Scala track see the [help\npage](http://help.exercism.io/getting-started-with-scala.html).\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "scheme/hello-world",
      "track_id": "scheme",
      "language": "Scheme",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "hello-world-test.scm": ";; Load SRFI-64 lightweight testing specification\n(use-modules (srfi srfi-64))\n\n;; Suppress log file output. To write logs, comment out the following line:\n(module-define! (resolve-module '(srfi srfi-64)) 'test-log-to-file #f)\n\n;; Require module\n(add-to-load-path (dirname (current-filename)))\n(use-modules (hello-world))\n\n(test-begin \"hello-world\")\n\n(test-assert \"Called with no args returns hello world\"\n             (equal? (hello)\n                     \"Hello, World!\"))\n\n(test-assert \"Called with an arg returns hello arg\"\n             (equal? (hello \"exercism\")\n                     \"Hello, exercism!\"))\n\n(test-end \"hello-world\")\n",
        "hello-world.scm": "(define-module (hello-world)\n  #:export (hello))\n",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    },
    {
      "id": "swift/hello-world",
      "track_id": "swift",
      "language": "Swift",
      "slug": "hello-world",
      "name": "Hello World",
      "files": {
        "helloWorld.swift": "// Apple Swift version 2.0\n\n// Enter Solution Here",
        "helloWorld.xcodeproj/project.pbxproj": "// !$*UTF8*$!\n{\n\tarchiveVersion = 1;\n\tclasses = {\n\t};\n\tobjectVersion = 46;\n\tobjects = {\n\n/* Begin PBXBuildFile section */\n\t\t9DCE80801BA747050024C69D /* helloWorldTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9DCE807F1BA747050024C69D /* helloWorldTest.swift */; };\n\t\t9DCE80881BA748820024C69D /* helloWorld.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9DCE80871BA748820024C69D /* helloWorld.swift */; settings = {ASSET_TAGS = (); }; };\n/* End PBXBuildFile section */\n\n/* Begin PBXFileReference section */\n\t\t9DCE807D1BA747050024C69D /* helloWorldTest.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = helloWorldTest.xctest; sourceTree = BUILT_PRODUCTS_DIR; };\n\t\t9DCE807F1BA747050024C69D /* helloWorldTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = helloWorldTest.swift; sourceTree = \"<group>\"; };\n\t\t9DCE80811BA747050024C69D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = \"<group>\"; };\n\t\t9DCE80871BA748820024C69D /* helloWorld.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = helloWorld.swift; sourceTree = SOURCE_ROOT; };\n/* End PBXFileReference section */\n\n/* Begin PBXFrameworksBuildPhase section */\n\t\t9DCE807A1BA747050024C69D /* Frameworks */ = {\n\t\t\tisa = PBXFrameworksBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXFrameworksBuildPhase section */\n\n/* Begin PBXGroup section */\n\t\t9DCE80661BA746730024C69D = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t9DCE807E1BA747050024C69D /* helloWorldTest */,\n\t\t\t\t9DCE80701BA746730024C69D /* Products */,\n\t\t\t);\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t9DCE80701BA746730024C69D /* Products */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t9DCE807D1BA747050024C69D /* helloWorldTest.xctest */,\n\t\t\t);\n\t\t\tname = Products;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n\t\t9DCE807E1BA747050024C69D /* helloWorldTest */ = {\n\t\t\tisa = PBXGroup;\n\t\t\tchildren = (\n\t\t\t\t9DCE80871BA748820024C69D /* helloWorld.swift */,\n\t\t\t\t9DCE807F1BA747050024C69D /* helloWorldTest.swift */,\n\t\t\t\t9DCE80811BA747050024C69D /* Info.plist */,\n\t\t\t);\n\t\t\tpath = helloWorldTest;\n\t\t\tsourceTree = \"<group>\";\n\t\t};\n/* End PBXGroup section */\n\n/* Begin PBXNativeTarget section */\n\t\t9DCE807C1BA747050024C69D /* helloWorldTest */ = {\n\t\t\tisa = PBXNativeTarget;\n\t\t\tbuildConfigurationList = 9DCE80841BA747050024C69D /* Build configuration list for PBXNativeTarget \"helloWorldTest\" */;\n\t\t\tbuildPhases = (\n\t\t\t\t9DCE80791BA747050024C69D /* Sources */,\n\t\t\t\t9DCE807A1BA747050024C69D /* Frameworks */,\n\t\t\t\t9DCE807B1BA747050024C69D /* Resources */,\n\t\t\t);\n\t\t\tbuildRules = (\n\t\t\t);\n\t\t\tdependencies = (\n\t\t\t);\n\t\t\tname = helloWorldTest;\n\t\t\tproductName = helloWorldTest;\n\t\t\tproductReference = 9DCE807D1BA747050024C69D /* helloWorldTest.xctest */;\n\t\t\tproductType = \"com.apple.product-type.bundle.unit-test\";\n\t\t};\n/* End PBXNativeTarget section */\n\n/* Begin PBXProject section */\n\t\t9DCE80671BA746730024C69D /* Project object */ = {\n\t\t\tisa = PBXProject;\n\t\t\tattributes = {\n\t\t\t\tLastUpgradeCheck = 0700;\n\t\t\t\tORGANIZATIONNAME = exercism.io;\n\t\t\t\tTargetAttributes = {\n\t\t\t\t\t9DCE807C1BA747050024C69D = {\n\t\t\t\t\t\tCreatedOnToolsVersion = 7.0;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\tbuildConfigurationList = 9DCE806A1BA746730024C69D /* Build configuration list for PBXProject \"helloWorld\" */;\n\t\t\tcompatibilityVersion = \"Xcode 3.2\";\n\t\t\tdevelopmentRegion = English;\n\t\t\thasScannedForEncodings = 0;\n\t\t\tknownRegions = (\n\t\t\t\ten,\n\t\t\t);\n\t\t\tmainGroup = 9DCE80661BA746730024C69D;\n\t\t\tproductRefGroup = 9DCE80701BA746730024C69D /* Products */;\n\t\t\tprojectDirPath = \"\";\n\t\t\tprojectRoot = \"\";\n\t\t\ttargets = (\n\t\t\t\t9DCE807C1BA747050024C69D /* helloWorldTest */,\n\t\t\t);\n\t\t};\n/* End PBXProject section */\n\n/* Begin PBXResourcesBuildPhase section */\n\t\t9DCE807B1BA747050024C69D /* Resources */ = {\n\t\t\tisa = PBXResourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXResourcesBuildPhase section */\n\n/* Begin PBXSourcesBuildPhase section */\n\t\t9DCE80791BA747050024C69D /* Sources */ = {\n\t\t\tisa = PBXSourcesBuildPhase;\n\t\t\tbuildActionMask = 2147483647;\n\t\t\tfiles = (\n\t\t\t\t9DCE80801BA747050024C69D /* helloWorldTest.swift in Sources */,\n\t\t\t\t9DCE80881BA748820024C69D /* helloWorld.swift in Sources */,\n\t\t\t);\n\t\t\trunOnlyForDeploymentPostprocessing = 0;\n\t\t};\n/* End PBXSourcesBuildPhase section */\n\n/* Begin XCBuildConfiguration section */\n\t\t9DCE80741BA746740024C69D /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n\t\t\t\tCLANG_ENABLE_MODULES = YES;\n\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n\t\t\t\tCLANG_WARN_UNREACHABLE_CODE = YES;\n\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n\t\t\t\tCOPY_PHASE_STRIP = NO;\n\t\t\t\tDEBUG_INFORMATION_FORMAT = dwarf;\n\t\t\t\tENABLE_STRICT_OBJC_MSGSEND = YES;\n\t\t\t\tENABLE_TESTABILITY = YES;\n\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n\t\t\t\tGCC_NO_COMMON_BLOCKS = YES;\n\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n\t\t\t\t\t\"DEBUG=1\",\n\t\t\t\t\t\"$(inherited)\",\n\t\t\t\t);\n\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.10;\n\t\t\t\tMTL_ENABLE_DEBUG_INFO = YES;\n\t\t\t\tONLY_ACTIVE_ARCH = YES;\n\t\t\t\tSDKROOT = macosx;\n\t\t\t\tSWIFT_OPTIMIZATION_LEVEL = \"-Onone\";\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\t9DCE80751BA746740024C69D /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++0x\";\n\t\t\t\tCLANG_CXX_LIBRARY = \"libc++\";\n\t\t\t\tCLANG_ENABLE_MODULES = YES;\n\t\t\t\tCLANG_ENABLE_OBJC_ARC = YES;\n\t\t\t\tCLANG_WARN_BOOL_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_CONSTANT_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;\n\t\t\t\tCLANG_WARN_EMPTY_BODY = YES;\n\t\t\t\tCLANG_WARN_ENUM_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_INT_CONVERSION = YES;\n\t\t\t\tCLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;\n\t\t\t\tCLANG_WARN_UNREACHABLE_CODE = YES;\n\t\t\t\tCLANG_WARN__DUPLICATE_METHOD_MATCH = YES;\n\t\t\t\tCOPY_PHASE_STRIP = NO;\n\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n\t\t\t\tENABLE_NS_ASSERTIONS = NO;\n\t\t\t\tENABLE_STRICT_OBJC_MSGSEND = YES;\n\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n\t\t\t\tGCC_NO_COMMON_BLOCKS = YES;\n\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;\n\t\t\t\tGCC_WARN_UNDECLARED_SELECTOR = YES;\n\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;\n\t\t\t\tGCC_WARN_UNUSED_FUNCTION = YES;\n\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.10;\n\t\t\t\tMTL_ENABLE_DEBUG_INFO = NO;\n\t\t\t\tSDKROOT = macosx;\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n\t\t9DCE80821BA747050024C69D /* Debug */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tINFOPLIST_FILE = helloWorldTest/Info.plist;\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"$(inherited) @executable_path/../Frameworks @loader_path/../Frameworks\";\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = com.exercism.io.helloWorldTest;\n\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n\t\t\t};\n\t\t\tname = Debug;\n\t\t};\n\t\t9DCE80831BA747050024C69D /* Release */ = {\n\t\t\tisa = XCBuildConfiguration;\n\t\t\tbuildSettings = {\n\t\t\t\tCOMBINE_HIDPI_IMAGES = YES;\n\t\t\t\tINFOPLIST_FILE = helloWorldTest/Info.plist;\n\t\t\t\tLD_RUNPATH_SEARCH_PATHS = \"$(inherited) @executable_path/../Frameworks @loader_path/../Frameworks\";\n\t\t\t\tPRODUCT_BUNDLE_IDENTIFIER = com.exercism.io.helloWorldTest;\n\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n\t\t\t};\n\t\t\tname = Release;\n\t\t};\n/* End XCBuildConfiguration section */\n\n/* Begin XCConfigurationList section */\n\t\t9DCE806A1BA746730024C69D /* Build configuration list for PBXProject \"helloWorld\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\t9DCE80741BA746740024C69D /* Debug */,\n\t\t\t\t9DCE80751BA746740024C69D /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n\t\t9DCE80841BA747050024C69D /* Build configuration list for PBXNativeTarget \"helloWorldTest\" */ = {\n\t\t\tisa = XCConfigurationList;\n\t\t\tbuildConfigurations = (\n\t\t\t\t9DCE80821BA747050024C69D /* Debug */,\n\t\t\t\t9DCE80831BA747050024C69D /* Release */,\n\t\t\t);\n\t\t\tdefaultConfigurationIsVisible = 0;\n\t\t\tdefaultConfigurationName = Release;\n\t\t};\n/* End XCConfigurationList section */\n\t};\n\trootObject = 9DCE80671BA746730024C69D /* Project object */;\n}\n",
        "helloWorld.xcodeproj/project.xcworkspace/contents.xcworkspacedata": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Workspace\n   version = \"1.0\">\n   <FileRef\n      location = \"self:helloWorld.xcodeproj\">\n   </FileRef>\n</Workspace>\n",
        "helloWorld.xcodeproj/xcshareddata/xcschemes/helloWorldTest.xcscheme": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Scheme\n   LastUpgradeVersion = \"0700\"\n   version = \"1.3\">\n   <BuildAction\n      parallelizeBuildables = \"YES\"\n      buildImplicitDependencies = \"YES\">\n      <BuildActionEntries>\n         <BuildActionEntry\n            buildForTesting = \"YES\"\n            buildForRunning = \"YES\"\n            buildForProfiling = \"NO\"\n            buildForArchiving = \"NO\"\n            buildForAnalyzing = \"YES\">\n            <BuildableReference\n               BuildableIdentifier = \"primary\"\n               BlueprintIdentifier = \"9DCE807C1BA747050024C69D\"\n               BuildableName = \"helloWorldTest.xctest\"\n               BlueprintName = \"helloWorldTest\"\n               ReferencedContainer = \"container:helloWorld.xcodeproj\">\n            </BuildableReference>\n         </BuildActionEntry>\n      </BuildActionEntries>\n   </BuildAction>\n   <TestAction\n      buildConfiguration = \"Debug\"\n      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n      shouldUseLaunchSchemeArgsEnv = \"YES\">\n      <Testables>\n         <TestableReference\n            skipped = \"NO\">\n            <BuildableReference\n               BuildableIdentifier = \"primary\"\n               BlueprintIdentifier = \"9DCE807C1BA747050024C69D\"\n               BuildableName = \"helloWorldTest.xctest\"\n               BlueprintName = \"helloWorldTest\"\n               ReferencedContainer = \"container:helloWorld.xcodeproj\">\n            </BuildableReference>\n         </TestableReference>\n      </Testables>\n      <MacroExpansion>\n         <BuildableReference\n            BuildableIdentifier = \"primary\"\n            BlueprintIdentifier = \"9DCE807C1BA747050024C69D\"\n            BuildableName = \"helloWorldTest.xctest\"\n            BlueprintName = \"helloWorldTest\"\n            ReferencedContainer = \"container:helloWorld.xcodeproj\">\n         </BuildableReference>\n      </MacroExpansion>\n      <AdditionalOptions>\n      </AdditionalOptions>\n   </TestAction>\n   <LaunchAction\n      buildConfiguration = \"Debug\"\n      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n      launchStyle = \"0\"\n      useCustomWorkingDirectory = \"NO\"\n      ignoresPersistentStateOnLaunch = \"NO\"\n      debugDocumentVersioning = \"YES\"\n      debugServiceExtension = \"internal\"\n      allowLocationSimulation = \"YES\">\n      <MacroExpansion>\n         <BuildableReference\n            BuildableIdentifier = \"primary\"\n            BlueprintIdentifier = \"9DCE807C1BA747050024C69D\"\n            BuildableName = \"helloWorldTest.xctest\"\n            BlueprintName = \"helloWorldTest\"\n            ReferencedContainer = \"container:helloWorld.xcodeproj\">\n         </BuildableReference>\n      </MacroExpansion>\n      <AdditionalOptions>\n      </AdditionalOptions>\n   </LaunchAction>\n   <ProfileAction\n      buildConfiguration = \"Release\"\n      shouldUseLaunchSchemeArgsEnv = \"YES\"\n      savedToolIdentifier = \"\"\n      useCustomWorkingDirectory = \"NO\"\n      debugDocumentVersioning = \"YES\">\n   </ProfileAction>\n   <AnalyzeAction\n      buildConfiguration = \"Debug\">\n   </AnalyzeAction>\n   <ArchiveAction\n      buildConfiguration = \"Release\"\n      revealArchiveInOrganizer = \"YES\">\n   </ArchiveAction>\n</Scheme>\n",
        "helloWorldTest/Info.plist": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>CFBundleDevelopmentRegion</key>\n\t<string>en</string>\n\t<key>CFBundleExecutable</key>\n\t<string>$(EXECUTABLE_NAME)</string>\n\t<key>CFBundleIdentifier</key>\n\t<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>\n\t<key>CFBundleInfoDictionaryVersion</key>\n\t<string>6.0</string>\n\t<key>CFBundleName</key>\n\t<string>$(PRODUCT_NAME)</string>\n\t<key>CFBundlePackageType</key>\n\t<string>BNDL</string>\n\t<key>CFBundleShortVersionString</key>\n\t<string>1.0</string>\n\t<key>CFBundleSignature</key>\n\t<string>????</string>\n\t<key>CFBundleVersion</key>\n\t<string>1</string>\n</dict>\n</plist>\n",
        "helloWorldTest/helloWorldTest.swift": "import XCTest\n\n// Apple Swift version 2.0\n\nclass  HelloWorldTest: XCTestCase {\n    \n    func testNoName(){\n        let expected = \"Hello, World!\"\n        XCTAssertEqual(HelloWorld.hello(), expected, \"When given no name, we should greet the world!\")\n    }\n    \n    func testSampleName(){\n        let expected = \"Hello, Alice!\"\n        XCTAssertEqual(HelloWorld.hello(\"Alice\"), expected, \"When given 'Alice' we should greet Alice!\")\n    }\n    \n    func testOtherSampleName(){\n        let expected = \"Hello, Bob!\"\n        XCTAssertEqual(HelloWorld.hello(\"Bob\"), expected, \"When given 'Bob' we should greet Bob!\")\n    }\n    \n    func testNoStrangeName(){\n        let expected = \"Hello, !\"\n        XCTAssertEqual(HelloWorld.hello(\"\"), expected, \"When given an empty string, it is strange, but should have a space and punctuation\")\n    }\n    \n}",
        "README.md": "# Hello World\n\nWrite a program that greets the user by name, or by saying \"Hello, World!\" if no name is given.\n\n[\"Hello, World!\"](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program) is the traditional first program for beginning programming in a new language.\n\n**Note:** You can skip this exercise by running:\n\n    exercism skip $LANGUAGE hello-world\n\n## Specification\n\nThe `Hello World!` program will greet me, the caller.\n\nIf I tell the program my name is Alice, it will greet me by saying \"Hello, Alice!\".\n\nIf I neglect to give it my name, it will greet me by saying \"Hello, World!\"\n\n## Test-Driven Development\n\nAs programmers mature, they eventually want to test their code.\n\nHere at Exercism we simulate [Test-Driven Development](http://en.wikipedia.org/wiki/Test-driven_development) (TDD), where you write your tests before writing any functionality. The simulation comes in the form of a pre-written test suite, which will signal that you have solved the problem.\n\nIt will also provide you with a safety net to explore other solutions without breaking the functionality.\n\n### A typical TDD workflow on Exercism:\n\n1. Run the test file and pick one test that's failing.\n2. Write some code to fix the test you picked.\n3. Re-run the tests to confirm the test is now passing.\n4. Repeat from step 1.\n5. [Submit your solution](http://help.exercism.io/submitting-exercises.html).\n\n## Instructions\n\nSubmissions are encouraged to be general, within reason. Having said that, it's also important not to over-engineer a solution.\n\nIt's important to remember that the goal is to make code as expressive and readable as we can. However, solutions to the hello-world exercise will be not be reviewed by a person, but by rikki- the robot, who will offer an encouraging word.\n\n## Setup\r\n\r\nGo through the project setup instructions for Xcode using Swift:\r\n\r\nhttp://help.exercism.io/getting-started-with-swift.html\r\n\r\n\n## Source\n\nThis is a program to introduce users to using Exercism [view source](http://en.wikipedia.org/wiki/%22Hello,_world!%22_program)\n"
      },
      "fresh": false
    }
  ]
}
